[{"categories":["网络"],"content":"6.1、应用层概述我们在浏览器的地址中输入某个网站的域名后，就可以访问该网站的内容，这个就是万维网WWW应用，其相关的应用层协议为超文本传送协议HTTP 用户在浏览器地址栏中输入的是“见名知意”的域名，而TCP/IP的网际层使用IP地址来表示目的主机，从域名到IP地址的装转换，由属于应用层范畴的域名系统DNS，在后台帮用户完成 常见的应用 总结 ","date":"2022-03-09","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第6章（应用层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/#61应用层概述"},{"categories":["网络"],"content":"6.2、客户/服务器方式（C/S方式）和对等方式（P2P方式）","date":"2022-03-09","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第6章（应用层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/#62客户服务器方式cs方式和对等方式p2p方式"},{"categories":["网络"],"content":"概念","date":"2022-03-09","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第6章（应用层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/#概念"},{"categories":["网络"],"content":"客户/服务器方式（C/S方式）","date":"2022-03-09","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第6章（应用层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/#客户服务器方式cs方式"},{"categories":["网络"],"content":"对等方式（P2P方式）","date":"2022-03-09","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/:3:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第6章（应用层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/#对等方式p2p方式"},{"categories":["网络"],"content":"总结 ","date":"2022-03-09","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/:4:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第6章（应用层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/#总结"},{"categories":["网络"],"content":"6.3、动态主机配置协议DHCP","date":"2022-03-09","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第6章（应用层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/#63动态主机配置协议dhcp"},{"categories":["网络"],"content":"概念 互联网广泛使用的动态主机配置协议 DHCP (Dynamic Host Configuration Protocol) 提供了即插即用连网 (plug-and-play networking) 的机制。 这种机制允许一台计算机加入新的网络和获取 IP 地址，而不用手工配置。 ","date":"2022-03-09","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第6章（应用层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/#概念-1"},{"categories":["网络"],"content":"DHCP的作用在之前，如果要正常访问Web服务器，需要该主机手动配置网络的相关配置信息 如果主机数很多，就工作量大，容易出错 如果我们给网络中添加一台DHCP服务器 ","date":"2022-03-09","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第6章（应用层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/#dhcp的作用"},{"categories":["网络"],"content":"DHCP的工作过程DHCP 使用客户 - 服务器方式 需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送发现报文 （DHCP DISCOVER），这时该主机就成为 DHCP 客户。 本地网络上所有主机都能收到此广播报文，但只有 DHCP 服务器才回答此广播报文。 DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池 (address pool) 中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文（DHCP OFFER）。 DHCP 工作方式 DHCP 使用客户-服务器方式，采用请求/应答方式工作。 DHCP 基于 UDP 工作（DHCP报文在运输层会被封装成为UDP用户数据报），DHCP 服务器运行在 67 号端口， DHCP客户运行在 68 号端口。 DHCP交互过程 DHCP客户端将广播发送DHCP发现报文（DHCP DISCOVER） 事务ID DHCP客户端的MAC地址 封装该报文的IP数据报的源IP地址为0.0.0.0，这是因为主机目前还未分配到IP地址，因此使用该地址代替 目的IP地址为广播地址255.255.255.255，之所以广播发送，是因为主机现在并不知道网络中有哪几个DHCP服务器。它们的IP地址各是什么 DHCP服务器收到DHCP发现报文后，根据其中封装的DHCP客户端的MAC地址来查找自己的数据库，如果查到匹配信息，则使用这些配置信息来构建并发送DHCP提供报文，如果没有则采用默认配置信息来构建报文并发送 DHCP服务端将广播发送DHCP提供报文（DHCP OFFER） 事务ID：DHCP客户端会与之前DHCP发现报文的事务ID做对比，来判断该DHCP提供报文是否是自己的 配置信息： IP地址：DHCP服务器从自己的IP地址池中挑选待租用给主机的IP地址（使用ARP来确保所选IP地址未被网络中其他主机占用） 子网掩码 地址租期 默认网关 DNS服务器 源IP地址：发送DHCP提供报文的DHCP服务器的IP 目的地址：因为目的主机还没分配到IP，所以使用广播地址 在本例中，DHCP客户会收到两个DHCP服务器发来的DHCP提供报文，DHCP客户从中选择一个，一般选择先到的，并向所选择的DHCP服务器发送DHCP请求报文 DHCP客户端将广播发送DHCP请求报文（DHCP REQUEST） 事务ID DHCP客户端的MAC地址 接收的租约中的IP地址 提供此租约的DHCP服务器端的IP地址 源地址：0.0.0.0，因为此时DHCP客户才从多个DHCP服务器中挑选一个作为自己的DHCP服务器。它首先要征得该服务器的同意，之后才能正式使用向该DHCP服务器租用的IP地址 目的地址：广播地址，这样可以一次性向所有DHCP服务器发送DHCP请求报文，来告知它们是否请求它们作为自己的DHCP服务器 在本例中，假设DHCP客户端选择DHCP服务器1作为自己的DHCP服务器，DHCP服务器1接受该请求，于是DHCP服务器1给DHCP客户端发送DHCP确认报文 源地址：DHCP服务器1的IP地址 目的地址：广播地址 DHCP客户收到该报文后就可以使用租用的IP地址 在使用前还会进行ARP检测 剩下流程图示 ","date":"2022-03-09","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/:3:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第6章（应用层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/#dhcp的工作过程"},{"categories":["网络"],"content":"DHCP中继代理下图的网络拓扑中的各主机是否可以通过DHCP来自动获取到网络配置？ 使用DHCP中继代理是因为我们不用给每一个网络上都设置一个DHCP服务器，这样会使DHCP服务器的数量太多 ","date":"2022-03-09","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/:4:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第6章（应用层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/#dhcp中继代理"},{"categories":["网络"],"content":"总结 ","date":"2022-03-09","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/:5:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第6章（应用层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/#总结-1"},{"categories":["网络"],"content":"6.4、域名系统DNS","date":"2022-03-09","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第6章（应用层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/#64域名系统dns"},{"categories":["网络"],"content":"概述域名相比IP地址更容易记忆 因特网是否可以只使用一台DNS服务器？ 不行 名称相同的域名其等级未必相同 ","date":"2022-03-09","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第6章（应用层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/#概述"},{"categories":["网络"],"content":"域名解析过程","date":"2022-03-09","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第6章（应用层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/#域名解析过程"},{"categories":["网络"],"content":"总结 ","date":"2022-03-09","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/:3:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第6章（应用层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/#总结-2"},{"categories":["网络"],"content":"6.5、文件传送协议FTP","date":"2022-03-09","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第6章（应用层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/#65文件传送协议ftp"},{"categories":["网络"],"content":"概念","date":"2022-03-09","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第6章（应用层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/#概念-2"},{"categories":["网络"],"content":"文件传送协议FTP的应用FTP采用C/S方式（客户/服务器方式） FTP客户计算机可将各种类型的文件上传到FTP服务器计算机 FTP客户计算机也可以从FTP服务器计算机下载文件 ","date":"2022-03-09","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第6章（应用层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/#文件传送协议ftp的应用"},{"categories":["网络"],"content":"FTP基本工作原理FTP服务器监听熟知端口（端口号为 21），使客户进程能够连接上。 FTP客户随机选择一个临时端口号与其建立TCP连接，这条TCP连接用于FTP客户与服务器之间传送FTP的相关控制命令（这条连接是FTP客户与服务器之间的命令通道） 下图为建立数据通道的TCP连接 FTP服务器使用自己的熟知端口号20与其建立TCP连接，这条TCP连接用于FTP客户与服务器之间传送文件 上面例子是主动模式：建立数据通道时，FTP服务器主动连接FTP客户 下图实例为被动模式 两种模式对比 注意两种模式都是 控制连接在整个会话期间保持打开状态 数据连接传输完毕后就关闭 ","date":"2022-03-09","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/:3:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第6章（应用层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/#ftp基本工作原理"},{"categories":["网络"],"content":"总结 ","date":"2022-03-09","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/:4:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第6章（应用层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/#总结-3"},{"categories":["网络"],"content":"6.6、电子邮件","date":"2022-03-09","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第6章（应用层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/#66电子邮件"},{"categories":["网络"],"content":"概念","date":"2022-03-09","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第6章（应用层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/#概念-3"},{"categories":["网络"],"content":"邮件发送和接收过程","date":"2022-03-09","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第6章（应用层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/#邮件发送和接收过程"},{"categories":["网络"],"content":"简单邮件传送协议SMTP（Simple Mail Transfer Protocol）的基本工作原理","date":"2022-03-09","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/:3:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第6章（应用层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/#简单邮件传送协议smtpsimple-mail-transfer-protocol的基本工作原理"},{"categories":["网络"],"content":"电子邮件的信息格式","date":"2022-03-09","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/:4:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第6章（应用层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/#电子邮件的信息格式"},{"categories":["网络"],"content":"邮件读取","date":"2022-03-09","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/:5:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第6章（应用层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/#邮件读取"},{"categories":["网络"],"content":"基于万维网的电子邮件","date":"2022-03-09","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/:6:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第6章（应用层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/#基于万维网的电子邮件"},{"categories":["网络"],"content":"总结 ","date":"2022-03-09","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/:7:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第6章（应用层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/#总结-4"},{"categories":["网络"],"content":"6.7、万维网WWW","date":"2022-03-09","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第6章（应用层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/#67万维网www"},{"categories":["网络"],"content":"概念概述 万维网 WWW (World Wide Web) 并非某种特殊的计算机网络。 万维网是一个大规模的、联机式的信息储藏所。 万维网用链接的方法能非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息。 这种访问方式称为“链接”。 万维网的工作方式 万维网以客户 - 服务器方式工作。 浏览器就是在用户计算机上的万维网客户程序。万维网文档所驻留的计算机则运行服务器程序，因此这个计算机也称为万维网服务器。 客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档。 在一个客户程序主窗口上显示出的万维网文档称为页面 (page)。 万维网应用举例 访问网页 怎样标志分布在整个互联网上的万维网文档？ 万维网的文档 ","date":"2022-03-09","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第6章（应用层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/#概念-4"},{"categories":["网络"],"content":"超文本传输协议HTTP（Hyper Transfer Protocol）","date":"2022-03-09","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第6章（应用层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/#超文本传输协议httphyper-transfer-protocol"},{"categories":["网络"],"content":"概念和传输过程 在万维网客户程序与万维网服务器程序之间进行交互所使用的协议，是超文本传送协议 HTTP (HyperText Transfer Protocol)。 HTTP 是一个应用层协议，它使用 TCP 连接进行可靠的传送。 每个万维网网点都有一个服务器进程，它不断地监听 TCP 的端口 80，以便发现是否有浏览器向它发出连接建立请求。 一旦监听到连接建立请求并建立了 TCP 连接之后，浏览器就向万维网服务器发出浏览某个页面的请求，服务器接着就返回所请求的页面作为响应。 最后，TCP 连接就被释放了。 ","date":"2022-03-09","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/:2:1","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第6章（应用层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/#概念和传输过程"},{"categories":["网络"],"content":"HTTP报文格式HTTP请求报文格式 HTTP响应报文格式 ","date":"2022-03-09","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/:2:2","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第6章（应用层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/#http报文格式"},{"categories":["网络"],"content":"使用Cookie在服务器上记录用户信息","date":"2022-03-09","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/:2:3","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第6章（应用层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/#使用cookie在服务器上记录用户信息"},{"categories":["网络"],"content":"万维网缓存与代理服务器如果该请求有缓存 如果该请求没有缓存 若WEb缓存的命中率比较高 则会大大减小了该链路上的通信量，因而减少了访问因特网的时延 假设原始服务器的文档被更改，这样代理服务器的文档就不是最新的 所以原始服务器通常会为每个响应的对象设定一个修改时间字段和一个有效日期字段 若未过期 若过期并且代理服务器的文档和原始服务器的文档一致，原始服务器则给代理服务器发送不包含实体主体的响应 若过期并且代理服务器的文档和原始服务器的文档不一致，原始服务器则给代理服务器发送封装有该文档的响应报文 ","date":"2022-03-09","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/:2:4","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第6章（应用层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/#万维网缓存与代理服务器"},{"categories":["网络"],"content":"总结","date":"2022-03-09","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/:3:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第6章（应用层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/#总结-5"},{"categories":["网络"],"content":"5.1、运输层概述","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#51运输层概述"},{"categories":["网络"],"content":"概念进程之间的通信 从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。 当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到三层（到网络层）的功能。 进程之间通信流程 “逻辑通信”是指运输层之间的通信好像是沿水平方向传送数据，但事实上，这两条数据并没有一条水平方向的物理连接，要传送的数据是沿着图中上下多次的虚线方向传送的 进程Ap1与Ap4之间进行基于网络的通信，进程Ap2与Ap3之间进行基于网络的通信 在运输层使用不同的端口，来对应不同的应用进程 然后通过网络层及其下层来传输应用层报文 接收方的运输层通过不同的端口，将收到的应用层报文，交付给应用层中相应的应用进程 这里端口并不是指看得见、摸得着的物理端口，而是指用来区分不同应用进程的标识符 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#概念"},{"categories":["网络"],"content":"总结 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#总结"},{"categories":["网络"],"content":"5.2、运输层端口号、复用与分用的概念","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#52运输层端口号复用与分用的概念"},{"categories":["网络"],"content":"为什么用端口号","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#为什么用端口号"},{"categories":["网络"],"content":"发送方的复用和接收方的分用 多个进程（这里一个端口表示一个进程） 利用一个运输层协议（或者称为运输层接口）发送数据称为 复用 多个进程（这里一个端口表示一个进程） 利用一个运输层协议（或者称为运输层接口）接收时叫做 分用。 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#发送方的复用和接收方的分用"},{"categories":["网络"],"content":"TCP/IP体系的应用层常用协议所使用的运输层熟知端口号","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:3:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#tcpip体系的应用层常用协议所使用的运输层熟知端口号"},{"categories":["网络"],"content":"运输层传输流程举例 在浏览器输入域名，回车浏览 然后用户PC中的DNS客户端进程会发送一个DNS查询请求报文 DNS查询请求报文需要使用运输层的UDP协议 首部中的源端口字段的值，在短暂端口号49151~65535中挑选一个未被占用的，用来表示DNS客户端进程 首部中的目的端口字段的值：53，是DNS服务器端进程所使用的熟知端口号 之后，将UDP用户数据报封装在IP数据报中，通过以太网发送给DNS服务器 DNS服务器收到该IP数据报后，从中解封出UDP用户数据报 UDP首部中的目的端口号为53，这表明应将该UDP用户数据报的数据载荷部分，也就是DNS查询请求报文，交付给本服务器中的DNS服务器端进程 DNS服务器端进程解析DNS查询请求报文的内容，然后按其要求查找对应的IP地址 之后，会给用户PC发送DNS响应报文，DNS响应报文需要使用运输层的UDP协议封装成UDP用户数据报 其首部中的源端口字段的值设置为熟知端口号53，表明这是DNS服务器端进程所发送的UDP用户数据报，目的端口的值设置为49152，这是之前用户PC中发送DNS查询请求报文的DNS客户端进程所使用的短暂端口号 将UDP用户数据报封装在IP数据报中，通过以太网发送给用户PC 用户PC收到该数据报后，从中解封出UDP用户数据报 UDP首部中的目的端口号为49152，这表明应将该UDP用户数据报的数据载荷部分，也就是DNS响应报文，交付给用户PC中的DNS客户端进程 DNS客户端进程解析DNS响应报文的内容，就可知道自己之前所请求的Web服务器的域名对应的IP地址 现在用户PC中的HTTP客户端进程可以向Web服务器发送HTTP请求报文（和DNS发送和接收流程差不多） ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:4:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#运输层传输流程"},{"categories":["网络"],"content":"5.3、UDP和TCP的对比","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#53udp和tcp的对比"},{"categories":["网络"],"content":"概念 UDP 和 TCP 是TCP/IP体系结构运输层中的两个重要协议 当运输层采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条全双工的可靠信道。 当运输层采用无连接的 UDP 协议时，这种逻辑通信信道是一条不可靠信道。 可靠信道与不可靠信道 两个对等运输实体在通信时传送的数据单位叫作运输协议数据单元 TPDU (Transport Protocol Data Unit)。 TCP 传送的数据单位协议是 TCP 报文段(segment)。 UDP 传送的数据单位协议是 UDP 报文或用户数据报。 UDP的通信是无连接的，不需要套接字（Socket） TCP是面向连接的，TCP之间的通信必须要在两个套接字（Socket）之间建立连接 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#概念-1"},{"categories":["网络"],"content":"用户数据报协议UDP（User Datagram Protocol）可以发送广播 可以向某个多播组发送多播 还可以发送单播 UDP 支持单播、多播以及广播 换句话说，UDP支持一对一，一对多，以及一对全的通信 运输过程 UDP对应用进程交下来的报文既不合并也不拆分，而是保留这些报文的边界 换句话说，UDP是面向应用报文的 UDP向上层提供无连接不可靠传输服务 UDP结构 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#用户数据报协议udpuser-datagram-protocol"},{"categories":["网络"],"content":"传输控制协议TCP（Transmission Control Protocol）使用TCP协议的通信双方，在进行数据传输之前，必须使用“三报文握手”建立TCP连接 TCP连接建立成功后，通信双方之间就好像有一条可靠的通信信道，通信双方使用这条基于TCP连接的可靠信道进行通信 很显然，TCP仅支持单播，也就是一对一的通信 运输过程 发送方 TCP会把应用进程交付下来的数据块看作是一连串无结构的字节流，TCP并不知道这些待传送的字节流的含义 并将他们编号，并存储在自己发送缓存中 TCP会根据发送策略，提取一定量的字节构建TCP报文并发送 接收方 一方面从所接受到的TCP报文段中，取出数据载荷部分并存储在接收缓存中；一方面将接收缓存中的一些字节交付给应用进程 TCP不保证接收方应用进程所收到的数据块与发送方发送的数据块，具有对应大小的关系（例如，发送方应用进程交给发送方的TCP共10个数据块，但接收方的TCP可能只用了4个数据块，就把收到的字节流交付给了上层的应用进程，但接收方收到的字节流必须和发送方应用进程发出的字节流完全一样） 接收方的应用进程必须有能力识别收到的字节流，把它还原成有意义的应用层数据 TCP是面向字节流的，这正是TCP实现可靠传输、流量控制、以及拥塞控制的基础 本图只画了一个方向的数据流，在实际网络中，基于TCP连接的两端，可以同时进行TCP报文段的发送和接收 TCP向上层提供面向连接的可靠传输服务 TCP结构 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:3:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#传输控制协议tcptransmission-control-protocol"},{"categories":["网络"],"content":"总结 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:4:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#总结-1"},{"categories":["网络"],"content":"5.4、TCP的流量控制","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#54tcp的流量控制"},{"categories":["网络"],"content":"概念举例 具体流程的视频 上图主机A现在可将发送缓存中序号1~200的字节数据全部删除，因为已经收到了主机B对它们的累计确认 上图主机A现在可将发送缓存中序号201~500的字节数据全部删除，因为已经收到了主机B对它们的累计确认 上图主机A现在可将发送缓存中序号501~600的字节数据全部删除，因为已经收到了主机B对它们的累计确认 上图如果零窗口探测报文在发送过程中如果丢失，还是能打破死锁局面 因为零窗口探测报文段也有重传计时器，重传计时器超时后，零窗口探测报文段会被重传 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#概念-2"},{"categories":["网络"],"content":"总结 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#总结-2"},{"categories":["网络"],"content":"5.5、TCP的拥塞控制","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#55tcp的拥塞控制"},{"categories":["网络"],"content":"概念网络拥塞往往是由许多因素引起的。例如： 点缓存的容量太小； 链路的容量不足； 处理机处理的速率太慢； 拥塞本身会进一步加剧拥塞； 拥塞控制的一般原理 拥塞控制的前提：网络能够承受现有的网络负荷。 实践证明，拥塞控制是很难设计的，因为它是一个动态问题。 分组的丢失是网络发生拥塞的征兆而不是原因。 在许多情况下，甚至正是拥塞控制本身成为引起网络性能恶化、甚至发生死锁的原因。 开环控制和闭环控制 监测网络的拥塞 主要指标有： 由于缺少缓存空间而被丢弃的分组的百分数； 平均队列长度； 超时重传的分组数； 平均分组时延； 分组时延的标准差，等等。 上述这些指标的上升都标志着拥塞的增长。 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#概念-3"},{"categories":["网络"],"content":"拥塞控制的算法 真正的发送窗口值 = Min (接收方窗口值，拥塞窗口值) 下图的实例横纵坐标的意思 传输轮次： 发送方给接收方发送数据报文段后，接收方给发送方发发回相应的确认报文段 一个传输轮次所经历的时间其实就是往返时间，往返时间并非是恒定的数值 使用传输轮次是为了强调把拥塞窗口所允许发送的报文段都连续发送出去，并受到了对已发送的最后一个报文段的确认 拥塞窗口： 它会随网络拥塞程度，以及所使用的拥塞控制算法动态变化 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#拥塞控制的算法"},{"categories":["网络"],"content":"慢开始和拥塞避免慢开始（slow-start） 目的：用来确定网络的负载能力或拥塞程度。 算法的思路：由小到大逐渐增大拥塞窗口数值。 两个变量： 拥塞窗口（cwnd）：初始拥塞窗口值：2 种设置方法。窗口值逐渐增大。 1 至 2 个最大报文段 （旧标准） 2 至 4 个最大报文段 （RFC 5681） 慢开始门限（ssthresh）：防止拥塞窗口增长过大引起网络拥塞。 图中swnd是发送窗口 每经过一个传输轮次，拥塞窗口就加倍 窗口大小按指数增加，2的n-1次方 拥塞避免（congestion avoidance） 思路：让拥塞窗口 cwnd 缓慢地增大，避免出现拥塞。 每经过一个传输轮次，拥塞窗口 cwnd = cwnd + 1。 使拥塞窗口 cwnd 按线性规律缓慢增长。 在拥塞避免阶段，具有 “加法增大” (Additive Increase) 的特点。 如果在发送过程中出现部分报文段丢失，这必然会造成发送方对这些丢失报文段的超时重传 这个时候又回到了慢开始 两个算法完整示意图","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:2:1","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#慢开始和拥塞避免"},{"categories":["网络"],"content":"慢开始和拥塞避免慢开始（slow-start） 目的：用来确定网络的负载能力或拥塞程度。 算法的思路：由小到大逐渐增大拥塞窗口数值。 两个变量： 拥塞窗口（cwnd）：初始拥塞窗口值：2 种设置方法。窗口值逐渐增大。 1 至 2 个最大报文段 （旧标准） 2 至 4 个最大报文段 （RFC 5681） 慢开始门限（ssthresh）：防止拥塞窗口增长过大引起网络拥塞。 图中swnd是发送窗口 每经过一个传输轮次，拥塞窗口就加倍 窗口大小按指数增加，2的n-1次方 拥塞避免（congestion avoidance） 思路：让拥塞窗口 cwnd 缓慢地增大，避免出现拥塞。 每经过一个传输轮次，拥塞窗口 cwnd = cwnd + 1。 使拥塞窗口 cwnd 按线性规律缓慢增长。 在拥塞避免阶段，具有 “加法增大” (Additive Increase) 的特点。 如果在发送过程中出现部分报文段丢失，这必然会造成发送方对这些丢失报文段的超时重传 这个时候又回到了慢开始 两个算法完整示意图","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:2:1","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#慢开始slow-start"},{"categories":["网络"],"content":"慢开始和拥塞避免慢开始（slow-start） 目的：用来确定网络的负载能力或拥塞程度。 算法的思路：由小到大逐渐增大拥塞窗口数值。 两个变量： 拥塞窗口（cwnd）：初始拥塞窗口值：2 种设置方法。窗口值逐渐增大。 1 至 2 个最大报文段 （旧标准） 2 至 4 个最大报文段 （RFC 5681） 慢开始门限（ssthresh）：防止拥塞窗口增长过大引起网络拥塞。 图中swnd是发送窗口 每经过一个传输轮次，拥塞窗口就加倍 窗口大小按指数增加，2的n-1次方 拥塞避免（congestion avoidance） 思路：让拥塞窗口 cwnd 缓慢地增大，避免出现拥塞。 每经过一个传输轮次，拥塞窗口 cwnd = cwnd + 1。 使拥塞窗口 cwnd 按线性规律缓慢增长。 在拥塞避免阶段，具有 “加法增大” (Additive Increase) 的特点。 如果在发送过程中出现部分报文段丢失，这必然会造成发送方对这些丢失报文段的超时重传 这个时候又回到了慢开始 两个算法完整示意图","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:2:1","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#拥塞避免congestion-avoidance"},{"categories":["网络"],"content":"慢开始和拥塞避免慢开始（slow-start） 目的：用来确定网络的负载能力或拥塞程度。 算法的思路：由小到大逐渐增大拥塞窗口数值。 两个变量： 拥塞窗口（cwnd）：初始拥塞窗口值：2 种设置方法。窗口值逐渐增大。 1 至 2 个最大报文段 （旧标准） 2 至 4 个最大报文段 （RFC 5681） 慢开始门限（ssthresh）：防止拥塞窗口增长过大引起网络拥塞。 图中swnd是发送窗口 每经过一个传输轮次，拥塞窗口就加倍 窗口大小按指数增加，2的n-1次方 拥塞避免（congestion avoidance） 思路：让拥塞窗口 cwnd 缓慢地增大，避免出现拥塞。 每经过一个传输轮次，拥塞窗口 cwnd = cwnd + 1。 使拥塞窗口 cwnd 按线性规律缓慢增长。 在拥塞避免阶段，具有 “加法增大” (Additive Increase) 的特点。 如果在发送过程中出现部分报文段丢失，这必然会造成发送方对这些丢失报文段的超时重传 这个时候又回到了慢开始 两个算法完整示意图","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:2:1","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#两个算法完整示意图"},{"categories":["网络"],"content":"快重传和快恢复快重传（fast retrasmit）快恢复（fast recovery）改进后的整体算法的示意图 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:2:2","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#快重传和快恢复"},{"categories":["网络"],"content":"快重传和快恢复快重传（fast retrasmit）快恢复（fast recovery）改进后的整体算法的示意图 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:2:2","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#快重传fast-retrasmit"},{"categories":["网络"],"content":"快重传和快恢复快重传（fast retrasmit）快恢复（fast recovery）改进后的整体算法的示意图 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:2:2","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#快恢复fast-recovery"},{"categories":["网络"],"content":"快重传和快恢复快重传（fast retrasmit）快恢复（fast recovery）改进后的整体算法的示意图 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:2:2","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#改进后的整体算法的示意图"},{"categories":["网络"],"content":"5.6、TCP超时重传时间的选择 如果超时重传时间RTO的值设置得比RTT0的值小很多，这会引起报文段不必要的重传，使网络负荷增大 如果超时重传时间RTO的值设置得远大于RTT0的值，这会使重传时间推迟的太长，使网络的空闲时间增大，降低传输效率 RFC6298建议使用下式计算超时重传时间RTO 往返时间RTT的测量比较复杂 TCP超时重传的计算 举例 总结 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#56tcp超时重传时间的选择"},{"categories":["网络"],"content":"5.7、TCP可靠传输的实现本集具体讲解 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#57tcp可靠传输的实现"},{"categories":["网络"],"content":"5.8、TCP的运输连接管理","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#58tcp的运输连接管理"},{"categories":["网络"],"content":"概念","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#概念-4"},{"categories":["网络"],"content":"TCP的连接建立 TCP 建立连接的过程叫做握手。 握手需要在客户和服务器之间交换三个 TCP 报文段。称之为三报文握手。 采用三报文握手主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误。 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#tcp的连接建立"},{"categories":["网络"],"content":"TCP的连接建立要解决以下三个问题","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:2:1","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#tcp的连接建立要解决以下三个问题"},{"categories":["网络"],"content":"TCP使用“三报文握手”建立连接 TCP 连接的建立采用客户服务器方式。 主动发起连接建立的应用进程叫做TCP客户 (client)。 被动等待连接建立的应用进程叫做TCP服务器 (server)。 “握手”需要在TCP客户端和服务器之间交换三个TCP报文段 过程 最初两端的TCP进程都处于关闭状态 一开始，TCP服务器进程首先创建传输控制块，用来存储TCP连接中的一些重要信息。例如TCP连接表、指向发送和接收缓存的指针、指向重传队列的指针，当前的发送和接收序号等 之后，就准备接受TCP客户端进程的连接请求 此时，TCP服务器进程就进入监听状态，等待TCP客户端进程的连接请求 TCP服务器进程是被动等待来自TCP客户端进程的连接请求，因此成为被动打开连接 TCP客户进程也是首先创建传输控制块 由于TCP连接建立是由TCP客户端主动发起的，因此称为主动打开连接 然后，在打算建立TCP连接时，向TCP服务器进程发送TCP连接请求报文段，并进入同步已发送状态 TCP连接请求报文段首部中 同步位SYN被设置为1，表明这是一个TCP连接请求报文段 序号字段seq被设置了一个初始值x，作为TCP客户端进程所选择的初始序号 请注意：TCP规定SYN被设置为1的报文段不能携带数据，但要消耗掉一个序号 TCP服务器进程收到TCP连接请求报文段后，如果同意建立连接，则向TCP客户进程发送TCP连接请求确认报文段，并进入同步已接收状态 TCP连接请求确认报文段首部中 同步位SYN和确认为ACK都设置为1，表明这是一个TCP连接请求确认报文段 序号字段seq被设置了一个初始值y，作为TCP服务器进程所选择的初始序号， 确认号字段ack的值被设置成了x+1，这是对TCP客户进程所选择的初始序号（seq）的确认 请注意：这个报文段也不能携带数据，因为它是SYN被设置为1的报文段，但同样要消耗掉一个序号 TCP客户进程收到TCP连接请求确认报文段后，还要向TCP服务器进程发送一个普通的TCP确认报文段，并进入连接已连接状态 普通的TCP确认报文段首部中 确认位ACK被设置为1，表明这是一个普通的TCP确认报文段 序号字段seq被设置为x+1，这是因为TCP客户进程发送的第一个TCP报文段的序号为x，所以TCP客户进程发送的第二个报文段的序号为x+1 确认号字段ack被设置为y+1，这是对TCP服务器进程所选择的初始序号的确认 请注意：TCP规定普通的TCP确认报文段可以携带数据，但如果不携带数据，则不消耗序号 TCP服务器进程收到该确认报文段后也进入连接已建立状态 现在，TCP双方都进入了连接已建立状态，它们可以基于已建立好的TCP连接，进行可靠的数据传输 为什么TCP客户进程最后还要发送一个普通的TCP确认报文段？能否使用“两报文握手”建立连接？ 下图实例是“两报文握手” 为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误”，这种情况是：一端(client)A发出去的第一个连接请求报文并没有\u003e 丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到连接释放以后的某个时间才到达另一端(server)B。本来这是一个\u003e 早已失效的报文段，但是B收到此失效的报文之后，会误认为是A再次发出的一个新的连接请求，于是B端就向A又发出确认报文，表示同\u003e 意建立连接。如果不采用“三次握手”，那么只要B端发出确认报文就会认为新的连接已经建立了，但是A端并没有发出建立连接的请求，因\u003e 此不会去向B端发送数据，B端没有收到数据就会一直等待，这样B端就会白白浪费掉很多资源。 所以并不多余，这是为了防止已失效的连接请求报文段突然又传送到了TCP服务器，因而导致错误 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:2:2","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#tcp使用三报文握手建立连接"},{"categories":["网络"],"content":"总结","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:2:3","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#总结-3"},{"categories":["网络"],"content":"TCP的连接释放 TCP 连接释放过程比较复杂。 数据传输结束后，通信的双方都可释放连接。 TCP 连接释放过程是四报文握手。 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:3:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#tcp的连接释放"},{"categories":["网络"],"content":"TCP通过“四报文挥手”来释放连接 TCP 连接的建立采用客户服务器方式。 主动发起连接建立的应用进程叫做TCP客户 (client)。 被动等待连接建立的应用进程叫做TCP服务器 (server)。 任何一方都可以在数据传送结束后发出连接释放的通知 过程 现在TCP客户进程和TCP服务器进程都处于连接已建立状态 TCP客户进程的应用进程通知其主动关闭TCP连接 TCP客户进程会发送TCP连接释放报文段，并进入终止等待1状态 TCP连接释放报文段首部中 终止位FIN和确认为ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认 序号seq字段的值设置为u，它等于TCP客户进程之前已传送过的数据的最后一个字节的序号加1 确认号ack字段的值设置为v，它等于TCP客户进程之前已收到的、数据的最后一个字节的序号加1 请注意：TCP规定终止位FIN等于1的报文段即使不携带数据，也要消耗掉一个序号 TCP服务器进程收到TCP连接释放报文段后，会发送一个普通的TCP确认报文段并进入关闭等待状态 普通的TCP确认报文段首部中 确认位ACK的值被设置为1，表明这是一个普通的TCP确认报文段 序号seq字段的值设置为v，它等于TCP服务器进程之前已传送过的数据的最后一个字节的序号加1，这也与之前收到的TCP连接释放报文段中的确认号匹配 确认号ack字段的值设置为u+1，这是对TCP连接释放报文段的确认 TCP服务器进程应该通知高层应用进程，TCP客户进程要断开与自己的TCP连接 此时，从TCP客户进程到TCP服务器进程这个方向的连接就释放了 这时的TCP连接属于半关闭状态，也就是TCP客户进程已经没有数据要发送了 但如果TCP服务器进程还有数据要发送，TCP客户进程仍要接收，也就是说从TCP服务器进程到TCP客户进程这个方向的连接并未关闭 TCP客户进程收到TCP确认报文段后就进入终止等待2状态，等待TCP服务器进程发出的TCP连接释放报文段 若使用TCP服务器进程的应用进程已经没有数据要发送了，应用进程就通知其TCP服务器进程释放连接 由于TCP连接释放是由TCP客户进程主动发起的，因此TCP服务器进程对TCP连接的释放称为被动关闭连接 TCP服务器进程发送TCP连接释放报文段并进入最后确认状态 该报文段首部中 终止位FIN和确认位ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认 序号seq字段的值为w，这是因为在半关闭状态下，TCP服务器进程可能又发送 确认号ack字段的值为u+1，这是对之前收到的TCP连接释放报文段的重复确认 TCP客户进程收到TCP连接释放报文段后，必须针对该报文段发送普通的TCP确认报文段，之后进入时间等待状态 该报文段首部中 确认为ACK的值被设置为1，表明这是一个普通的TCP确认报文段 序号seq字段的值设置为u+1，这是因为TCP客户进程之前发送的TCP连接释放报文段虽然不携带数据，但要消耗掉一个序号 确认号ack字段的值设置为w+1，这是对所收到的TCP连接释放报文段的确认 TCP服务器进程收到该报文段后就进入关闭状态，而TCP客户进程还要进过2MSL后才能进入关闭状态 TCP客户进程在发送完最后一个确认报文后，为什么不直接进入关闭状态？而是要进入时间等待状态？ 因为时间等待状态以及处于该状态2MSL时长，可以确保TCP服务器进程可以收到最后一个TCP确认报文段而进入关闭状态 另外，TCP客户进程在发送完最后一个TCP确认报文段后，在经过2MSL时长，就可以使本次连接持续时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的TCP连接中，不会出现旧连接中的报文段 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:3:1","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#tcp通过四报文挥手来释放连接"},{"categories":["网络"],"content":"TCP保活计时器的作用TCP双方已经建立了连接，后来，TCP客户进程所在的主机突然出现了故障 TCP服务器进程以后就不能再收到TCP客户进程发来的数据 因此，应当有措施使TCP服务器进程不要再白白等待下去 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:3:2","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#tcp保活计时器的作用"},{"categories":["网络"],"content":"5.9、TCP报文段的首部格式","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#59tcp报文段的首部格式"},{"categories":["网络"],"content":"各字段的作用源端口和目的端口 序号、确认号和确认标志位 数据偏移、保留、窗口和校验和 同步标志位、终止标志位、复位标志位、推送标志位、紧急标志位和紧急指针 选项和填充 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第5章（传输层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%E4%BC%A0%E8%BE%93%E5%B1%82/#各字段的作用"},{"categories":["网络"],"content":"4.1、网络层概述","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#41网络层概述"},{"categories":["网络"],"content":"简介 网络层的主要任务是实现网络互连，进而实现数据包在各网络之间的传输 这些异构型网络N1~N7如果只是需要各自内部通信，他们只要实现各自的物理层和数据链路层即可 但是如果要将这些异构型网络互连起来，形成一个更大的互联网，就需要实现网络层设备路由器 有时为了简单起见，可以不用画出这些网络，图中N1~N7，而将他们看做是一条链路即可 要实现网络层任务，需要解决一下主要问题： 网络层向运输层提供怎样的服务（“可靠传输”还是“不可靠传输”） 在数据链路层那课讲过的可靠传输，详情可以看那边的笔记：网络层对以下的分组丢失、分组失序、分组重复的传输错误采取措施，使得接收方能正确接受发送方发送的数据，就是可靠传输，反之，如果什么措施也不采取，则是不可靠传输 网络层寻址问题 路由选择问题 路由器收到数据后，是依据什么来决定将数据包从自己的哪个接口转发出去？ 依据数据包的目的地址和路由器中的路由表 但在实际当中，路由器是怎样知道这些路由记录？ 由用户或网络管理员进行人工配置，这种方法只适用于规模较小且网络拓扑不改变的小型互联网 另一种是实现各种路由选择协议，由路由器执行路由选择协议中所规定的路由选择算法，而自动得出路由表中的路有记录，这种方法更适合规模较大且网络拓扑经常改变的大型互联网 补充 网络层（网际层）除了 IP协议外，还有之前介绍过的地址解析协议ARP，还有网际控制报文协议ICMP，网际组管理协议IGMP ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#简介"},{"categories":["网络"],"content":"总结 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#总结"},{"categories":["网络"],"content":"4.2、网络层提供的两种服务 在计算机网络领域，网络层应该向运输层提供怎样的服务（“面向连接”还是“无连接”）曾引起了长期的争论。 争论焦点的实质就是：在计算机通信中，可靠交付应当由谁来负责？是网络还是端系统？ ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#42网络层提供的两种服务"},{"categories":["网络"],"content":"面向连接的虚电路服务一种观点：让网络负责可靠交付 这种观点认为，应借助于电信网的成功经验，让网络负责可靠交付，计算机网络应模仿电信网络，使用面向连接的通信方式。 通信之前先建立虚电路 (Virtual Circuit)，以保证双方通信所需的一切网络资源。 如果再使用可靠传输的网络协议，就可使所发送的分组无差错按序到达终点，不丢失、不重复。 发送方 发送给 接收方 的所有分组都沿着同一条虚电路传送 虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。 请注意，电路交换的电话通信是先建立了一条真正的连接。 因此分组交换的虚连接和电路交换的连接只是类似，但并不完全一样 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#面向连接的虚电路服务"},{"categories":["网络"],"content":"无连接的数据报服务另一种观点：网络提供数据报服务 互联网的先驱者提出了一种崭新的网络设计思路。 网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。 网络在发送分组时不需要先建立连接。每一个分组（即 IP 数据报）独立发送，与其前后的分组无关（不进行编号）。 网络层不提供服务质量的承诺。即所传送的分组可能出错、丢失、重复和失序（不按序到达终点），当然也不保证分组传送的时限。 发送方 发送给 接收方 的分组可能沿着不同路径传送 尽最大努力交付 如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的主机中的运输层负责可靠交付（包括差错处理、流量控制等） 。 采用这种设计思路的好处是：网络的造价大大降低，运行方式灵活，能够适应多种应用。 互连网能够发展到今日的规模，充分证明了当初采用这种设计思路的正确性。 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#无连接的数据报服务"},{"categories":["网络"],"content":"虚电路服务与数据报服务的对比 对比的方面 虚电路服务 数据报服务 思路 可靠通信应当由网络来保证 可靠通信应当由用户主机来保证 连接的建立 必须有 不需要 终点地址 仅在连接建立阶段使用，每个分组使用短的虚电路号 每个分组都有终点的完整地址 分组的转发 属于同一条虚电路的分组均按照同一路由进行转发 每个分组独立选择路由进行转发 当结点出故障时 所有通过出故障的结点的虚电路均不能工作 出故障的结点可能会丢失分组，一些路由可能会发生变化 分组的顺序 总是按发送顺序到达终点 到达终点时不一定按发送顺序 端到端的差错处理和流量控制 可以由网络负责，也可以由用户主机负责 由用户主机负责 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:3:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#虚电路服务与数据报服务的对比"},{"categories":["网络"],"content":"4.3、IPv4","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#43ipv4"},{"categories":["网络"],"content":"概述","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#概述"},{"categories":["网络"],"content":"分类编制的IPv4地址","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#分类编制的ipv4地址"},{"categories":["网络"],"content":"简介 每一类地址都由两个固定长度的字段组成，其中一个字段是网络号 net-id，它标志主机（或路由器）所连接到的网络，而另一个字段则是主机号 host-id，它标志该主机（或路由器）。 主机号在它前面的网络号所指明的网络范围内必须是唯一的。 由此可见，一个 IP 地址在整个互联网范围内是唯一的。 A类地址 B类地址 C类地址 练习 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:2:1","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#简介-1"},{"categories":["网络"],"content":"总结IP 地址的指派范围 一般不使用的特殊的 IP 地址 IP 地址的一些重要特点 (1) IP 地址是一种分等级的地址结构。分两个等级的好处是： 第一，IP 地址管理机构在分配 IP 地址时只分配网络号，而剩下的主机号则由得到该网络号的单位自行分配。这样就方便了 IP 地址的管理。 第二，路由器仅根据目的主机所连接的网络号来转发分组（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间。 (2) 实际上 IP 地址是标志一个主机（或路由器）和一条链路的接口。 当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号 net-id 必须是不同的。这种主机称为多归属主机 (multihomed host)。 由于一个路由器至少应当连接到两个网络（这样它才能将 IP 数据报从一个网络转发到另一个网络），因此一个路由器至少应当有两个不同的 IP 地址。 (3) 用转发器或网桥连接起来的若干个局域网仍为一个网络，因此这些局域网都具有同样的网络号 net-id。 (4) 所有分配到网络号 net-id 的网络，无论是范围很小的局域网，还是可能覆盖很大地理范围的广域网，都是平等的。 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:2:2","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#总结-1"},{"categories":["网络"],"content":"划分子网的IPv4地址","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:3:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#划分子网的ipv4地址"},{"categories":["网络"],"content":"为什么要划分子网在 ARPANET 的早期，IP 地址的设计确实不够合理： IP 地址空间的利用率有时很低。 给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。 两级的 IP 地址不够灵活。 如果想要将原来的网络划分成三个独立的网路 所以是否可以从主机号部分借用一部分作为子网号 但是如果未在图中标记子网号部分，那么我们和计算机又如何知道分类地址中主机号有多少比特被用作子网号了呢？ 所以就有了划分子网的工具：子网掩码 从 1985 年起在 IP 地址中又增加了一个“子网号字段”，使两级的 IP 地址变成为三级的 IP 地址。 这种做法叫做划分子网 (subnetting) 。 划分子网已成为互联网的正式标准协议。 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:3:1","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#为什么要划分子网"},{"categories":["网络"],"content":"如何划分子网基本思路 划分子网纯属一个单位内部的事情。单位对外仍然表现为没有划分子网的网络。 从主机号借用若干个位作为子网号 subnet-id，而主机号 host-id 也就相应减少了若干个位。 凡是从其他网络发送给本单位某个主机的 IP 数据报，仍然是根据 IP 数据报的目的网络号 net-id，先找到连接在本单位网络上的路由器。 然后此路由器在收到 IP 数据报后，再按目的网络号 net-id 和子网号 subnet-id 找到目的子网。 最后就将 IP 数据报直接交付目的主机。 划分为三个子网后对外仍是一个网络 优点 减少了 IP 地址的浪费 使网络的组织更加灵活 更便于维护和管理 划分子网纯属一个单位内部的事情，对外部网络透明，对外仍然表现为没有划分子网的一个网络。 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:3:2","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#如何划分子网"},{"categories":["网络"],"content":"子网掩码 (IP 地址) AND (子网掩码) = 网络地址 重要，下面很多相关知识都会用到 举例 例子1 例子2 默认子网掩码 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:3:3","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#子网掩码"},{"categories":["网络"],"content":"总结 子网掩码是一个网络或一个子网的重要属性。 路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。 路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。 若一个路由器连接在两个子网上，就拥有两个网络地址和两个子网掩码。 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:3:4","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#总结-2"},{"categories":["网络"],"content":"无分类编址的IPv4地址","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:4:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#无分类编址的ipv4地址"},{"categories":["网络"],"content":"为什么使用无分类编址无分类域间路由选择 CIDR (Classless Inter-Domain Routing)。 CIDR 最主要的特点 CIDR使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号。 IP 地址从三级编址（使用子网掩码）又回到了两级编址。 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:4:1","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#为什么使用无分类编址"},{"categories":["网络"],"content":"如何使用无分类编址举例 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:4:2","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#如何使用无分类编址"},{"categories":["网络"],"content":"路由聚合（构造超网）","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:4:3","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#路由聚合构造超网"},{"categories":["网络"],"content":"总结","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:4:4","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#总结-3"},{"categories":["网络"],"content":"IPv4地址的应用规划给定一个IPv4地址快，如何将其划分成几个更小的地址块，并将这些地址块分配给互联网中不同网络，进而可以给各网络中的主机和路由器接口分配IPv4地址 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:5:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#ipv4地址的应用规划"},{"categories":["网络"],"content":"定长的子网掩码FLSM（Fixed Length Subnet Mask）划分子网的IPv4就是定长的子网掩码 举例 通过上面步骤分析，就可以从子网1~8中任选5个分配给左图中的N1~N5 采用定长的子网掩码划分，只能划分出2^n个子网，其中n是从主机号部分借用的用来作为子网号的比特数量，每个子网所分配的IP地址数量相同 但是也因为每个子网所分配的IP地址数量相同，不够灵活，容易造成IP地址的浪费 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:5:1","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#定长的子网掩码flsmfixed-length-subnet-mask"},{"categories":["网络"],"content":"变长的子网掩码VLSM（Variable Length Subnet Mask）无分类编址的IPv4就是变长的子网掩码 举例 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:5:2","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#变长的子网掩码vlsmvariable-length-subnet-mask"},{"categories":["网络"],"content":"4.4、IP数据报的发送和转发过程举例 源主机如何知道目的主机是否与自己在同一个网络中，是直接交付，还是间接交付？ 可以通过目的地址IP和源地址的子网掩码进行逻辑与运算得到目的网络地址 如果目的网络地址和源网络地址 相同，就是在同一个网络中，属于直接交付 如果目的网络地址和源网络地址 不相同，就不在同一个网络中，属于间接交付，传输给主机所在网络的默认网关（路由器——下图会讲解）,由默认网关帮忙转发 主机C如何知道路由器R的存在？ 用户为了让本网络中的主机能和其他网络中的主机进行通信，就必须给其指定本网络的一个路由器的接口，由该路由器帮忙进行转发，所指定的路由器，也被称为默认网关 例如。路由器的接口0的IP地址192.168.0.128做为左边网络的默认网关 主机A会将该IP数据报传输给自己的默认网关，也就是图中所示的路由器接口0 路由器收到IP数据报后如何转发？ 检查IP数据报首部是否出错： 若出错，则直接丢弃该IP数据报并通告源主机 若没有出错，则进行转发 根据IP数据报的目的地址在路由表中查找匹配的条目： 若找到匹配的条目，则转发给条目中指示的吓一跳 若找不到，则丢弃该数据报并通告源主机 假设IP数据报首部没有出错，路由器取出IP数据报首部各地址字段的值 接下来路由器对该IP数据报进行查表转发 逐条检查路由条目，将目的地址与路由条目中的地址掩码进行逻辑与运算得到目的网络地址，然后与路由条目中的目的网络进行比较，如果相同，则这条路由条目就是匹配的路由条目，按照它的下一条指示，图中所示的也就是接口1转发该IP数据报 路由器是隔离广播域的 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#44ip数据报的发送和转发过程"},{"categories":["网络"],"content":"4.5、静态路由配置及其可能产生的路由环路问题","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#45静态路由配置及其可能产生的路由环路问题"},{"categories":["网络"],"content":"概念","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#概念"},{"categories":["网络"],"content":"多种情况举例静态路由配置 举例 默认路由 举例 默认路由可以被所有网络匹配，但路由匹配有优先级，默认路由是优先级最低的 特定主机路由 举例 有时候，我们可以给路由器添加针对某个主机的特定主机路由条目 一般用于网络管理人员对网络的管理和测试 多条路由可选，匹配路由最具体的 静态路由配置错误导致路由环路 举例 假设将R2的路由表中第三条目录配置错了下一跳 这导致R2和R3之间产生了路由环路 聚合了不存在的网络而导致路由环路 举例 正常情况 错误情况 解决方法 黑洞路由的下一跳为null0，这是路由器内部的虚拟接口，IP数据报进入它后就被丢弃 网络故障而导致路由环路 举例 解决方法 添加故障的网络为黑洞路由 假设。一段时间后故障网络恢复了 R1又自动地得出了其接口0的直连网络的路由条目 针对该网络的黑洞网络会自动失效 如果又故障 则生效该网络的黑洞网络 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#多种情况举例"},{"categories":["网络"],"content":"总结 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:3:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#总结-4"},{"categories":["网络"],"content":"4.6、路由选择协议","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#46路由选择协议"},{"categories":["网络"],"content":"概述因特网所采用的路由选择协议的主要特点 因特网采用分层次的路由选择协议 自治系统 AS：在单一的技术管理下的一组路由器，而这些路由器使用一种 AS 内部的路由选择协议和共同的度量以确定分组在该 AS 内的路由，同时还使用一种 AS 之间的路由选择协议用以确定分组在 AS之间的路由。 自治系统之间的路由选择简称为域间路由选择，自治系统内部的路由选择简称为域内路由选择 域间路由选择使用外部网关协议EGP这个类别的路由选择协议 域内路由选择使用内部网关协议IGP这个类别的路由选择协议 网关协议的名称可称为路由协议 常见的路由选择协议 路由器的基本结构 路由器是一种具有多个输入端口，和输出端口的专用计算机，其任务是转发分组 路由器结构可划分为两大部分： 1、分组转发部分 由三部分构成 交换结构 一组输入端口： 信号从某个输入端口进入路由器 物理层将信号转换成比特流，送交数据链路层处理 数据链路层识别从比特流中识别出帧，去掉帧头和帧尾后，送交网络层处理 如果送交网络层的分组是普通待转发的数据分组 则根据分组首部中的目的地址进行查表转发 若找不到匹配的转发条目，则丢弃该分组，否则，按照匹配条目中所指示的端口进行转发 一组输出端口 网络层更新数据分组首部中某些字段的值，例如将数据分组的生存时间减1，然后送交数据链路层进行封装 数据链路层将数据分组封装成帧，交给物理层处理 物理层将帧看成比特流将其变换成相应的电信号进行发送 路由器的各端口还会有输入缓冲区和输出缓冲区 输入缓冲区用来暂存新进入路由器但还来不及处理的分组 输出缓冲区用来暂存已经处理完毕但还来不及发送的分组 路由器的端口一般都具有输入和输出功能，这些实例分出了输入端口和输出端口是更好演示路由基本工作过程 2、路由选择部分 路由选择部分的核心构件是路由选择处理机，它的任务是根据所使用的路由选择协议。周期性地与其他路由器 进行路由信息的交互，来更新路由表 如果送交给输入端口的网络层的分组是路由器之间交换路由信息的路由报文，则把这种分组送交给路由选择处理机 路由选择处理机根据分组的内容来更新自己的路由表 路由选择处理机还会周期性地给其他路由器发送自己所知道的路由信息 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#概述-1"},{"categories":["网络"],"content":"路由信息协议RIPRIP的基本工作过程 举例 RIP的路由条目的更新规则 举例1 路由器C的表到达各目的网络的下一条都记为问号，可以理解为路由器D并不需要关心路由器C的这些内容 假设路由器C的RIP更新报文发送周期到了，则路由器C将自己路由表中的相关路由信息封装到RIP更新报文中发送给路由器D 路由器C能到达这些网络，说明路由器C的相邻路由器也能到达，只是比路由器C的距离大1，于是根据距离的对比，路由器D更新自己的路由表 举例2 RIP存在“坏消息传播得慢”的问题 解决方法 但是，这些方法也不能完全解决“坏消息传播得慢”的问题，这是距离向量的本质决定 总结 RIP 协议的优缺点 优点： 实现简单，开销较小。 缺点： RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。 路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。 “坏消息传播得慢”，使更新过程的收敛时间过长。 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#路由信息协议rip"},{"categories":["网络"],"content":"开放最短路径优先OSPF开放最短路径优先 OSPF (Open Shortest Path First) 注意：OSPF 只是一个协议的名字，它并不表示其他的路由选择协议不是“最短路径优先”。 概念 问候（Hello）分组 IP数据报首部中协议号字段的取值应为89，来表明IP数据报的数据载荷为OSPF分组 发送链路状态通告LSA 洪泛法有点类似于广播，就是从一个接口进来，从其他剩余所有接口出去 链路状态数据库同步 使用SPF算法计算出各自路由器到达其他路由器的最短路径 OSPF五种分组类型 OSPF的基本工作过程 OSPF在多点接入网络中路由器邻居关系建立 如果不采用其他机制，将会产生大量的多播分组 若DR出现问题，则由BDR顶替DR 为了使OSPF能够用于规模很大的网络，OSPF把一个自治系统再划分为若干个更小的范围，叫做区域（Area） 在该自治系统内，所有路由器都使用OSPF协议，OSPF将该自治系统再划分成4个更小的区域 每个区域都有一个32比特的区域标识符 主干区域的区域标识符必须为0，主干区域用于连通其他区域 其他区域的区域标识符不能为0且不相同 每个区域一般不应包含路由器超过200个 划分区域的好处就是，利用洪泛法交换链路状态信息局限于每一个区域而不是自治系统，这样减少整个网络上的通信量 总结 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:3:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#开放最短路径优先ospf"},{"categories":["网络"],"content":"边界网关协议BGPBGP（Border Gateway Protocol） 是不同自治系统的路由器之间交换路由信息的协议 总结 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:4:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#边界网关协议bgp"},{"categories":["网络"],"content":"直接封装RIP、OSPF和BGP报文的协议 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:5:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#直接封装ripospf和bgp报文的协议"},{"categories":["网络"],"content":"4.7、IPv4数据报的首部格式","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#47ipv4数据报的首部格式"},{"categories":["网络"],"content":"各字段的作用 一个 IP 数据报由首部和数据两部分组成。 首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。 在首部的固定部分的后面是一些可选字段，其长度是可变的。 图中的每一行都由32个比特（也就是4个字节）构成，每个小格子称为字段或者域，每个字段或某些字段的组合用来表达IP协议的相关功能 IP数据报的首部长度一定是4字节的整数倍 因为首部中的可选字段的长度从1个字节到40个字节不等，那么，当20字节的固定部分加上1到40个字节长度不等的可变部分，会造成首部长度不是4字节整数倍时，就用取值为全0的填充字段填充相应个字节，以确保IP数据报的首部长度是4字节的整数倍 对IPv4数据报进行分片 ​ 现在假定分片2的IP数据报经过某个网络时还需要进行分片 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#各字段的作用"},{"categories":["网络"],"content":"总结 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#总结-5"},{"categories":["网络"],"content":"4.8、网际控制报文协议ICMP","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#48网际控制报文协议icmp"},{"categories":["网络"],"content":"概念架构IP网络时需要特别注意两点： 确认网络是否正常工作 遇到异常时进行问题诊断 而ICMP就是实现这些问题的协议 ICMP的主要功能包括： 确认IP包是否成功送达目标地址 通知在发送过程当中IP包被废弃的具体原因 改善网络设置等 有了这些功能以后，就可以获得网络是否正常，设置是否有误以及设备有何异常等信息，从而便于进行网络上的问题诊断 ICMP 不是高层协议（看起来好像是高层协议，因为 ICMP 报文是装在 IP 数据报中，作为其中的数据部分），而是 IP 层的协议 ICMP 报文的格式 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#概念-1"},{"categories":["网络"],"content":"ICMP差错报告报文","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#icmp差错报告报文"},{"categories":["网络"],"content":"终点不可达","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:2:1","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#终点不可达"},{"categories":["网络"],"content":"源点抑制","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:2:2","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#源点抑制"},{"categories":["网络"],"content":"时间超过","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:2:3","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#时间超过"},{"categories":["网络"],"content":"参数问题","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:2:4","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#参数问题"},{"categories":["网络"],"content":"改变路由（重定向）","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:2:5","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#改变路由重定向"},{"categories":["网络"],"content":"不应发送ICMP差错报告报文情况","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:2:6","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#不应发送icmp差错报告报文情况"},{"categories":["网络"],"content":"ICMP应用举例","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:3:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#icmp应用举例"},{"categories":["网络"],"content":"分组网间探测PING（Packet InterNet Groper）","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:3:1","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#分组网间探测pingpacket-internet-groper"},{"categories":["网络"],"content":"跟踪路由（traceroute）tracert命令的实现原理 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:3:2","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#跟踪路由traceroute"},{"categories":["网络"],"content":"总结 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:4:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#总结-6"},{"categories":["网络"],"content":"4.9、虚拟专用网VPN与网络地址转换NAT","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#49虚拟专用网vpn与网络地址转换nat"},{"categories":["网络"],"content":"虚拟专用网VPN（Virtual Private Network） 由于 IP 地址的紧缺，一个机构能够申请到的IP地址数往往远小于本机构所拥有的主机数。 考虑到互联网并不很安全，一个机构内也并不需要把所有的主机接入到外部的互联网。 假定在一个机构内部的计算机通信也是采用 TCP/IP 协议，那么从原则上讲，对于这些仅在机构内部使用的计算机就可以由本机构自行分配其 IP 地址。 上图是因特网数字分配机构IANA官网查看IPv4地址空间中特殊地址的分配方案 用粉红色标出来的地址就是无需申请的、可自由分配的专用地址，或称私有地址 私有地址只能用于一个机构的内部通信，而不能用于和因特网上的主机通信 私有地址只能用作本地地址而不能用作全球地址 因特网中所有路由器对目的地址是私有地址的IP数据报一律不进行转发 本地地址与全球地址 本地地址——仅在机构内部使用的 IP 地址，可以由本机构自行分配，而不需要向互联网的管理机构申请。 全球地址——全球唯一的 IP 地址，必须向互联网的管理机构申请。 问题：在内部使用的本地地址就有可能和互联网中某个 IP 地址重合，这样就会出现地址的二义性问题。 所以部门A和部门B至少需要一个 路由器具有合法的全球IP地址，这样各自的专用网才能利用公用的因特网进行通信 部门A向部门B发送数据流程 两个专用网内的主机间发送的数据报是通过了公用的因特网，但在效果上就好像是在本机构的专用网上传送一样 数据报在因特网中可能要经过多个网络和路由器，但从逻辑上看，R1和R2之间好像是一条直通的点对点链路 因此也被称为IP隧道技术 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#虚拟专用网vpnvirtual-private-network"},{"categories":["网络"],"content":"网络地址转换NAT（Network Address Translation）举例 使用私有地址的主机，如何才能与因特网上使用全球IP地址的主机进行通信？ 这需要在专用网络连接到因特网的路由器上安装NAT软件 专有NAT软件的路由器叫做NAT路由器 它至少有一个有效的外部全球IP地址 这样，所有使用私有地址的主机在和外界通信时，都要在NAT路由器上将其私有地址转换为全球IP地址 假设，使用私有地址的主机要给因特网上使用全球IP地址的另一台主机发送IP数据报 因特网上的这台主机给源主机发回数据报 当专用网中的这两台使用私有地址的主机都要给因特网使用全球地址的另一台主机发送数据报时，在NAT路由器的NAT转换表中就会产生两条记录，分别记录两个私有地址与全球地址的对应关系 这种基本转换存在一个问题 解决方法 我们现在用的很多家用路由器都是这种NART路由器 内网主机与外网主机的通信，是否能由外网主机首先发起？ 否定 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#网络地址转换natnetwork-address-translation"},{"categories":["网络"],"content":"总结","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/:3:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第4章（网络层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/#总结-7"},{"categories":["网络"],"content":"3.1、数据链路层概述","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#31数据链路层概述"},{"categories":["网络"],"content":"概述链路是从一个结点到相邻结点的一段物理线路，数据链路则是在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现） 网络中的主机、路由器等都必须实现数据链路层 局域网中的主机、交换机等都必须实现数据链路层 从层次上来看数据的流动 仅从数据链路层观察帧的流动 主机H1 到主机H2 所经过的网络可以是多种不同类型的 注意：不同的链路层可能采用不同的数据链路层协议 数据链路层使用的信道 数据链路层属于计算机网路的低层。数据链路层使用的信道主要有以下两种类型： 点对点信道 广播信道 局域网属于数据链路层 局域网虽然是个网络。但我们并不把局域网放在网络层中讨论。这是因为在网络层要讨论的是多个网络互连的问题，是讨论分组怎么从一个网络，通过路由器，转发到另一个网络。 而在同一个局域网中，分组怎么从一台主机传送到另一台主机，但并不经过路由器转发。从整个互联网来看，局域网仍属于数据链路层的范围 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#概述"},{"categories":["网络"],"content":"三个重要问题数据链路层传送的协议数据单元是帧 封装成帧 封装成帧 (framing) 就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。 首部和尾部的一个重要作用就是进行帧定界。 差错控制 在传输过程中可能会产生比特差错：1 可能会变成 0， 而 0 也可能变成 1。 可靠传输 接收方主机收到有误码的帧后，是不会接受该帧的，会将它丢弃 如果数据链路层向其上层提供的是不可靠服务，那么丢弃就丢弃了，不会再有更多措施 如果数据链路层向其上层提供的是可靠服务，那就还需要其他措施，来确保接收方主机还可以重新收到被丢弃的这个帧的正确副本 以上三个问题都是使用点对点信道的数据链路层来举例的 如果使用广播信道的数据链路层除了包含上面三个问题外，还有一些问题要解决 如图所示，主机A，B，C，D，E通过一根总线进行互连，主机A要给主机C发送数据，代表帧的信号会通过总线传输到总线上的其他各主机，那么主机B，D，E如何知道所收到的帧不是发送给她们的，主机C如何知道发送的帧是发送给自己的 可以用编址（地址）的来解决 将帧的目的地址添加在帧中一起传输 还有数据碰撞问题 随着技术的发展，交换技术的成熟， 在 有线（局域网）领域 使用点对点链路和链路层交换机的交换式局域网取代了共享式局域网 在无线局域网中仍然使用的是共享信道技术 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#三个重要问题"},{"categories":["网络"],"content":"3.2、封装成帧","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#32封装成帧"},{"categories":["网络"],"content":"介绍封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧 帧头和帧尾中包含有重要的控制信息 发送方的数据链路层将上层交付下来的协议数据单元封装成帧后，还要通过物理层，将构成帧的各比特，转换成电信号交给传输媒体，那么接收方的数据链路层如何从物理层交付的比特流中提取出一个个的帧？ 答：需要帧头和帧尾来做帧定界 但比不是每一种数据链路层协议的帧都包含有帧定界标志，例如下面例子 前导码 前同步码：作用是使接收方的时钟同步 帧开始定界符：表明其后面紧跟着的就是MAC帧 另外以太网还规定了帧间间隔为96比特时间，因此，MAC帧不需要帧结束定界符 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#介绍"},{"categories":["网络"],"content":"透明传输 透明 指某一个实际存在的事物看起来却好像不存在一样。 透明传输是指数据链路层对上层交付的传输数据没有任何限制，好像数据链路层不存在一样 帧界定标志也就是个特定数据值，如果在上层交付的协议数据单元中， 恰好也包含这个特定数值，接收方就不能正确接收 所以数据链路层应该对上层交付的数据有限制，其内容不能包含帧定界符的值 解决透明传输问题 解决方法：面向字节的物理链路使用字节填充 (byte stuffing) 或字符填充 (character stuffing)，面向比特的物理链路使用比特填充的方法实现透明传输 发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”(其十六进制编码是1B)。 接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。 如果转义字符也出现在数据当中，那么应在转义字符前面插入一个转义字符 ESC。当接收端收到连续的两个转义字符时，就删除其中前面的一个。 帧的数据部分长度 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#透明传输"},{"categories":["网络"],"content":"总结","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:3:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#总结"},{"categories":["网络"],"content":"3.3、差错检测","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#33差错检测"},{"categories":["网络"],"content":"介绍","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#介绍-1"},{"categories":["网络"],"content":"奇偶校验","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#奇偶校验"},{"categories":["网络"],"content":"循环冗余校验CRC(Cyclic Redundancy Check)例题 总结 循环冗余校验 CRC 是一种检错方法，而帧校验序列 FCS 是添加在数据后面的冗余码 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:3:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#循环冗余校验crccyclic-redundancy-check"},{"categories":["网络"],"content":"3.4、可靠传输","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#34可靠传输"},{"categories":["网络"],"content":"基本概念下面是比特差错 其他传输差错 分组丢失 路由器输入队列快满了，主动丢弃收到的分组 分组失序 数据并未按照发送顺序依次到达接收端 分组重复 由于某些原因，有些分组在网络中滞留了，没有及时到达接收端，这可能会造成发送端对该分组的重发，重发的分组到达接收端，但一段时间后，滞留在网络的分组也到达了接收端，这就造成分组重复的传输差错 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#基本概念"},{"categories":["网络"],"content":"三种可靠协议 停止-等待协议SW 回退N帧协议GBN 选择重传协议SR 这三种可靠传输实现机制的基本原理并不仅限于数据链路层，可以应用到计算机网络体系结构的各层协议中 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#三种可靠协议"},{"categories":["网络"],"content":"停止-等待协议","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:3:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#停止-等待协议"},{"categories":["网络"],"content":"停止-等待协议可能遇到的四个问题确认与否认 超时重传 确认丢失 既然数据分组需要编号，确认分组是否需要编号？ 要。如下图所示 确认迟到 注意，图中最下面那个数据分组与之前序号为0的那个数据分组不是同一个数据分组 注意事项 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:3:1","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#停止-等待协议可能遇到的四个问题"},{"categories":["网络"],"content":"停止-等待协议的信道利用率假设收发双方之间是一条直通的信道 TD：是发送方发送数据分组所耗费的发送时延 RTT：是收发双方之间的往返时间 TA：是接收方发送确认分组所耗费的发送时延 TA一般都远小于TD，可以忽略，当RTT远大于TD时，信道利用率会非常低 像停止-等待协议这样通过确认和重传机制实现的可靠传输协议，常称为自动请求重传协议ARQ(Automatic Repeat reQuest)，意思是重传的请求是自动进行，因为不需要接收方显式地请求，发送方重传某个发送的分组 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:3:2","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#停止-等待协议的信道利用率"},{"categories":["网络"],"content":"回退N帧协议GBN","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:4:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#回退n帧协议gbn"},{"categories":["网络"],"content":"为什么用回退N帧协议在相同的时间内，使用停止-等待协议的发送方只能发送一个数据分组，而采用流水线传输的发送方，可以发送多个数据分组 回退N帧协议在流水线传输的基础上，利用发送窗口来限制发送方可连续发送数据分组的个数 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:4:1","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#为什么用回退n帧协议"},{"categories":["网络"],"content":"无差错情况流程发送方将序号落在发送窗口内的0~4号数据分组，依次连续发送出去 他们经过互联网传输正确到达接收方，就是没有乱序和误码，接收方按序接收它们，每接收一个，接收窗口就向前滑动一个位置，并给发送方发送针对所接收分组的确认分组，在通过互联网的传输正确到达了发送方 发送方每接收一个、发送窗口就向前滑动一个位置，这样就有新的序号落入发送窗口，发送方可以将收到确认的数据分组从缓存中删除了，而接收方可以择机将已接收的数据分组交付上层处理 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:4:2","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#无差错情况流程"},{"categories":["网络"],"content":"累计确认 累计确认 优点: 即使确认分组丢失，发送方也可能不必重传 减小接收方的开销 减小对网络资源的占用 缺点： 不能向发送方及时反映出接收方已经正确接收的数据分组信息 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:4:3","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#累计确认"},{"categories":["网络"],"content":"有差错情况例如 在传输数据分组时，5号数据分组出现误码，接收方通过数据分组中的检错码发现了错误 于是丢弃该分组，而后续到达的这剩下四个分组与接收窗口的序号不匹配 接收同样也不能接收它们，讲它们丢弃，并对之前按序接收的最后一个数据分组进行确认，发送ACK4，每丢弃一个数据分组，就发送一个ACK4 当收到重复的ACK4时，就知道之前所发送的数据分组出现了差错，于是可以不等超时计时器超时就立刻开始重传，具体收到几个重复确认就立刻重传，根据具体实现决定 如果收到这4个重复的确认并不会触发发送立刻重传，一段时间后。超时计时器超时，也会将发送窗口内以发送过的这些数据分组全部重传 若WT超过取值范围，例如WT=8，会出现什么情况？ 习题 总结 回退N帧协议在流水线传输的基础上利用发送窗口来限制发送方连续发送数据分组的数量，是一种连续ARQ协议 在协议的工作过程中发送窗口和接收窗口不断向前滑动，因此这类协议又称为滑动窗口协议 由于回退N帧协议的特性，当通信线路质量不好时，其信道利用率并不比停止-等待协议高 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:4:4","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#有差错情况"},{"categories":["网络"],"content":"选择重传协议SR具体流程请看视频 习题 总结 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:5:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#选择重传协议sr"},{"categories":["网络"],"content":"3.5、点对点协议PPP 点对点协议PPP（Point-to-Point Protocol）是目前使用最广泛的点对点数据链路层协议 PPP协议是因特网工程任务组IEIF在1992年制定的。经过1993年和1994年的修订，现在的PPP协议已成为因特网的正式标准[RFC1661，RFC1662] 数据链路层使用的一种协议，它的特点是：简单；只检测差错，而不是纠正差错；不使用序号，也不进行流量控制；可同时支持多种网络层协议 PPPoE 是为宽带上网的主机使用的链路层协议 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#35点对点协议ppp"},{"categories":["网络"],"content":"帧格式必须规定特殊的字符作为帧定界符 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#帧格式"},{"categories":["网络"],"content":"透明传输必须保证数据传输的透明性 实现透明传输的方法 面向字节的异步链路：字节填充法（插入“转义字符”） 面向比特的同步链路：比特填充法（插入“比特0”） ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#透明传输-1"},{"categories":["网络"],"content":"差错检测能够对接收端收到的帧进行检测，并立即丢弃有差错的帧。 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:3:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#差错检测"},{"categories":["网络"],"content":"工作状态 当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。 PC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧）。 这些分组及其响应选择一些 PPP 参数，并进行网络层配置，NCP 给新接入的 PC 机 分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。 通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。 可见，PPP 协议已不是纯粹的数据链路层的协议，它还包含了物理层和网络层的内容。 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:4:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#工作状态"},{"categories":["网络"],"content":"3.6、媒体接入控制（介质访问控制）——广播信道媒体接入控制（介质访问控制）使用一对多的广播通信方式 Medium Access Control翻译成媒体接入控制，有些翻译成介质访问控制 局域网的数据链路层 局域网最主要的特点是： 网络为一个单位所拥有； 地理范围和站点数目均有限。 局域网具有如下主要优点： 具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。 便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。 提高了系统的可靠性、可用性和残存性。 数据链路层的两个子层 为了使数据链路层能更好地适应多种局域网标准，IEEE 802 委员会就将局域网的数据链路层拆成两个子层： 逻辑链路控制 LLC (Logical Link Control)子层； 媒体接入控制 MAC (Medium Access Control)子层。 与接入到传输媒体有关的内容都放在 MAC子层，而 LLC 子层则与传输媒体无关。 不管采用何种协议的局域网，对 LLC 子层来说都是透明的。 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#36媒体接入控制介质访问控制广播信道"},{"categories":["网络"],"content":"基本概念为什么要媒体接入控制（介质访问控制）？ 共享信道带来的问题 若多个设备在共享信道上同时发送数据，则会造成彼此干扰，导致发送失败。 随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的使用点对点链路和链路层交换机的交换式局域网在有线领域已完全取代了共享式局域网，但由于无线信道的广播天性，无线局域网仍然使用的是共享媒体技术 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#基本概念-1"},{"categories":["网络"],"content":"静态划分信道信道复用 频分复用FDM (Frequency Division Multiplexing) 将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。 频分复用的所有用户在同样的时间占用不同的带宽资源（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。 时分复用TDM (Time Division Multiplexing) 时分复用则是将时间划分为一段段等长的时分复用帧（TDM帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。 每一个用户所占用的时隙是周期性地出现（其周期就是TDM帧的长度）的。 TDM 信号也称为等时 (isochronous) 信号。 时分复用的所有用户在不同的时间占用同样的频带宽度。 波分复用 WDM(Wavelength Division Multiplexing) 波分复用就是光的频分复用，使用一根光纤来同时传输多个光载波信号 光信号传输一段距离后悔衰减，所以要用 掺铒光纤放大器 放大光信号 码分复用 CDM (Code Division Multiplexing) ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#静态划分信道"},{"categories":["网络"],"content":"动态接入控制受控接入 受控接入在局域网中使用得较少，本书不再讨论 随机接入 重点 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:3:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#动态接入控制"},{"categories":["网络"],"content":"随机接入（CSMA/CD协议）总线局域网使用协议：CSMA/CD ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:4:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#随机接入csmacd协议"},{"categories":["网络"],"content":"基本概念最初的以太网是将许多计算机都连接到一根总线上。易于实现广播通信。当初认为这样的连接方法既简单又可靠，因为总线上没有有源器件。 以太网（Ethernet）是一种计算机局域网技术。IEEE组织的IEEE 802.3标准制定了**以太网（Ethernet）**的技术标准 以太网采用无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢弃，其他什么也不做 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:4:1","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#基本概念-2"},{"categories":["网络"],"content":"多址接入MA表示许多主机以多点接入的方式连接在一根总线上。 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:4:2","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#多址接入ma"},{"categories":["网络"],"content":"载波监听CS是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。 总线上并没有什么“载波”。因此， “载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号。 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:4:3","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#载波监听cs"},{"categories":["网络"],"content":"碰撞检测CD “碰撞检测”就是计算机边发送数据边检测信道上的信号电压大小。 当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。 当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。 所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测”。 在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。 每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。 为什么要进行碰撞检测？ 因为信号传播时延对载波监听产生了影响 A 需要单程传播时延的 2 倍的时间，才能检测到与 B 的发送产生了冲突 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:4:4","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#碰撞检测cd"},{"categories":["网络"],"content":"CSMA/CD 协议工作流程","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:4:5","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#csmacd-协议工作流程"},{"categories":["网络"],"content":"CSMA/CD 协议工作——争用期（碰撞窗口）","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:4:6","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#csmacd-协议工作争用期碰撞窗口"},{"categories":["网络"],"content":"CSMA/CD 协议工作——最小帧长","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:4:7","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#csmacd-协议工作最小帧长"},{"categories":["网络"],"content":"CSMA/CD 协议工作——最大帧长","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:4:8","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#csmacd-协议工作最大帧长"},{"categories":["网络"],"content":"CSMA/CD 协议工作——截断二进制指数退避算法","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:4:9","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#csmacd-协议工作截断二进制指数退避算法"},{"categories":["网络"],"content":"CSMA/CD 协议工作——信道利用率","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:4:10","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#csmacd-协议工作信道利用率"},{"categories":["网络"],"content":"CSMA/CD 协议工作——帧接收流程","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:4:11","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#csmacd-协议工作帧接收流程"},{"categories":["网络"],"content":"CSMA/CD 协议的重要特性 使用 CSMA/CD 协议的以太网不能进行全双工通信而只能进行双向交替通信（半双工通信）。 每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。 这种发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率。 CSMA/CD协议曾经用于各种总线结构以太网和双绞线以太网的早起版本中。 现在的以太网基于交换机和全双工连接，不会有碰撞，因此没有必要使用CSMA/CS协议 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:4:12","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#csmacd-协议的重要特性"},{"categories":["网络"],"content":"随机接入（CSMA/CA协议）无线局域网使用的协议：CSMA/CA ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:5:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#随机接入csmaca协议"},{"categories":["网络"],"content":"为什么无线局域网要使用CSMA/CA协议","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:5:1","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#为什么无线局域网要使用csmaca协议"},{"categories":["网络"],"content":"帧间间隔IFS（InterFrame Space）","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:5:2","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#帧间间隔ifsinterframe-space"},{"categories":["网络"],"content":"CSMA/CA协议的工作原理 源站为什么在检测到信道空闲后还要再等待一段时间DIFS？ 考虑到可能有其他的站有高优先级的帧要发送。若有，就要让高优先级帧先发送 目的站为什么正确接收数据帧后还要等待一段时间SIFS才能发送ACK帧？ SIFS是最短的帧间间隔，用来分隔开属于一次对话的各帧，在这段时间内，一个站点应当能够从发送方式切换到接收方式 信道由忙转为空闲且经过DIFS时间后，还要退避一段随机时间才能使用信道？ 防止多个站点同时发送数据而产生碰撞 使用退避算法的时机 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:5:3","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#csmaca协议的工作原理"},{"categories":["网络"],"content":"CSMA/CA协议的退避算法退避算法的示例 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:5:4","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#csmaca协议的退避算法"},{"categories":["网络"],"content":"CSMA/CA协议的信道预约和虚拟载波监听虚拟载波监听机制能减少隐蔽站带来的碰撞问题的示例 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:5:5","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#csmaca协议的信道预约和虚拟载波监听"},{"categories":["网络"],"content":"3.7、MAC地址、IP地址以及ARP协议","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#37mac地址ip地址以及arp协议"},{"categories":["网络"],"content":"MAC地址 使用点对点信道的数据链路层不需要使用地址 使用广播信道的数据链路层必须使用地址来区分各主机 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#mac地址"},{"categories":["网络"],"content":"广播信道的数据链路层必须使用地址（MAC） MAC地址又称为硬件地址或物理地址。请注意：不要被 “物理” 二字误导认为物理地址属于物理层范畴，物理地址属于数据链路层范畴 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:1:1","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#广播信道的数据链路层必须使用地址mac"},{"categories":["网络"],"content":"IEEE 802局域网的MAC地址格式 组织唯一标识符OUI 生产网络设备的厂商，需要向IEEE的注册管理机构申请一个或多个OUI 网络接口标识符 由获得OUI的厂商自行随意分配 EUI-48 48是这个MAC地址的位数 对于使用EUI-48空间的应用程序，IEEE的目标寿命为100年（直到2080年），但是鼓励采用EUI-64作为替代 关于无效的 MAC 帧 数据字段的长度与长度字段的值不一致； 帧的长度不是整数个字节； 用收到的帧检验序列 FCS 查出有差错； 数据字段的长度不在 46 ~ 1500 字节之间。 有效的 MAC 帧长度为 64 ~ 1518 字节之间。 对于检查出的无效 MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧。 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:1:2","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#ieee-802局域网的mac地址格式"},{"categories":["网络"],"content":"IEEE 802局域网的MAC地址发送顺序","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:1:3","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#ieee-802局域网的mac地址发送顺序"},{"categories":["网络"],"content":"单播MAC地址举例 主机B给主机C发送单播帧，主机B首先要构建该单播帧，在帧首部中的目的地址字段填入主机C的MAC地址，源地址字段填入自己的MAC地址，再加上帧首部的其他字段、数据载荷以及帧尾部，就构成了该单播帧 主机B将该单播帧发送出去，主机A和C都会收到该单播帧 主机A的网卡发现该单播帧的目的MAC地址与自己的MAC地址不匹配，丢弃该帧 主机C的网卡发现该单播帧的目的MAC地址与自己的MAC地址匹配，接受该帧 并将该帧交给其上层处理 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:1:4","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#单播mac地址举例"},{"categories":["网络"],"content":"广播MAC地址举例 假设主机B要发送一个广播帧，主机B首先要构建该广播帧，在帧首部中的目的地址字段填入广播地址，也就是十六进制的全F，源地址字段填入自己的MAC地址，再加上帧首部中的其他字段、数据载荷以及帧尾部，就构成了该广播帧 主机B讲该广播帧发送出去，主机A和C都会收到该广播帧，发现该帧首部中的目的地址字段的内容是广播地址，就知道该帧是广播帧，主机A和主机C都接受该帧，并将该帧交给上层处理 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:1:5","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#广播mac地址举例"},{"categories":["网络"],"content":"多播MAC地址举例 假设主机A要发送多播帧给该多播地址。将该多播地址的左起第一个字节写成8个比特，第一个字节的最低比特位是1，这就表明该地址是多播地址。 快速判断地址是不是多播地址，就是上图所示箭头所指的第十六进制数不能整除2（1,3,5,7,9,B,D,F），则该地址是多播地址 假设主机B，C和D支持多播，各用户给自己的主机配置多播组列表如下所示 主机B属于两个多播组，主机C也属于两个多播组，而主机D不属于任何多播组 主机A首先要构建该多播帧，在帧首部中的目的地址字段填入该多播地址，源地址点填入自己的MAC地址，再加上帧首部中的其他字段、数据载荷以及帧尾部，就构成了该多播帧 主机A将该多播帧发送出去，主机B、C、D都会收到该多播帧 主机B和C发现该多播帧的目的MAC地址在自己的多播组列表中，主机B和C都会接受该帧 主机D发现该多播帧的目的MAC地址不在自己得多播组列表中，则丢弃该多播帧 给主机配置多播组列表进行私有应用时，不得使用公有的标准多播地址 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:1:6","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#多播mac地址举例"},{"categories":["网络"],"content":"IP地址IP地址属于网络层的范畴，不属于数据链路层的范畴 下面内容讲的是IP地址的使用，详细的IP地址内容在网络层中介绍 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#ip地址"},{"categories":["网络"],"content":"基本概念","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:2:1","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#基本概念-3"},{"categories":["网络"],"content":"从网络体系结构看IP地址与MAC地址","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:2:2","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#从网络体系结构看ip地址与mac地址"},{"categories":["网络"],"content":"数据包转发过程中IP地址与MAC地址的变化情况图上各主机和路由器各接口的IP地址和MAC地址用简单的标识符来表示 如何从IP地址找出其对应的MAC地址？ ARP协议 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:2:3","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#数据包转发过程中ip地址与mac地址的变化情况"},{"categories":["网络"],"content":"ARP协议如何从IP地址找出其对应的MAC地址？ ARP（地址解析协议） ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:3:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#arp协议"},{"categories":["网络"],"content":"流程ARP高速缓存表 当主机B要给主机C发送数据包时，会首先在自己的ARP高速缓存表中查找主机C的IP地址所对应的MAC地址，但未找到，因此，主机B需要发送ARP请求报文，来获取主机C的MAC地址 ARP请求报文有具体的格式，上图的只是简单描述 ARP请求报文被封装在MAC帧中发送，目的地址为广播地址 主机B发送封装有ARP请求报文的广播帧，总线上的其他主机都能收到该广播帧 收到ARP请求报文的主机A和主机C会把ARP请求报文交给上层的ARP进程 主机A发现所询问的IP地址不是自己的IP地址，因此不用理会 主机C的发现所询问的IP地址是自己的IP地址，需要进行相应 动态与静态的区别 ARP协议只能在一段链路或一个网络上使用，而不能跨网络使用 ARP协议的使用是逐段链路进行的 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:3:1","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#流程"},{"categories":["网络"],"content":"总结 ARP表中的IP地址与MAC地址的对应关系记录，是会定期自动删除的，因为IP地址与MAC地址的对应关系不是永久性的 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:3:2","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#总结-1"},{"categories":["网络"],"content":"3.8、集线器与交换机的区别","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#38集线器与交换机的区别"},{"categories":["网络"],"content":"集线器-在物理层扩展以太网","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#集线器-在物理层扩展以太网"},{"categories":["网络"],"content":"概念 传统以太网最初是使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用更便宜和更灵活的双绞线。 采用双绞线的以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，叫做集线器 (hub)。 集线器是也可以看做多口中继器，每个端口都可以成为一个中继器，中继器是对减弱的信号进行放大和发送的设备 集线器的以太网在逻辑上仍是个总线网，需要使用CSMA/CD协议来协调各主机争用总线，只能工作在半双工模式，收发帧不能同时进行 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:1:1","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#概念"},{"categories":["网络"],"content":"集线器HUB在物理层扩展以太网使用集线器扩展：将多个以太网段连成更大的、多级星形结构的以太网 优点 使原来属于不同碰撞域的以太网上的计算机能够进行跨碰撞域的通信。 扩大了以太网覆盖的地理范围。 缺点 碰撞域增大了，但总的吞吐量并未提高。 如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。 碰撞域 碰撞域（collision domain）又称为冲突域，是指网络中一个站点发出的帧会与其他站点发出的帧产生碰撞或冲突的那部分网络。 碰撞域越大，发生碰撞的概率越高。 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:1:2","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#集线器hub在物理层扩展以太网"},{"categories":["网络"],"content":"以太网交换机-在数据链路层扩展以太网","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#以太网交换机-在数据链路层扩展以太网"},{"categories":["网络"],"content":"概念 扩展以太网更常用的方法是在数据链路层进行。 早期使用网桥，现在使用以太网交换机。 网桥 网桥工作在数据链路层。 它根据 MAC 帧的目的地址对收到的帧进行转发和过滤。 当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的MAC 地址，然后再确定将该帧转发到哪一个接口，或把它丢弃。 交换机 1990 年问世的交换式集线器 (switching hub) 可明显地提高以太网的性能。 交换式集线器常称为以太网交换机 (switch) 或第二层交换机 (L2 switch)，强调这种交换机工作在数据链路层。 以太网交换机实质上就是一个多接口的网桥 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:2:1","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#概念-1"},{"categories":["网络"],"content":"集线器HUB与交换机SWITCH区别 使用集线器互连而成的共享总线式以太网上的某个主机，要给另一个主机发送单播帧，该单播帧会通过共享总线传输到总线上的其他各个主机 使用交换机互连而成的交换式以太网上的某个主机，要给另一个主机发送单播帧，该单播帧进入交换机后，交换机会将该单播帧转发给目的主机，而不是网络中的其他各个主机 这个例子的前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了 以太网交换机的交换方式 存储转发方式 把整个数据帧先缓存后再进行处理。 直通 (cut-through) 方式 接收数据帧的同时就立即按数据帧的目的 MAC 地址决定该帧的转发接口，因而提高了帧的转发速度。 缺点是它不检查差错就直接将帧转发出去，因此有可能也将一些无效帧转发给其他的站。 这个例子的前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了 对比集线器和交换机 多台主机同时给另一台主机发送单播帧 集线器以太网：会产生碰撞，遭遇碰撞的帧会传播到总线上的各主机 交换机以太网：会将它们缓存起来，然后逐个转发给目的主机，不会产生碰撞 这个例子的前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了 集线器扩展以太网和交换机扩展以太网区别 单播 广播 多个单播 广播域（broadcast domain）：指这样一部分网络，其中任何一台设备发出的广播通信都能被该部分网络中的所有其他设备所接收。 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:2:2","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#集线器hub与交换机switch区别"},{"categories":["网络"],"content":"总结 工作在数据链路层的以太网交换机，其性能远远超过工作在物理层的集线器，而且价格并不贵，这就使得集线器逐渐被市场淘汰 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:3:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#总结-2"},{"categories":["网络"],"content":"3.9、以太网交换机自学习和转发帧的流程","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#39以太网交换机自学习和转发帧的流程"},{"categories":["网络"],"content":"概念","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#概念-2"},{"categories":["网络"],"content":"自学习和转发帧的例子以下例子假设各主机知道网络中其他各主机的MAC地址（无需进行ARP） A -\u003e B A 先向 B 发送一帧。该帧从接口 1 进入到交换机 交换机收到帧后，先查找（图中左边）交换表。没有查到应从哪个接口转发这个帧给 B 交换机把这个帧的源地址 A 和接口 1 写入（图中左边）交换表中 交换机向除接口 1 以外的所有的接口广播这个帧 接口 4到接口 2，先查找（图中右边）交换表。没有查到应从哪个接口转发这个帧给 B 交换机把这个帧的源地址 A 和接口 1 写入（图中右边）交换表中 除B主机之外与该帧的目的地址不相符，将丢弃该帧 主机B发现是给自己的帧，接受该帧 B -\u003e A B 向 A 发送一帧。该帧从接口 3 进入到交换机 交换机收到帧后，先查找（图中左边）交换表。发现（图中左边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口1转发出去。于是就把这个帧传送到接口 1 转发给 A。 主机 A 发现目的地址是它，就接受该帧 交换机把这个帧的源地址 B 和接口 3 写入（图中左边）交换表中 E -\u003e A E 向 A发送一帧 交换机收到帧后，先查找（图中右边）交换表。发现（图中右边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口2转发出去。于是就把这个帧传送到接口 2 转发给 接口 4。 交换机把这个帧的源地址 E 和接口 3 写入（图中右边）交换表中 接口 4 到 左边的交换机，先查找（图中左边）交换表。发现（图中左边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口1转发出去。于是就把这个帧传送到接口 1 转发给 A。 交换机把这个帧的源地址 E 和接口 4 写入（图中左边）交换表中 主机 A 发现目的地址是它，就接受该帧 G -\u003e A 主机 A、主机 G、交换机 1的接口 1就共享同一条总线（相当于总线式网络，可以想象成用集线器连接了） 主机 G 发送给 主机 A 一个帧 主机 A 和 交换机接口 1都能接收到 主机 A 的网卡收到后，根据帧的目的MAC地址A，就知道是发送给自己的帧，就接受该帧 交换机 1收到该帧后，首先进行登记工作 然后交换机 1对该帧进行转发，该帧的MAC地址是A，在（图中左边）交换表查找MAC 地址有 A MAC 地址为 A的接口号是1，但是该帧正是从接口 1 进入交换机的，交换机不会再从该接口 1 将帧转发出去，因为这是没有必要，于是丢弃该帧 随着网络中各主机都发送了帧后，网络中的各交换机就可以学习到各主机的MAC地址，以及它们与自己各接口的对应关系 考虑到可能有时要在交换机的接口更换主机，或者主机要更换其网络适配器，这就需要更改交换表中的项目。为此，在交换表中每个项目都设有一定的有效时间。过期的项目就自动被删除。 以太网交换机的这种自学习方法使得以太网交换机能够即插即用，不必人工进行配置，因此非常方便。 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#自学习和转发帧的例子"},{"categories":["网络"],"content":"总结交换机自学习和转发帧的步骤归纳 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:3:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#总结-3"},{"categories":["网络"],"content":"3.10、以太网交换机的生成树协议STP","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#310以太网交换机的生成树协议stp"},{"categories":["网络"],"content":"如何提高以太网的可靠性","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#如何提高以太网的可靠性"},{"categories":["网络"],"content":"生成树协议STP IEEE 802.1D 标准制定了一个生成树协议 STP (Spanning Tree Protocol)。 其要点是：不改变网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是无环路的树状结构，从而消除了兜圈子现象。 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#生成树协议stp"},{"categories":["网络"],"content":"3.11、虚拟局域网VLAN","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#311虚拟局域网vlan"},{"categories":["网络"],"content":"为什么要虚拟局域网VLAN广播风暴 分割广播域的方法 为了分割广播域，所以虚拟局域网VLAN技术应运而生 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#为什么要虚拟局域网vlan"},{"categories":["网络"],"content":"概念 利用以太网交换机可以很方便地实现虚拟局域网 VLAN (Virtual LAN)。 IEEE 802.1Q 对虚拟局域网 VLAN 的定义： 虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组，而这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算机是属于哪一个 VLAN。 同一个VLAN内部可以广播通信，不同VLAN不可以广播通信 虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。 由于虚拟局域网是用户和网络资源的逻辑组合，因此可按照需要将有关设备和资源非常方便地重新组合，使用户从不同的服务器或数据库中存取所需的资源。 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#概念-3"},{"categories":["网络"],"content":"虚拟局域网VLAN的实现机制虚拟局域网VLAN技术是在交换机上实现的，需要交换机能够实现以下功能 能够处理带有VLAN标记的帧——IEEE 802.1 Q帧 交换机的各端口可以支持不同的端口类型，不同端口类型的端口对帧的处理方式有所不同 Access端口 交换机与用户计算机之间的互连 同一个VLAN内部可以广播通信，不同VLAN不可以广播通信 Truck端口 交换机之间或交换机与路由器之间的互连 小例题 华为交换机私有的Hybrid端口类型 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:3:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#虚拟局域网vlan的实现机制"},{"categories":["网络"],"content":"总结 虚拟局域网优点 虚拟局域网（VLAN）技术具有以下主要优点： 改善了性能 简化了管理 降低了成本 改善了安全性 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:4:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第3章（数据链路层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/#总结-4"},{"categories":["网络"],"content":"2.1、物理层的基本概念","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第2章（物理层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/#21物理层的基本概念"},{"categories":["网络"],"content":"2.2、物理层下面的传输媒体传输媒体也称为传输介质或传输媒介，他就是数据传输系统中在发送器和接收器之间的物理通路。传输媒体课分为两大类，即导引型传输媒体和非导引型传输媒体 传输媒体不属于计算机网络体系结构的任何一层。如果非要将它添加到体系结构中，那只能将其放置到物理层之下。 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第2章（物理层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/#22物理层下面的传输媒体"},{"categories":["网络"],"content":"导引型传输媒体在导引型传输媒体中，电磁波被导引沿着固体媒体传播。 同轴电缆 双绞线 光纤 多模光纤 可以存在多条不同角度入射的光线在一条光纤中传输。这种光纤就称为多模光纤。 单模光纤 若光纤的直径减小到只有一个光的波长，则光纤就像一根波导那样，它可使光线一直向前传播，而不会产生多次反射。这样的光纤称为单模光纤。 电力线 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第2章（物理层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/#导引型传输媒体"},{"categories":["网络"],"content":"非导引型传输媒体非导引型传输媒体是指自由空间。 无线电波 微波 红外线 可见光 LIFI ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第2章（物理层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/#非导引型传输媒体"},{"categories":["网络"],"content":"2.3、传输方式","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第2章（物理层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/#23传输方式"},{"categories":["网络"],"content":"串行传输和并行传输 串行传输： 数据是一个比特一个比特依次发送的，因此在发送端与接收端之间，只需要一条数据传输线路即可 并行传输： 一次发送n个比特，因此，在发送端和接收端之间需要有n条传输线路 并行传输的优点是比串行传输的速度n倍，但成本高 数据在传输线路上的传输采用是串行传输，计算机内部的数据传输常用并行传输 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第2章（物理层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/#串行传输和并行传输"},{"categories":["网络"],"content":"同步传输和异步传输 同步传输： 数据块以稳定的比特流的形式传输。字节之间没有间隔 接收端在每个比特信号的中间时刻进行检测，以判别接收到的是比特0还是比特1 由于不同设备的时钟频率存在一定差异，不可能做到完全相同，在传输大量数据的过程中，所产生的判别时刻的累计误差，会导致接收端对比特信号的判别错位 所以要使收发双发时钟保持同步 异步传输： 以字节为独立的传输单位，字节之间的时间间隔不是固定 接收端仅在每个字节的起始处对字节内的比特实现同步 通常在每个字节前后分别加上起始位和结束位 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第2章（物理层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/#同步传输和异步传输"},{"categories":["网络"],"content":"单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）在许多情况下，我们要使用“信道（channel）”这一名词。信道和电路并不等同。信道一般都是用来表示向某一个方向传送信息的媒体。因此，一条通信电路往往包含一条发送信道和一条接收信道。 从通信的双方信息交互的方式来看，可以有以下三种基本方式： 单向通信： 又称为单工通信，即只能有一个方向的通信而没有反方向的交互。无线电广播或有线电以及电视广播就属于这种类型 双向交替通信： 又称为半双工通信，即通信的双方可以发送信息，但不能双方同时发送（当然也就不能同时接收）。这种通信方式使一方发送另一方接收，过一段时间后可以再反过来 双向同时通信： 又称为全双工通信，即通信的双发可以同时发送和接收信息。 单向通信只需要一条信道，而双向交替通信或双向同时通信则需要两条信道（每个方向各一条） 双向同时通信的传输效率最高 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/:3:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第2章（物理层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/#单向通信单工双向交替通信半双工和双向同时通信全双工"},{"categories":["网络"],"content":"2.4、编码与调制 常用术语 数据 (data) —— 运送消息的实体。 信号 (signal) —— 数据的电气的或电磁的表现。 模拟信号 (analogous signal) —— 代表消息的参数的取值是连续的。 数字信号 (digital signal) —— 代表消息的参数的取值是离散的。 码元 (code) —— 在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形。 基带信号（即基本频带信号）—— 来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。 基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。因此必须对基带信号进行调制 (modulation)。 在计算机网络中，常见的是将数字基带信号通过编码或调制的方法在相应信道进行传输 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第2章（物理层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/#24编码与调制"},{"categories":["网络"],"content":"传输媒体与信道的关系 信道的几个基本概念 信道 —— 一般用来表示向某一个方向传送信息的媒体。 单向通信（单工通信）——只能有一个方向的通信而没有反方向的交互。 双向交替通信（半双工通信）——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。 双向同时通信（全双工通信）——通信的双方可以同时发送和接收信息。 严格来说，传输媒体不能和信道划等号 对于单工传输，传输媒体只包含一个信道，要么是发送信道，要么是接收信道 对于半双工和全双工，传输媒体中要包含两个信道，一个发送信道，另一个是接收信道 如果使用信道复用技术，一条传输媒体还可以包含多个信道 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第2章（物理层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/#传输媒体与信道的关系"},{"categories":["网络"],"content":"常用编码不归零编码 正电平表示比特1/0 负电平表示比特0/1 中间的虚线是零电平，所谓不归零编码，就是指在整个码元时间内，电平不会出现零电平 实际比特1和比特0的表示要看现实怎么规定 这需要发送方的发送与接收方的接收做到严格的同步 需要额外一根传输线来传输时钟信号，使发送方和接收方同步，接收方按时钟信号的节拍来逐个接收码元 但是对于计算机网络，宁愿利用这根传输线传输数据信号，而不是传输时钟信号 由于不归零编码存在同步问题，因此计算机网络中的数据传输不采用这类编码！ 归零编码 归零编码虽然自同步，但编码效率低 曼彻斯特编码 在每个码元时间的中间时刻，信号都会发生跳变 负跳变表示比特1/0 正跳变表示比特0/1 码元中间时刻的跳变即表示时钟，又表示数据 实际比特1和比特0的表示要看现实怎么规定 传统以太网使用的就是曼切斯特编码 差分曼彻斯特编码 在每个码元时间的中间时刻，信号都会发送跳变，但与曼彻斯特不同 跳变仅表示时钟 码元开始处电平是否变换表示数据 变化表示比特1/0 不变化表示比特0/1 实际比特1和比特0的表示要看现实怎么规定 比曼彻斯特编码变化少，更适合较高的传输速率 总结 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第2章（物理层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/#常用编码"},{"categories":["网络"],"content":"调制数字信号转换为模拟信号，在模拟信道中传输，例如WiFi，采用补码键控CCK/直接序列扩频DSSS/正交频分复用OFDM等调制方式。 模拟信号转换为另一种模拟信号，在模拟信道中传输，例如，语音数据加载到模拟的载波信号中传输。频分复用FDM技术，充分利用带宽资源。 基本调制方法 调幅AM：所调制的信号由两种不同振幅的基本波形构成。每个基本波形只能表示1比特信息量。 调频FM：所调制的信号由两种不同频率的基本波形构成。每个基本波形只能表示1比特信息量。 调相PM：所调制的信号由两种不同初相位的基本波形构成。每个基本波形只能表示1比特信息量。 但是使用基本调制方法，1个码元只能包含1个比特信息 混合调制 上图码元所对应的4个比特是错误的，码元不能随便对应4个比特 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/:3:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第2章（物理层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/#调制"},{"categories":["网络"],"content":"码元在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形。 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/:4:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第2章（物理层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/#码元"},{"categories":["网络"],"content":"2.5、信道的极限容量 任何实际的信道都不是理想的，在传输信号时会产生各种失真以及带来多种干扰。 码元传输的速率越高，或信号传输的距离越远，或传输媒体质量越差，在信道的输出端的波形的失真就越严重。 失真的原因： 码元传输的速率越高 信号传输的距离越远 噪声干扰越大 传输媒体质量越差 奈氏准则和香农公式对比： ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第2章（物理层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/#25信道的极限容量"},{"categories":["网络"],"content":"补充：信道复用技术本节内容视频未讲到，是《计算机网络（第7版）谢希仁》物理层的内容 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第2章（物理层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/#补充信道复用技术"},{"categories":["网络"],"content":"频分复用、时分复用和统计时分复用复用 (multiplexing) 是通信技术中的基本概念。 它允许用户使用一个共享信道进行通信，降低成本，提高利用率。 频分复用 FDM (Frequency Division Multiplexing) 将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。 频分复用的所有用户在同样的时间占用不同的带宽资源（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。 时分复用TDM (Time Division Multiplexing) 时分复用则是将时间划分为一段段等长的时分复用帧（TDM帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。 每一个用户所占用的时隙是周期性地出现（其周期就是TDM帧的长度）的。 TDM 信号也称为等时 (isochronous) 信号。 时分复用的所有用户在不同的时间占用同样的频带宽度。 时分复用可能会造成线路资源的浪费 使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的。 统计时分复用 STDM (Statistic TDM) ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第2章（物理层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/#频分复用时分复用和统计时分复用"},{"categories":["网络"],"content":"波分复用波分复用 WDM(Wavelength Division Multiplexing) ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第2章（物理层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/#波分复用"},{"categories":["网络"],"content":"码分复用码分复用 CDM (Code Division Multiplexing) 常用的名词是码分多址 CDMA (Code Division Multiple Access)。 各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。 这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/:3:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第2章（物理层）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/#码分复用"},{"categories":["网络"],"content":" 学习资料：[计算机网络微课堂——高军（https://www.bilibili.com/video/BV1c4411d7jb) ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第1章（概述）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/#"},{"categories":["网络"],"content":"图示说明代表着主机 代表服务器 代表着路由器 代表着网络 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第1章（概述）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/#图示说明"},{"categories":["网络"],"content":"1.1、计算机网络在信息时代的作用 计算机网络已由一种通信基础设施发展成为一种重要的信息服务基础设施 计算机网络已经像水，电，煤气这些基础设施一样，成为我们生活中不可或缺的一部分 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第1章（概述）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/#11计算机网络在信息时代的作用"},{"categories":["网络"],"content":"我国互联网发展状况中国互联网络信息中心CNNIC ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第1章（概述）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/#我国互联网发展状况"},{"categories":["网络"],"content":"1.2、因特网概述","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第1章（概述）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/#12因特网概述"},{"categories":["网络"],"content":"1、网络、互连网（互联网）和因特网网络：网络（Network）由若干**结点（Node）和连接这些结点的链路（Link）**组成。 互连网（互联网）：多个网络通过路由器互连起来，这样就构成了一个覆盖范围更大的网络，即互连网（互联网）。因此，互联网又称为“网络的网络（Network of Networks）”。 因特网：因特网（Internet）是世界上最大的互连网络（用户数以亿计，互连的网络数以百万计）。 internet与Internet的区别 internet(互联网或互连网)是一个通用名词，它泛指多个计算机网络互连而成的网络。在这些网络之间的通信协议可以是任意的。 Internet（因特网）则是一个专用名词，它指当前全球最大的、开放的、由众多网络互连而成的特定计算机网络，它采用TCP/IP协议族作为通信的规则，其前身是美国的ARPANET。 任意把几个计算机网络互连起来（不管采用什么协议），并能够相互通信，这样构成的是一个互连网(internet) ，而不是互联网(Internet)。 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第1章（概述）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/#1网络互连网互联网和因特网"},{"categories":["网络"],"content":"2、因特网发展的三个阶段因特网服务提供者ISP(Internet Service Provider) 普通用户是如何接入到因特网的呢？ 答：通过ISP接入因特网 ISP可以从因特网管理机构申请到成块的IP地址，同时拥有通信线路以及路由器等联网设备。任何机构和个人只需缴纳费用，就可从ISP的得到所需要的IP地址。 因为因特网上的主机都必须有IP地址才能进行通信，这样就可以通过该ISP接入到因特网 中国的三大ISP：中国电信，中国联通和中国移动 基于ISP的三层结构的因特网 一旦某个用户能够接入到因特网，那么他也可以成为一个ISP，所需要做的就是购买一些如调制解调器或路由器这样的设备，让其他用户可以和他相连。 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第1章（概述）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/#2因特网发展的三个阶段"},{"categories":["网络"],"content":"3、因特网的标准化工作 因特网的标准化工作对因特网的发展起到了非常重要的作用。 因特网在指定其标准上的一个很大的特点是面向公众。 因特网所有的RFC(Request For Comments)技术文档都可从因特网上免费下载； 任何人都可以随时用电子邮件发表对某个文档的意见或建议。 因特网协会ISOC是一个国际性组织，它负责对因特网进行全面管理，以及在世界范围内促进其发展和使用。 因特网体系结构委员会IAB，负责管理因特网有关协议的开发； 因特网工程部IETF，负责研究中短期工程问题，主要针对协议的开发和标准化； 因特网研究部IRTF，从事理论方面的研究和开发一些需要长期考虑的问题。 制订因特网的正式标准要经过一下4个阶段： 1、因特网草案（在这个阶段还不是RFC文档） 2、建议标准（从这个阶段开始就成为RFC文档） 3、草案标准 4、因特网标准 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/:3:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第1章（概述）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/#3因特网的标准化工作"},{"categories":["网络"],"content":"4、因特网的组成 边缘部分 由所有连接在因特网上的主机组成（台式电脑，大型服务器，笔记本电脑，平板，智能手机等）。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。 核心部分 由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）。 路由器是一种专用计算机，但我们不称它为主机，路由器是实现分组交换的关键构建，其任务是转发收到的分组，这是网络核心最重要的部分。 处在互联网边缘的部分就是连接在互联网上的所有的主机。这些主机又称为端系统 (end system)。 端系统在功能上可能有很大的差别： 小的端系统可以是一台普通个人电脑，具有上网功能的智能手机，甚至是一个很小的网络摄像头。 大的端系统则可以是一台非常昂贵的大型计算机。 端系统的拥有者可以是个人，也可以是单位（如学校、企业、政府机关等），当然也可以是某个ISP。 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/:4:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第1章（概述）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/#4因特网的组成"},{"categories":["网络"],"content":"补充：端系统之间通信的含义 “主机 A 和主机 B 进行通信”实际上是指：“运行在主机 A 上的某个程序和运行在主机 B 上的另一个程序进行通信”。即“主机 A 的某个进程和主机 B 上的另一个进程进行通信”。简称为“计算机之间通信”。 端系统之间的通信方式通常可划分为两大类： 客户-服务器方式： 客户 (client) 和服务器 (server) 都是指通信中所涉及的两个应用进程。 客户 - 服务器方式所描述的是进程之间服务和被服务的关系。 客户是服务的请求方，服务器是服务的提供方。 服务请求方和服务提供方都要使用网络核心部分所提供的服务。 对等连接方式： 对等连接 (peer-to-peer，简写为 P2P ) 是指两个主机在通信时并不区分哪一个是服务请求方还是服务提供方。 只要两个主机都运行了对等连接软件 ( P2P 软件) ，它们就可以进行平等的、对等连接通信。 双方都可以下载对方已经存储在硬盘中的共享文档。 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/:4:1","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第1章（概述）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/#补充"},{"categories":["网络"],"content":"1.3 三种交换方式网络核心部分是互联网中最复杂的部分。 网络中的核心部分要向网络边缘中的大量主机提供连通性，使边缘部分中的任何一个主机都能够向其他主机通信（即传送或接收各种形式的数据）。 在网络核心部分起特殊作用的是路由器(router)。 路由器是实现分组交换 (packet switching) 的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第1章（概述）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/#13-三种交换方式"},{"categories":["网络"],"content":"1、电路交换（Circuit Switching） 传统两两相连的方式，当电话数量很多时，电话线也很多，就很不方便 所以要使得每一部电话能够很方便地和另一部电话进行通信，就应该使用一个中间设备将这些电话连接起来，这个中间设备就是电话交换机 电话交换机接通电话线的方式称为电路交换； 从通信资源的分配角度来看，交换（Switching）就是按照某种方式动态地分配传输线路的资源； 电路交换的三个步骤： 1、建立连接（分配通信资源） 2、通话（一直占用通信资源） 3、释放连接（归还通信资源） 当使用电路交换来传送计算机数据时，其线路的传输效率往往很低。 这是因为计算机数据是突发式地出现在传输线路上的。 所以计算机通常采用的是分组交换，而不是线路交换 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第1章（概述）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/#1电路交换circuit-switching"},{"categories":["网络"],"content":"2、分组交换（Packet Switching） 通常我们把表示该消息的整块数据成为一个报文。 在发送报文之前，先把较长的报文划分成一个个更小的等长数据段，在每一个数据段前面。加上一些由必要的控制信息组成的首部后，就构成一个分组，也可简称为“包”，相应地，首部也可称为“包头”。 首部包含了分组的目的地址 分组从源主机到目的主机，可走不同的路径。 发送方 构造分组 发送分组 路由器 缓存分组 转发分组 简称为“分组转发” 在路由器中的输入和输出端口之间没有直接连线。 路由器处理分组的过程是： 把收到的分组先放入缓存（暂时存储）； 查找转发表，找出到某个目的地址应从哪个端口转发； 把分组送到适当的端口转发出去。 接收方 接收分组 还原报文 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第1章（概述）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/#2分组交换packet-switching"},{"categories":["网络"],"content":"3、报文交换（Message Switching）报文交换中的交换结点也采用存储转发方式，但报文交换对报文的大小没有限制，这就要求交换结点需要较大的缓存空间。报文交换主要用于早期的电报通信网，现在较少使用，通常被较先进的分组交换方式所取代。 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/:3:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第1章（概述）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/#3报文交换message-switching"},{"categories":["网络"],"content":"三种交换方式的对比 假设A，B，C，D是分组传输路径所要经过的4个结点交换机，纵坐标为时间 分析： 电路交换： 通信之前首先要建立连接；连接建立好之后，就可以使用已建立好的连接进行数据传送；数据传送后，需释放连接，以归还之前建立连接所占用的通信线路资源。 一旦建立连接，中间的各结点交换机就是直通形式的，比特流可以直达终点； 报文交换： 可以随时发送报文，而不需要事先建立连接；整个报文先传送到相邻结点交换机，全部存储下来后进行查表转发，转发到下一个结点交换机。 整个报文需要在各结点交换机上进行存储转发，由于不限制报文大小，因此需要各结点交换机都具有较大的缓存空间。 分组交换： 可以随时发送分组，而不需要事先建立连接。构成原始报文的一个个分组，依次在各结点交换机上存储转发。各结点交换机在发送分组的同时，还缓存接收到的分组。 构成原始报文的一个个分组，在各结点交换机上进行存储转发，相比报文交换，减少了转发时延，还可以避免过长的报文长时间占用链路，同时也有利于进行差错控制。 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/:4:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第1章（概述）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/#三种交换方式的对比"},{"categories":["网络"],"content":"1.4 计算机网络的定义和分类","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第1章（概述）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/#14-计算机网络的定义和分类"},{"categories":["网络"],"content":"定义 计算机网络的精确定义并未统一 计算机网络的最简单的定义是：一些互相连接的、自治的计算机的集合。 互连：是指计算机之间可以通过有线或无线的方式进行数据通信； 自治：是指独立的计算机，他有自己的硬件和软件，可以单独运行使用； 集合：是指至少需要两台计算机； 计算机网络的较好的定义是：计算机网络主要是由一些通用的，可编程的硬件（一定包含有中央处理机CPU）互连而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。 计算机网络所连接的硬件，并不限于一般的计算机，而是包括了智能手机等智能硬件。 计算机网络并非专门用来传送数据，而是能够支持很多种的应用（包括今后可能出现的各种应用）。 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第1章（概述）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/#定义"},{"categories":["网络"],"content":"分类按交换技术分类： 电路交换网络 报文交换网络 分组交换网络 按使用者分类： 公用网 专用网 按传输介质分类： 有线网络 无线网络 按覆盖范围分类： 广域网WAN（Wide Area Network） 作用范围通常为几十到几千公里，因而有时也称为远程网（long haul network）。广域网是互联网的核心部分，其任务是通过长距离（例如，跨越不同的国家）运送主机所发送的数据。 城域网MAN 作用范围一般是一个城市，可跨越几个街区甚至整个城市 局域网LAN 一般用微型计算机或工作站通过高速通信线路相连（速率通常在 10 Mbit/s 以上），但地理上范围较小（1 km 左右） 个域网PAN 就是在个人工作的地方把个人使用的电子设备用无线技术连接起来的网络。 按拓扑结构分类： 总线型网络 星型网络 环形网络 网状型网络 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第1章（概述）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/#分类"},{"categories":["网络"],"content":"1.5 计算机网络的性能指标","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第1章（概述）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/#15-计算机网络的性能指标"},{"categories":["网络"],"content":"速率","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第1章（概述）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/#速率"},{"categories":["网络"],"content":"带宽","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第1章（概述）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/#带宽"},{"categories":["网络"],"content":"吞吐量 带宽1 Gb/s的以太网，代表其额定速率是1 Gb/s，这个数值也是该以太网的吞吐量的绝对上限值。因此，对于带宽1 Gb/s的以太网，可能实际吞吐量只有 700 Mb/s，甚至更低。 注意：吞吐量还可以用每秒传送的字节数或帧数表示 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/:3:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第1章（概述）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/#吞吐量"},{"categories":["网络"],"content":"时延时延时指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。 网络时延由几部分组成： 发送时延 主机或路由器发送数据帧所需要的时间，也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。 传播时延 电磁波在信道中传播一定的距离需要花费的时间。 处理时延 主机或路由器在收到分组时要花费一定时间进行处理 排队时延 分组在进过网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理。 有时会把排队时延看成处理时延 一部分 总时延 = 发送时延 + 传播时延 + 处理时延 （处理时延 + 排队时延） 当处理时延忽略不计时，发送时延 和 传播时延谁占主导，要具体情况具体分析 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/:4:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第1章（概述）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/#时延"},{"categories":["网络"],"content":"时延带宽积时延带宽积 = 传播时延 * 带宽 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/:5:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第1章（概述）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/#时延带宽积"},{"categories":["网络"],"content":"往返时间互联网上的信息不仅仅单方向传输而是双向交互的。因此，我们有时很需要知道双向交互一次所需的时间。 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/:6:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第1章（概述）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/#往返时间"},{"categories":["网络"],"content":"利用率利用率有信道利用率和网络利用率两种。 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/:7:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第1章（概述）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/#利用率"},{"categories":["网络"],"content":"丢包率 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/:8:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第1章（概述）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/#丢包率"},{"categories":["网络"],"content":"1.6 计算机网络体系结构","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/:0:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第1章（概述）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/#16-计算机网络体系结构"},{"categories":["网络"],"content":"1、常见的计算机网络体系结构 如今用的最多的是TCP/IP体系结构，现今规模最大的、覆盖全球的、基于TCP/IP的互联网并未使用OSI标准。 TCP/IP体系结构相当于将OSI体系结构的物理层和数据链路层合并为了网络接口层，并去掉了会话层和表示层。 TCP/IP在网络层使用的协议是IP协议，IP协议的意思是网际协议，因此TCP/IP体系结构的网络层称为网际层 在用户主机的操作系统中，通常都带有符合TCP/IP体系结构标准的TCP/IP协议族。 而用于网络互连的路由器中，也带有符合TCP/IP体系结构标准的TCP/IP协议族。 只不过路由器一般只包含网络接口层和网际层。 网络接口层：并没有规定具体内容，这样做的目的是可以互连全世界各种不同的网络接口，例如：有线的以太网接口，无线局域网的WIFI接口等。 网际层：它的核心协议是IP协议。 运输层：TCP和UDP是这层的两个重要协议。 应用层：这层包含了大量的应用层协议，如 HTTP , DNS 等。 **IP协议（网际层）可以将不同的网络接口（网络接口层）进行互连，并向其上的TCP协议和UDP协议（运输层）**提供网络互连服务 而TCP协议在享受IP协议提供的网络互连服务的基础上，可向应用层的相应协议提供可靠的传输服务。 UDP协议在享受IP协议提供的网络互连服务的基础上，可向应用层的相应协议提供不可靠的传输服务。 TCP/IP体系结构中最重要的是IP协议和TCP协议，因此用TCP和IP来表示整个协议大家族。 教学时把TCP/IP体系结构的网络接口层分成了物理层和数据链路层 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/:1:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第1章（概述）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/#1常见的计算机网络体系结构"},{"categories":["网络"],"content":"2、计算机网络体系结构分层的必要性物理层问题 这图说明 第一，严格来说，传输媒体并不属于物理层 计算机传输的信号，并不是图示的方波信号 这样举例只是让初学者容易理解 数据链路层问题 网络层问题 运输层问题 如何标识与网络通信相关的应用进程：一个分组到来，我们应该交给哪个进程处理呢？浏览器进程还是QQ进程 应用层问题 应用层该用什么方法（应用层协议）去解析数据 总结 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/:2:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第1章（概述）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/#2计算机网络体系结构分层的必要性"},{"categories":["网络"],"content":"3、计算机网络体系结构分层思想举例例子：主机的浏览器如何与Web服务器进行通信 解析： 主机和Web服务器之间基于网络的通信，实际上是主机中的浏览器应用进程与Web服务器中的Web服务器应用进程之间基于网络的通信 体系结构的各层在整个过程中起到怎样的作用？ 1、发送方发送 第一步： 应用层按照HTTP协议的规定构建一个HTTP请求报文 应用层将HTTP请求报文交付给运输层处理 第二步： 运输层给HTTP请求报文添加一个TCP首部，使之成为TCP报文段 TCP报文段的首部格式作用是区分应用进程以及实现可靠传输 运输层将TCP报文段交付给网络层处理 第三步： 网络层给TCP报文段添加一个IP首部，使之成为IP数据报 IP数据报的首部格式作用是使IP数据报可以在互联网传输，也就是被路由器转发 网络层将IP数据报交付给数据链路层处理 第四步： 数据链路层给IP数据报添加一个首部和一个尾部，使之成为帧 （图示右边为首部，左边为尾部） 该首部的作用主要是为了让帧能够在一段链路上或一个网络上传输，能够被相应的目的主机接收 该尾部的作用是让目的主机检查所接收到的帧是否有误码 数据链路层将帧交付给物理层 第五步： 物理层先将帧看做是比特流，这里的网络N1假设是以太网，所以物理层还会给该比特流前面添加前导码 前导码的作用是为了让目的主机做好接收帧的准备 物理层将装有前导码的比特流变换成相应的信号发送给传输媒体 第六步： 信号通过传输媒体到达路由器 2、路由器转发 在路由器中 物理层将信号变为比特流，然后去掉前导码后，将其交付给数据链路层 数据链路层将帧的首部和尾部去掉后，将其交付给网络层，这实际交付的是IP数据报 网络层解析IP数据报的首部，从中提取目的网络地址 在路由器中 提取目的网络地址后查找自身路由表。确定转发端口， 以便进行转发 网络层将IP数据报交付给数据链路层 数据链路层给IP数据报添加一个首部和一个尾部，使之成为帧 数据链路层将帧交付给物理层 物理层先将帧看成比特流，这里的网络N2假设是以太网，所以物理层还会给该比特流前面添加前导码 物理层将装有前导码的比特流变换成相应的信号发送给传输媒体，信号通过传输媒体到达Web服务器 3、接收方接收 和发送方（主机）发送过程的封装正好是反着来 在Web 服务器上 物理层将信号变换为比特流，然后去掉前导码后成为帧，交付给数据链路层 数据链路层将帧的首部和尾部去掉后成为IP数据报，将其交付给网络层 网络层将IP数据报的首部去掉后成为TCP报文段，将其交付给运输层 运输层将TCP报文段的首部去掉后成为HTTP请求报文，将其交付给应用层 应用层对HTTP请求报文进行解析，然后给主机发回响应报文 发回响应报文的步骤和之前过程类似 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/:3:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第1章（概述）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/#3计算机网络体系结构分层思想举例"},{"categories":["网络"],"content":"4、计算机网络体系结构中的专用术语以下介绍的专用术语来源于OSI的七层协议体系结构，但也适用于TCP/IP的四层体系结构和五层协议体系结构 实体 协议 协议：控制两个对等实体进行逻辑通信的规则的集合 协议三要素： 语法：定义所交换信息的格式 语义：定义收发双方所要完成的操作 同步：定义收发双发的时序关系 服务 ","date":"2022-03-08","objectID":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/:4:0","series":["计算机网络学习笔记"],"tags":["TCP/IP"],"title":"计算机网络第1章（概述）","uri":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0/#4计算机网络体系结构中的专用术语"},{"categories":["前端"],"content":"一、javaScript基础总结","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:0:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#一javascript基础总结"},{"categories":["前端"],"content":"1、数据类型相关知识点","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:1:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#1数据类型相关知识点"},{"categories":["前端"],"content":"Ⅰ-基本(值)类型 String: 任意字符串 Number: 任意的数字 boolean: true/false undefined: undefined null: null –\u003e使用typeof时返回object symbol (ECMAScript 2016新增)。 –\u003eSymbol 是 基本数据类型 的一种，Symbol 对象是 Symbol原始值的封装 (en-US) 。 bigint， –\u003eBigInt 是一种数字类型的数据，它可以表示任意精度格式的整数。 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:1:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-基本值类型"},{"categories":["前端"],"content":"Ⅱ-对象(引用)类型 Object: 任意对象 Function: 一种特别的对象(可以执行) –内部包含可运行的代码 Array: 一种特别的对象(key为数值下标属性, 内部数据是有序的) ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:1:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-对象引用类型"},{"categories":["前端"],"content":"Ⅲ-判断方法①* typeof* typeof 操作符返回一个字符串，表示未经计算的操作数的类型。 可以判断: undefined/ 数值 / 字符串 / 布尔值 / function 不能判断: null与object object与array 注意: 运行console.log(typeof undefined)时,得到的的也是一个字符串,同时为小写!!–\u003e 'undefined' 代码示例 // typeof返回数据类型的字符串表达 var a //注意:typeof返回的是字符串 console.log(a, typeof a, typeof a==='undefined',a===undefined ) // undefined 'undefined' true true console.log(undefined === 'undefined') //false a = 4 console.log(typeof a==='number') //true a = 'hongjilin' console.log(typeof a==='string') //true console.log(typeof a==='String') //false --\u003e注意,返回的类型为小写 a = true console.log(typeof a==='boolean') //true a = null console.log(typeof a, a===null) // 'object' true let b={} console.log(typeof b,typeof null, '-------') // 'object' 'object' --\u003e所以Typeof不能判断null与object ②*instanceof*(判断实例方法) 专门判断对象的具体类型 instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。 代码示例: var b1 = { b2: [1, 'abc', console.log], //可以简化成 b3:()=\u003e()=\u003e 'hongjilin' --\u003e高阶函数相关知识 b3: function () { return () =\u003e{ return 'hongjilin'} } } /**使用instanceof进行对象判断*/ console.log(b1 instanceof Object, b1 instanceof Array) // true false console.log(b1.b2 instanceof Array, b1.b2 instanceof Object) // true true console.log(b1.b3 instanceof Function, b1.b3 instanceof Object) // true true /**使用typeof进行对象中某属性的判断*/ console.log(typeof b1.b2, typeof null) // 'object' 'object' console.log(typeof b1.b3==='function') // true console.log(typeof b1.b2[2]==='function') //true /**调用对象与数组中某函数示例*/ b1.b2[2]('调用console.log打印hongjilin') //调用console.log打印hongjilin console.log(b1.b3()()) // hongjilin ③*===* 具体可以看 MDN的JavaScript中的相等性判断 可以判断: undefined, null 简而言之，在比较两件事情时，双等号将执行类型转换; 三等号将进行相同的比较，而不进行类型转换 (如果类型不同, 只是总会返回 false ) ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:1:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-判断方法"},{"categories":["前端"],"content":"Ⅲ-判断方法①* typeof* typeof 操作符返回一个字符串，表示未经计算的操作数的类型。 可以判断: undefined/ 数值 / 字符串 / 布尔值 / function 不能判断: null与object object与array 注意: 运行console.log(typeof undefined)时,得到的的也是一个字符串,同时为小写!!– 'undefined' 代码示例 // typeof返回数据类型的字符串表达 var a //注意:typeof返回的是字符串 console.log(a, typeof a, typeof a==='undefined',a===undefined ) // undefined 'undefined' true true console.log(undefined === 'undefined') //false a = 4 console.log(typeof a==='number') //true a = 'hongjilin' console.log(typeof a==='string') //true console.log(typeof a==='String') //false --注意,返回的类型为小写 a = true console.log(typeof a==='boolean') //true a = null console.log(typeof a, a===null) // 'object' true let b={} console.log(typeof b,typeof null, '-------') // 'object' 'object' --所以Typeof不能判断null与object ②*instanceof*(判断实例方法) 专门判断对象的具体类型 instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。 代码示例: var b1 = { b2: [1, 'abc', console.log], //可以简化成 b3:()=()= 'hongjilin' --高阶函数相关知识 b3: function () { return () ={ return 'hongjilin'} } } /**使用instanceof进行对象判断*/ console.log(b1 instanceof Object, b1 instanceof Array) // true false console.log(b1.b2 instanceof Array, b1.b2 instanceof Object) // true true console.log(b1.b3 instanceof Function, b1.b3 instanceof Object) // true true /**使用typeof进行对象中某属性的判断*/ console.log(typeof b1.b2, typeof null) // 'object' 'object' console.log(typeof b1.b3==='function') // true console.log(typeof b1.b2[2]==='function') //true /**调用对象与数组中某函数示例*/ b1.b2[2]('调用console.log打印hongjilin') //调用console.log打印hongjilin console.log(b1.b3()()) // hongjilin ③*===* 具体可以看 MDN的JavaScript中的相等性判断 可以判断: undefined, null 简而言之，在比较两件事情时，双等号将执行类型转换; 三等号将进行相同的比较，而不进行类型转换 (如果类型不同, 只是总会返回 false ) ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:1:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-typeof"},{"categories":["前端"],"content":"Ⅲ-判断方法①* typeof* typeof 操作符返回一个字符串，表示未经计算的操作数的类型。 可以判断: undefined/ 数值 / 字符串 / 布尔值 / function 不能判断: null与object object与array 注意: 运行console.log(typeof undefined)时,得到的的也是一个字符串,同时为小写!!– 'undefined' 代码示例 // typeof返回数据类型的字符串表达 var a //注意:typeof返回的是字符串 console.log(a, typeof a, typeof a==='undefined',a===undefined ) // undefined 'undefined' true true console.log(undefined === 'undefined') //false a = 4 console.log(typeof a==='number') //true a = 'hongjilin' console.log(typeof a==='string') //true console.log(typeof a==='String') //false --注意,返回的类型为小写 a = true console.log(typeof a==='boolean') //true a = null console.log(typeof a, a===null) // 'object' true let b={} console.log(typeof b,typeof null, '-------') // 'object' 'object' --所以Typeof不能判断null与object ②*instanceof*(判断实例方法) 专门判断对象的具体类型 instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。 代码示例: var b1 = { b2: [1, 'abc', console.log], //可以简化成 b3:()=()= 'hongjilin' --高阶函数相关知识 b3: function () { return () ={ return 'hongjilin'} } } /**使用instanceof进行对象判断*/ console.log(b1 instanceof Object, b1 instanceof Array) // true false console.log(b1.b2 instanceof Array, b1.b2 instanceof Object) // true true console.log(b1.b3 instanceof Function, b1.b3 instanceof Object) // true true /**使用typeof进行对象中某属性的判断*/ console.log(typeof b1.b2, typeof null) // 'object' 'object' console.log(typeof b1.b3==='function') // true console.log(typeof b1.b2[2]==='function') //true /**调用对象与数组中某函数示例*/ b1.b2[2]('调用console.log打印hongjilin') //调用console.log打印hongjilin console.log(b1.b3()()) // hongjilin ③*===* 具体可以看 MDN的JavaScript中的相等性判断 可以判断: undefined, null 简而言之，在比较两件事情时，双等号将执行类型转换; 三等号将进行相同的比较，而不进行类型转换 (如果类型不同, 只是总会返回 false ) ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:1:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#instanceof判断实例方法"},{"categories":["前端"],"content":"Ⅲ-判断方法①* typeof* typeof 操作符返回一个字符串，表示未经计算的操作数的类型。 可以判断: undefined/ 数值 / 字符串 / 布尔值 / function 不能判断: null与object object与array 注意: 运行console.log(typeof undefined)时,得到的的也是一个字符串,同时为小写!!– 'undefined' 代码示例 // typeof返回数据类型的字符串表达 var a //注意:typeof返回的是字符串 console.log(a, typeof a, typeof a==='undefined',a===undefined ) // undefined 'undefined' true true console.log(undefined === 'undefined') //false a = 4 console.log(typeof a==='number') //true a = 'hongjilin' console.log(typeof a==='string') //true console.log(typeof a==='String') //false --注意,返回的类型为小写 a = true console.log(typeof a==='boolean') //true a = null console.log(typeof a, a===null) // 'object' true let b={} console.log(typeof b,typeof null, '-------') // 'object' 'object' --所以Typeof不能判断null与object ②*instanceof*(判断实例方法) 专门判断对象的具体类型 instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。 代码示例: var b1 = { b2: [1, 'abc', console.log], //可以简化成 b3:()=()= 'hongjilin' --高阶函数相关知识 b3: function () { return () ={ return 'hongjilin'} } } /**使用instanceof进行对象判断*/ console.log(b1 instanceof Object, b1 instanceof Array) // true false console.log(b1.b2 instanceof Array, b1.b2 instanceof Object) // true true console.log(b1.b3 instanceof Function, b1.b3 instanceof Object) // true true /**使用typeof进行对象中某属性的判断*/ console.log(typeof b1.b2, typeof null) // 'object' 'object' console.log(typeof b1.b3==='function') // true console.log(typeof b1.b2[2]==='function') //true /**调用对象与数组中某函数示例*/ b1.b2[2]('调用console.log打印hongjilin') //调用console.log打印hongjilin console.log(b1.b3()()) // hongjilin ③*===* 具体可以看 MDN的JavaScript中的相等性判断 可以判断: undefined, null 简而言之，在比较两件事情时，双等号将执行类型转换; 三等号将进行相同的比较，而不进行类型转换 (如果类型不同, 只是总会返回 false ) ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:1:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#heading"},{"categories":["前端"],"content":"Ⅳ-相关问题引出① undefined与null的区别? undefined代表定义未赋值 nulll定义并赋值了, 只是值为null 代码示例 var a console.log(a) // undefined a = null console.log(a) // null ② 什么时候给变量赋值为null呢? 初始赋值, 表明将要赋值为对象,可以用做约定俗成的占位符 结束前, 让对象成为垃圾对象(被垃圾回收器回收) 代码示例 //起始,可以用做约定俗成的占位符 var b = null // 初始赋值为null, 表明将要赋值为对象 //确定对象就赋值 b = ['atguigu', 12] //最后在不使用的时候,将其引用置空,就可以释放b这个对象占用的内存 ---当没有引用指向它的对象称为垃圾对象 b = null // 让b指向的对象成为垃圾对象(被垃圾回收器回收) ③ 严格区别变量类型与数据类型? 数据的类型 基本类型 对象类型 变量的类型(变量内存值的类型) 基本类型: 保存就是基本类型的数据 引用类型: 保存的是地址值(对象类型) ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:1:4","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-相关问题引出"},{"categories":["前端"],"content":"Ⅳ-相关问题引出① undefined与null的区别? undefined代表定义未赋值 nulll定义并赋值了, 只是值为null 代码示例 var a console.log(a) // undefined a = null console.log(a) // null ② 什么时候给变量赋值为null呢? 初始赋值, 表明将要赋值为对象,可以用做约定俗成的占位符 结束前, 让对象成为垃圾对象(被垃圾回收器回收) 代码示例 //起始,可以用做约定俗成的占位符 var b = null // 初始赋值为null, 表明将要赋值为对象 //确定对象就赋值 b = ['atguigu', 12] //最后在不使用的时候,将其引用置空,就可以释放b这个对象占用的内存 ---当没有引用指向它的对象称为垃圾对象 b = null // 让b指向的对象成为垃圾对象(被垃圾回收器回收) ③ 严格区别变量类型与数据类型? 数据的类型 基本类型 对象类型 变量的类型(变量内存值的类型) 基本类型: 保存就是基本类型的数据 引用类型: 保存的是地址值(对象类型) ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:1:4","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-undefined与null的区别"},{"categories":["前端"],"content":"Ⅳ-相关问题引出① undefined与null的区别? undefined代表定义未赋值 nulll定义并赋值了, 只是值为null 代码示例 var a console.log(a) // undefined a = null console.log(a) // null ② 什么时候给变量赋值为null呢? 初始赋值, 表明将要赋值为对象,可以用做约定俗成的占位符 结束前, 让对象成为垃圾对象(被垃圾回收器回收) 代码示例 //起始,可以用做约定俗成的占位符 var b = null // 初始赋值为null, 表明将要赋值为对象 //确定对象就赋值 b = ['atguigu', 12] //最后在不使用的时候,将其引用置空,就可以释放b这个对象占用的内存 ---当没有引用指向它的对象称为垃圾对象 b = null // 让b指向的对象成为垃圾对象(被垃圾回收器回收) ③ 严格区别变量类型与数据类型? 数据的类型 基本类型 对象类型 变量的类型(变量内存值的类型) 基本类型: 保存就是基本类型的数据 引用类型: 保存的是地址值(对象类型) ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:1:4","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-什么时候给变量赋值为null呢"},{"categories":["前端"],"content":"Ⅳ-相关问题引出① undefined与null的区别? undefined代表定义未赋值 nulll定义并赋值了, 只是值为null 代码示例 var a console.log(a) // undefined a = null console.log(a) // null ② 什么时候给变量赋值为null呢? 初始赋值, 表明将要赋值为对象,可以用做约定俗成的占位符 结束前, 让对象成为垃圾对象(被垃圾回收器回收) 代码示例 //起始,可以用做约定俗成的占位符 var b = null // 初始赋值为null, 表明将要赋值为对象 //确定对象就赋值 b = ['atguigu', 12] //最后在不使用的时候,将其引用置空,就可以释放b这个对象占用的内存 ---当没有引用指向它的对象称为垃圾对象 b = null // 让b指向的对象成为垃圾对象(被垃圾回收器回收) ③ 严格区别变量类型与数据类型? 数据的类型 基本类型 对象类型 变量的类型(变量内存值的类型) 基本类型: 保存就是基本类型的数据 引用类型: 保存的是地址值(对象类型) ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:1:4","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-严格区别变量类型与数据类型"},{"categories":["前端"],"content":"Ⅴ-补充知识点:①符串对比*\u003e、\u003c以及charCodeAt()*方法 Javascript字符串在进行大于(小于)比较时，会根据第一个不同的字符的ascii值码进行比较，当数字(number)与字符串(string)进行比较大小时，会强制的将数字(number)转换成字符串(string)然后再进行比较 (function(){ console.log('13'\u003e'3'); // 输出：false console.log(5\u003e'6'); // 输出： false console.log('d'\u003e'ABDC') // 输出： true console.log(19\u003e'ssf') // 输出 false console.log('A'\u003e'abcdef') // 输出 false })() 手动转换为ascii后相减,用正负数表示大小 sorter={(a:string,b:string)=\u003e a.charCodeAt()-b.charCodeAt()} ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:1:5","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-补充知识点"},{"categories":["前端"],"content":"Ⅴ-补充知识点:①符串对比*、'3'); // 输出：false console.log(5'6'); // 输出： false console.log('d''ABDC') // 输出： true console.log(19'ssf') // 输出 false console.log('A''abcdef') // 输出 false })() 手动转换为ascii后相减,用正负数表示大小 sorter={(a:string,b:string)= a.charCodeAt()-b.charCodeAt()} ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:1:5","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#符串对比以及charcodeat方法"},{"categories":["前端"],"content":"2、数据,变量, 内存的理解","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:2:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#2数据变量-内存的理解"},{"categories":["前端"],"content":"Ⅰ-什么是数据? 存储在内存中代表特定信息的’东西', 本质上是0101… 数据的特点: 可传递, 可运算 –\u003elet a=0;b=a 🔜体现可传递 一切皆数据 内存中所有操作的目标: 数据 算术运算 逻辑运算 赋值 运行函数 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:2:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-什么是数据"},{"categories":["前端"],"content":"Ⅱ-什么是内存? 内存条通电后产生的可储存数据的空间(临时的) 内存产生和死亡: 内存条(电路版)==\u003e通电==\u003e产生内存空间==\u003e存储数据==\u003e处理数据==\u003e断电==\u003e内存空间和数据都消失 一块小内存的2个数据 内部存储的数据 地址值 内存分类 栈: 全局变量/局部变量（特殊的链表数据结构，后进先出） 堆: 对象（树数据结构） ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:2:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-什么是内存"},{"categories":["前端"],"content":"Ⅲ-什么是变量? 可变化的量, 由变量名和变量值组成 每个变量都对应的一块小内存, 变量名用来查找对应的内存, 变量值就是内存中保存的数据 ps:变量obj.xx–\u003e.相当于拿着地址找到后面对应的内存,所以只有当我变量中存的是地址,才可以用. ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:2:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-什么是变量"},{"categories":["前端"],"content":"Ⅳ-内存,数据, 变量三者之间的关系 内存用来存储数据的空间 变量是内存的标识 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:2:4","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-内存数据-变量三者之间的关系"},{"categories":["前端"],"content":"Ⅴ-相关问题引出① 关于赋值和内存的问题 let a = xxx, a内存中到底保存的是什么? xxx是基本数据, 保存的就是这个数据 xxx是对象, 保存的是对象的地址值 xxx是一个变量, 保存的xxx的内存内容(可能是基本数据, 也可能是地址值) ② 关于引用变量赋值问题 2个引用变量指向同一个对象, 通过一个变量修改对象内部数据, 另一个变量看到的是修改之后的数据 2个引用变量指向同一个对象, 让其中一个引用变量指向另一个对象, 另一引用变量依然指向前一个对象 代码示例: let a = {age: 12} //此时是将a指向的地址值赋值给B,所以B此时也指向{age:12}这个内存 let b = a //此时重新创建了一个内存并让a指向它,所以此处a指向的是{name:'hong'},而b指向仍是刚开始的指向{age:12} a = {name: 'hong'} //此时a与b指向的内存已经不一样了,所以修改互不影响 b.age = 14 console.log(b.age, a.name, a.age) // 14 hong undefined //此时其实已经重新创建了一个内存{age:15},并且将其地址赋值覆盖给a //实际上传进来的obj也是拿着其key对应的地址值找内存,此时 const fn2=(obj) =\u003e obj = {age: 15} fn2(a) console.log(a.age) //15 ③ 在js调用函数时传递变量参数时, 是值传递还是引用传递 理解1: 都是值(基本/地址值)传递 所以实际上传进function中的参数也是拿着其存着的地址值找内存 //传进来的obj存储的是a中存的地址值,所以obj==a(因为他们地址值一致,指向一致) let a = {name: 'hong'} const fn2=(obj) =\u003e obj = {age: 15} fn2(a) console.log(a.age) //15 理解2: 可能是值传递, 也可能是引用传递(地址值) ④ JS引擎如何管理内存? 内存生命周期 分配小内存空间, 得到它的使用权 存储数据, 可以反复进行操作 释放小内存空间 释放内存 局部变量: 函数执行完自动释放 对象: 成为垃圾对象==\u003e垃圾回收器回收 var a = 3 var obj = {name:\"hong\"} obj = undefined ||null //此时,obj没有被释放,但是之前声明的`{name:\"hong\"}`由于没有人指向它,会在后面你某个时刻被垃圾回收器回收 function fn () { var b = {}} fn() // b是自动释放, b所指向的对象是在后面的某个时刻由垃圾回收器回收 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:2:5","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-相关问题引出-1"},{"categories":["前端"],"content":"Ⅴ-相关问题引出① 关于赋值和内存的问题 let a = xxx, a内存中到底保存的是什么? xxx是基本数据, 保存的就是这个数据 xxx是对象, 保存的是对象的地址值 xxx是一个变量, 保存的xxx的内存内容(可能是基本数据, 也可能是地址值) ② 关于引用变量赋值问题 2个引用变量指向同一个对象, 通过一个变量修改对象内部数据, 另一个变量看到的是修改之后的数据 2个引用变量指向同一个对象, 让其中一个引用变量指向另一个对象, 另一引用变量依然指向前一个对象 代码示例: let a = {age: 12} //此时是将a指向的地址值赋值给B,所以B此时也指向{age:12}这个内存 let b = a //此时重新创建了一个内存并让a指向它,所以此处a指向的是{name:'hong'},而b指向仍是刚开始的指向{age:12} a = {name: 'hong'} //此时a与b指向的内存已经不一样了,所以修改互不影响 b.age = 14 console.log(b.age, a.name, a.age) // 14 hong undefined //此时其实已经重新创建了一个内存{age:15},并且将其地址赋值覆盖给a //实际上传进来的obj也是拿着其key对应的地址值找内存,此时 const fn2=(obj) = obj = {age: 15} fn2(a) console.log(a.age) //15 ③ 在js调用函数时传递变量参数时, 是值传递还是引用传递 理解1: 都是值(基本/地址值)传递 所以实际上传进function中的参数也是拿着其存着的地址值找内存 //传进来的obj存储的是a中存的地址值,所以obj==a(因为他们地址值一致,指向一致) let a = {name: 'hong'} const fn2=(obj) = obj = {age: 15} fn2(a) console.log(a.age) //15 理解2: 可能是值传递, 也可能是引用传递(地址值) ④ JS引擎如何管理内存? 内存生命周期 分配小内存空间, 得到它的使用权 存储数据, 可以反复进行操作 释放小内存空间 释放内存 局部变量: 函数执行完自动释放 对象: 成为垃圾对象==垃圾回收器回收 var a = 3 var obj = {name:\"hong\"} obj = undefined ||null //此时,obj没有被释放,但是之前声明的`{name:\"hong\"}`由于没有人指向它,会在后面你某个时刻被垃圾回收器回收 function fn () { var b = {}} fn() // b是自动释放, b所指向的对象是在后面的某个时刻由垃圾回收器回收 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:2:5","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-关于赋值和内存的问题"},{"categories":["前端"],"content":"Ⅴ-相关问题引出① 关于赋值和内存的问题 let a = xxx, a内存中到底保存的是什么? xxx是基本数据, 保存的就是这个数据 xxx是对象, 保存的是对象的地址值 xxx是一个变量, 保存的xxx的内存内容(可能是基本数据, 也可能是地址值) ② 关于引用变量赋值问题 2个引用变量指向同一个对象, 通过一个变量修改对象内部数据, 另一个变量看到的是修改之后的数据 2个引用变量指向同一个对象, 让其中一个引用变量指向另一个对象, 另一引用变量依然指向前一个对象 代码示例: let a = {age: 12} //此时是将a指向的地址值赋值给B,所以B此时也指向{age:12}这个内存 let b = a //此时重新创建了一个内存并让a指向它,所以此处a指向的是{name:'hong'},而b指向仍是刚开始的指向{age:12} a = {name: 'hong'} //此时a与b指向的内存已经不一样了,所以修改互不影响 b.age = 14 console.log(b.age, a.name, a.age) // 14 hong undefined //此时其实已经重新创建了一个内存{age:15},并且将其地址赋值覆盖给a //实际上传进来的obj也是拿着其key对应的地址值找内存,此时 const fn2=(obj) = obj = {age: 15} fn2(a) console.log(a.age) //15 ③ 在js调用函数时传递变量参数时, 是值传递还是引用传递 理解1: 都是值(基本/地址值)传递 所以实际上传进function中的参数也是拿着其存着的地址值找内存 //传进来的obj存储的是a中存的地址值,所以obj==a(因为他们地址值一致,指向一致) let a = {name: 'hong'} const fn2=(obj) = obj = {age: 15} fn2(a) console.log(a.age) //15 理解2: 可能是值传递, 也可能是引用传递(地址值) ④ JS引擎如何管理内存? 内存生命周期 分配小内存空间, 得到它的使用权 存储数据, 可以反复进行操作 释放小内存空间 释放内存 局部变量: 函数执行完自动释放 对象: 成为垃圾对象==垃圾回收器回收 var a = 3 var obj = {name:\"hong\"} obj = undefined ||null //此时,obj没有被释放,但是之前声明的`{name:\"hong\"}`由于没有人指向它,会在后面你某个时刻被垃圾回收器回收 function fn () { var b = {}} fn() // b是自动释放, b所指向的对象是在后面的某个时刻由垃圾回收器回收 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:2:5","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-关于引用变量赋值问题"},{"categories":["前端"],"content":"Ⅴ-相关问题引出① 关于赋值和内存的问题 let a = xxx, a内存中到底保存的是什么? xxx是基本数据, 保存的就是这个数据 xxx是对象, 保存的是对象的地址值 xxx是一个变量, 保存的xxx的内存内容(可能是基本数据, 也可能是地址值) ② 关于引用变量赋值问题 2个引用变量指向同一个对象, 通过一个变量修改对象内部数据, 另一个变量看到的是修改之后的数据 2个引用变量指向同一个对象, 让其中一个引用变量指向另一个对象, 另一引用变量依然指向前一个对象 代码示例: let a = {age: 12} //此时是将a指向的地址值赋值给B,所以B此时也指向{age:12}这个内存 let b = a //此时重新创建了一个内存并让a指向它,所以此处a指向的是{name:'hong'},而b指向仍是刚开始的指向{age:12} a = {name: 'hong'} //此时a与b指向的内存已经不一样了,所以修改互不影响 b.age = 14 console.log(b.age, a.name, a.age) // 14 hong undefined //此时其实已经重新创建了一个内存{age:15},并且将其地址赋值覆盖给a //实际上传进来的obj也是拿着其key对应的地址值找内存,此时 const fn2=(obj) = obj = {age: 15} fn2(a) console.log(a.age) //15 ③ 在js调用函数时传递变量参数时, 是值传递还是引用传递 理解1: 都是值(基本/地址值)传递 所以实际上传进function中的参数也是拿着其存着的地址值找内存 //传进来的obj存储的是a中存的地址值,所以obj==a(因为他们地址值一致,指向一致) let a = {name: 'hong'} const fn2=(obj) = obj = {age: 15} fn2(a) console.log(a.age) //15 理解2: 可能是值传递, 也可能是引用传递(地址值) ④ JS引擎如何管理内存? 内存生命周期 分配小内存空间, 得到它的使用权 存储数据, 可以反复进行操作 释放小内存空间 释放内存 局部变量: 函数执行完自动释放 对象: 成为垃圾对象==垃圾回收器回收 var a = 3 var obj = {name:\"hong\"} obj = undefined ||null //此时,obj没有被释放,但是之前声明的`{name:\"hong\"}`由于没有人指向它,会在后面你某个时刻被垃圾回收器回收 function fn () { var b = {}} fn() // b是自动释放, b所指向的对象是在后面的某个时刻由垃圾回收器回收 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:2:5","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-在js调用函数时传递变量参数时-是值传递还是引用传递"},{"categories":["前端"],"content":"Ⅴ-相关问题引出① 关于赋值和内存的问题 let a = xxx, a内存中到底保存的是什么? xxx是基本数据, 保存的就是这个数据 xxx是对象, 保存的是对象的地址值 xxx是一个变量, 保存的xxx的内存内容(可能是基本数据, 也可能是地址值) ② 关于引用变量赋值问题 2个引用变量指向同一个对象, 通过一个变量修改对象内部数据, 另一个变量看到的是修改之后的数据 2个引用变量指向同一个对象, 让其中一个引用变量指向另一个对象, 另一引用变量依然指向前一个对象 代码示例: let a = {age: 12} //此时是将a指向的地址值赋值给B,所以B此时也指向{age:12}这个内存 let b = a //此时重新创建了一个内存并让a指向它,所以此处a指向的是{name:'hong'},而b指向仍是刚开始的指向{age:12} a = {name: 'hong'} //此时a与b指向的内存已经不一样了,所以修改互不影响 b.age = 14 console.log(b.age, a.name, a.age) // 14 hong undefined //此时其实已经重新创建了一个内存{age:15},并且将其地址赋值覆盖给a //实际上传进来的obj也是拿着其key对应的地址值找内存,此时 const fn2=(obj) = obj = {age: 15} fn2(a) console.log(a.age) //15 ③ 在js调用函数时传递变量参数时, 是值传递还是引用传递 理解1: 都是值(基本/地址值)传递 所以实际上传进function中的参数也是拿着其存着的地址值找内存 //传进来的obj存储的是a中存的地址值,所以obj==a(因为他们地址值一致,指向一致) let a = {name: 'hong'} const fn2=(obj) = obj = {age: 15} fn2(a) console.log(a.age) //15 理解2: 可能是值传递, 也可能是引用传递(地址值) ④ JS引擎如何管理内存? 内存生命周期 分配小内存空间, 得到它的使用权 存储数据, 可以反复进行操作 释放小内存空间 释放内存 局部变量: 函数执行完自动释放 对象: 成为垃圾对象==垃圾回收器回收 var a = 3 var obj = {name:\"hong\"} obj = undefined ||null //此时,obj没有被释放,但是之前声明的`{name:\"hong\"}`由于没有人指向它,会在后面你某个时刻被垃圾回收器回收 function fn () { var b = {}} fn() // b是自动释放, b所指向的对象是在后面的某个时刻由垃圾回收器回收 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:2:5","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-js引擎如何管理内存"},{"categories":["前端"],"content":"3、对象","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:3:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#3对象"},{"categories":["前端"],"content":"Ⅰ-对象的概念① 什么是对象? 多个数据的封装体 用来保存多个数据的容器 一个对象代表现实中的一个事物 ② 为什么要用对象? 统一管理多个数据 ③ 对象的组成 属性: 属性名(字符串)和属性值(任意)组成 方法: 一种特别的属性(属性值是函数) ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:3:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-对象的概念"},{"categories":["前端"],"content":"Ⅰ-对象的概念① 什么是对象? 多个数据的封装体 用来保存多个数据的容器 一个对象代表现实中的一个事物 ② 为什么要用对象? 统一管理多个数据 ③ 对象的组成 属性: 属性名(字符串)和属性值(任意)组成 方法: 一种特别的属性(属性值是函数) ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:3:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-什么是对象"},{"categories":["前端"],"content":"Ⅰ-对象的概念① 什么是对象? 多个数据的封装体 用来保存多个数据的容器 一个对象代表现实中的一个事物 ② 为什么要用对象? 统一管理多个数据 ③ 对象的组成 属性: 属性名(字符串)和属性值(任意)组成 方法: 一种特别的属性(属性值是函数) ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:3:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-为什么要用对象"},{"categories":["前端"],"content":"Ⅰ-对象的概念① 什么是对象? 多个数据的封装体 用来保存多个数据的容器 一个对象代表现实中的一个事物 ② 为什么要用对象? 统一管理多个数据 ③ 对象的组成 属性: 属性名(字符串)和属性值(任意)组成 方法: 一种特别的属性(属性值是函数) ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:3:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-对象的组成"},{"categories":["前端"],"content":"Ⅱ-如何访问对象内部数据? .属性名: 编码简单, 有时不能用 ['属性名']: 编码麻烦, 能通用 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:3:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-如何访问对象内部数据"},{"categories":["前端"],"content":"Ⅲ-什么时候必须使用['属性名']的方式? 属性名包含特殊字符: - 空格 属性名不确定 var p = {} //1. 给p对象添加一个属性: content type: text/json // p.content-type = 'text/json' //不能用 p['content-type'] = 'text/json' console.log(p['content-type']) //2. 属性名不确定 var propName = 'myAge' var value = 18 // p.propName = value //不能用 p[propName] = value console.log(p.myAge) ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:3:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-什么时候必须使用属性名的方式"},{"categories":["前端"],"content":"4、函数","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:4:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#4函数"},{"categories":["前端"],"content":"Ⅰ-函数的概念① 什么是函数 实现特定功能的n条语句的封装体 只有函数是可以执行的, 其它类型的数据不能执行 ② 为什么要用函数? 提高代码复用 便于阅读交流 ③ 如何定义函数? 函数声明 表达式 function fn1 () { console.log('fn1()' )//函数声明 const fn2 = ()=\u003e console.log('fn2()') //表达式 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:4:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-函数的概念"},{"categories":["前端"],"content":"Ⅰ-函数的概念① 什么是函数 实现特定功能的n条语句的封装体 只有函数是可以执行的, 其它类型的数据不能执行 ② 为什么要用函数? 提高代码复用 便于阅读交流 ③ 如何定义函数? 函数声明 表达式 function fn1 () { console.log('fn1()' )//函数声明 const fn2 = ()= console.log('fn2()') //表达式 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:4:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-什么是函数"},{"categories":["前端"],"content":"Ⅰ-函数的概念① 什么是函数 实现特定功能的n条语句的封装体 只有函数是可以执行的, 其它类型的数据不能执行 ② 为什么要用函数? 提高代码复用 便于阅读交流 ③ 如何定义函数? 函数声明 表达式 function fn1 () { console.log('fn1()' )//函数声明 const fn2 = ()= console.log('fn2()') //表达式 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:4:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-为什么要用函数"},{"categories":["前端"],"content":"Ⅰ-函数的概念① 什么是函数 实现特定功能的n条语句的封装体 只有函数是可以执行的, 其它类型的数据不能执行 ② 为什么要用函数? 提高代码复用 便于阅读交流 ③ 如何定义函数? 函数声明 表达式 function fn1 () { console.log('fn1()' )//函数声明 const fn2 = ()= console.log('fn2()') //表达式 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:4:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-如何定义函数"},{"categories":["前端"],"content":"Ⅱ-如何调用(执行)函数 test(): 直接调用 obj.test(): 通过对象调用 new test(): new调用 test.call/apply(obj): 临时让test成为obj的方法进行调用 代码示例 var obj = {} //此处不能使用箭头函数,因为箭头函数会改变this指向 function test2 () { this.xxx = 'hongjilin' } // obj.test2() 不能直接, 根本就没有 test2.call(obj) // 可以让一个函数成为指定任意对象的方法进行调用 console.log(obj.xxx) ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:4:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-如何调用执行函数"},{"categories":["前端"],"content":"Ⅲ-回调函数① 什么函数才是回调函数? 你定义的 你没有调 但最终它执行了(在某个时刻或某个条件下) ② 常见的回调函数? dom事件回调函数 ==\u003e发生事件的dom元素 定时器回调函数 ===\u003ewindow ajax请求回调函数(后面讲) 生命周期回调函数(后面讲) // dom事件回调函数 document.getElementById('btn').onclick = function () {alert(this.innerHTML)} // 定时器回调函数 setTimeout(function () { alert('到点了'+this)}, 2000) ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:4:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-回调函数"},{"categories":["前端"],"content":"Ⅲ-回调函数① 什么函数才是回调函数? 你定义的 你没有调 但最终它执行了(在某个时刻或某个条件下) ② 常见的回调函数? dom事件回调函数 ==发生事件的dom元素 定时器回调函数 ===window ajax请求回调函数(后面讲) 生命周期回调函数(后面讲) // dom事件回调函数 document.getElementById('btn').onclick = function () {alert(this.innerHTML)} // 定时器回调函数 setTimeout(function () { alert('到点了'+this)}, 2000) ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:4:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-什么函数才是回调函数"},{"categories":["前端"],"content":"Ⅲ-回调函数① 什么函数才是回调函数? 你定义的 你没有调 但最终它执行了(在某个时刻或某个条件下) ② 常见的回调函数? dom事件回调函数 ==发生事件的dom元素 定时器回调函数 ===window ajax请求回调函数(后面讲) 生命周期回调函数(后面讲) // dom事件回调函数 document.getElementById('btn').onclick = function () {alert(this.innerHTML)} // 定时器回调函数 setTimeout(function () { alert('到点了'+this)}, 2000) ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:4:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-常见的回调函数"},{"categories":["前端"],"content":"Ⅳ-IIFE (自调用函数) 全称: Immediately-Invoked Function Expression 自调用函数 作用: 隐藏实现 不会污染外部(一般指全局)命名空间 用它来编码js模块 代码示例 (function () { //匿名函数自调用 var a = 3 console.log(a + 3) })() console.log(a) // a is not defined //此处前方为何要一个`;`--\u003e因为自调用函数外部有一个()包裹,可能与前方以()结尾的代码被一起认为是函数调用 //不加分号可能会被认为这样 console.log(a)(IIFE) ;(function () {//不会污染外部(全局)命名空间--\u003e举例 let a = 1; function test () { console.log(++a) } //声明一个局部函数test window.$ = function () { return {test: test} }// 向外暴露一个全局函数 })() test () //test is not defined $().test() // 1. $是一个函数 2. $执行后返回的是一个对象 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:4:4","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-iife-自调用函数"},{"categories":["前端"],"content":"Ⅴ-函数中的this① this是什么? 任何函数本质上都是通过某个对象来调用的,如果没有直接指定就是window 所有函数内部都有一个变量this 它的值是调用函数的当前对象 ② 如何确定this的值? test(): window p.test(): p new test(): 新创建的对象 p.call(obj): obj ③ 代码举例详解 function Person(color) { console.log(this) this.color = color; this.getColor = function () { console.log(this) return this.color; }; this.setColor = function (color) { console.log(this) this.color = color; }; } Person(\"red\"); //this是谁? window const p = new Person(\"yello\"); //this是谁? p p.getColor(); //this是谁? p const obj = {}; //调用call会改变this指向--\u003e让我的p函数成为`obj`的临时方法进行调用 p.setColor.call(obj, \"black\"); //this是谁? obj const test = p.setColor; test(); //this是谁? window --\u003e因为直接调用了 function fun1() { function fun2() { console.log(this); } fun2(); //this是谁? window } fun1();//调用fun1 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:4:5","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-函数中的this"},{"categories":["前端"],"content":"Ⅴ-函数中的this① this是什么? 任何函数本质上都是通过某个对象来调用的,如果没有直接指定就是window 所有函数内部都有一个变量this 它的值是调用函数的当前对象 ② 如何确定this的值? test(): window p.test(): p new test(): 新创建的对象 p.call(obj): obj ③ 代码举例详解 function Person(color) { console.log(this) this.color = color; this.getColor = function () { console.log(this) return this.color; }; this.setColor = function (color) { console.log(this) this.color = color; }; } Person(\"red\"); //this是谁? window const p = new Person(\"yello\"); //this是谁? p p.getColor(); //this是谁? p const obj = {}; //调用call会改变this指向--让我的p函数成为`obj`的临时方法进行调用 p.setColor.call(obj, \"black\"); //this是谁? obj const test = p.setColor; test(); //this是谁? window --因为直接调用了 function fun1() { function fun2() { console.log(this); } fun2(); //this是谁? window } fun1();//调用fun1 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:4:5","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-this是什么"},{"categories":["前端"],"content":"Ⅴ-函数中的this① this是什么? 任何函数本质上都是通过某个对象来调用的,如果没有直接指定就是window 所有函数内部都有一个变量this 它的值是调用函数的当前对象 ② 如何确定this的值? test(): window p.test(): p new test(): 新创建的对象 p.call(obj): obj ③ 代码举例详解 function Person(color) { console.log(this) this.color = color; this.getColor = function () { console.log(this) return this.color; }; this.setColor = function (color) { console.log(this) this.color = color; }; } Person(\"red\"); //this是谁? window const p = new Person(\"yello\"); //this是谁? p p.getColor(); //this是谁? p const obj = {}; //调用call会改变this指向--让我的p函数成为`obj`的临时方法进行调用 p.setColor.call(obj, \"black\"); //this是谁? obj const test = p.setColor; test(); //this是谁? window --因为直接调用了 function fun1() { function fun2() { console.log(this); } fun2(); //this是谁? window } fun1();//调用fun1 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:4:5","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-如何确定this的值"},{"categories":["前端"],"content":"Ⅴ-函数中的this① this是什么? 任何函数本质上都是通过某个对象来调用的,如果没有直接指定就是window 所有函数内部都有一个变量this 它的值是调用函数的当前对象 ② 如何确定this的值? test(): window p.test(): p new test(): 新创建的对象 p.call(obj): obj ③ 代码举例详解 function Person(color) { console.log(this) this.color = color; this.getColor = function () { console.log(this) return this.color; }; this.setColor = function (color) { console.log(this) this.color = color; }; } Person(\"red\"); //this是谁? window const p = new Person(\"yello\"); //this是谁? p p.getColor(); //this是谁? p const obj = {}; //调用call会改变this指向--让我的p函数成为`obj`的临时方法进行调用 p.setColor.call(obj, \"black\"); //this是谁? obj const test = p.setColor; test(); //this是谁? window --因为直接调用了 function fun1() { function fun2() { console.log(this); } fun2(); //this是谁? window } fun1();//调用fun1 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:4:5","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-代码举例详解"},{"categories":["前端"],"content":"5、关于语句分号 js一条语句的后面可以不加分号 是否加分号是编码风格问题, 没有应该不应该，只有你自己喜欢不喜欢 在下面2种情况下不加分号会有问题 小括号开头的前一条语句 中方括号开头的前一条语句 解决办法: 在行首加分号 强有力的例子: vue.js库 知乎热议: https://www.zhihu.com/question/20298345 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#5关于语句分号"},{"categories":["前端"],"content":"二、函数高级","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:0:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#二函数高级"},{"categories":["前端"],"content":"1、原型与原型链","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:1:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#1原型与原型链"},{"categories":["前端"],"content":"Ⅰ-原型 [prototype] 函数的prototype属性 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象) 原型对象中有一个属性constructor, 它指向函数对象 给原型对象添加属性(一般都是方法) 作用: 函数的所有实例对象自动拥有原型中的属性(方法) 代码示例 // 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象) console.log(Date.prototype, typeof Date.prototype) function Fun () { } console.log(Fun.prototype) // 默认指向一个Object空对象(没有我们的属性) // 原型对象中有一个属性constructor, 它指向函数对象 console.log(Date.prototype.constructor===Date) console.log(Fun.prototype.constructor===Fun) //给原型对象添加属性(一般是方法) ===\u003e实例对象可以访问 Fun.prototype.test = function () { console.log('test()') } var fun = new Fun() fun.test() ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:1:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-原型-prototype"},{"categories":["前端"],"content":"Ⅱ-显式原型与隐式原型 每个函数function都有一个prototype，即显式原型(属性) 每个实例对象都有一个[__ proto __]，可称为隐式原型(属性) 对象的隐式原型的值为其对应构造函数的显式原型的值 内存结构 总结: 函数的[prototype]属性: 在定义函数时自动添加的, 默认值是一个空Object对象 对象的[__ proto __]属性: 创建对象时自动添加的, 默认值为构造函数的prototype属性值 程序员能直接操作显式原型, 但不能直接操作隐式原型(ES6之前) 代码示例: //定义构造函数 function Fn() { // 内部默认执行语句: this.prototype = {} } // 1. 每个函数function都有一个prototype，即显式原型属性, 默认指向一个空的Object对象 console.log(Fn.prototype) // 2. 每个实例对象都有一个__proto__，可称为隐式原型 //创建实例对象 var fn = new Fn() // 内部默认执行语句: this.__proto__ = Fn.prototype console.log(fn.__proto__) // 3. 对象的隐式原型的值为其对应构造函数的显式原型的值 console.log(Fn.prototype===fn.__proto__) // true //给原型添加方法 Fn.prototype.test = function () { console.log('test()') } //通过实例调用原型的方法 fn.test() ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:1:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-显式原型与隐式原型"},{"categories":["前端"],"content":"Ⅲ-原型链① 原型链 原型链 访问一个对象的属性时， 先在自身属性中查找，找到返回 如果没有, 再沿着[__ proto __]这条链向上查找, 找到返回 如果最终没找到, 返回undefined 别名: 隐式原型链 作用: 查找对象的属性(方法) ②构造函数/原型/实例对象的关系(图解) var o1 = new Object(); var o2 = {}; function Foo(){ } ps:所有函数的[__ proto __]都是一样的 ③ 属性问题 读取对象的属性值时: 会自动到原型链中查找 设置对象的属性值时: 不会查找原型链, 如果当前对象中没有此属性, 直接添加此属性并设置其值 方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上 代码示例 function Fn() { } Fn.prototype.a = 'xxx' var fn1 = new Fn() console.log(fn1.a, fn1) //xxx Fn{} var fn2 = new Fn() fn2.a = 'yyy' console.log(fn1.a, fn2.a, fn2) //xxx yyy Fn{a: \"yyy\"} function Person(name, age) { this.name = name this.age = age } Person.prototype.setName = function (name) { this.name = name } var p1 = new Person('Tom', 12) p1.setName('Bob') console.log(p1) //Person {name: \"Bob\", age: 12} var p2 = new Person('Jack', 12) p2.setName('Cat') console.log(p2) //Person {name: \"Cat\", age: 12} console.log(p1.__proto__===p2.__proto__) // true --\u003e所以方法一般定义在原型中 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:1:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-原型链"},{"categories":["前端"],"content":"Ⅲ-原型链① 原型链 原型链 访问一个对象的属性时， 先在自身属性中查找，找到返回 如果没有, 再沿着[__ proto __]这条链向上查找, 找到返回 如果最终没找到, 返回undefined 别名: 隐式原型链 作用: 查找对象的属性(方法) ②构造函数/原型/实例对象的关系(图解) var o1 = new Object(); var o2 = {}; function Foo(){ } ps:所有函数的[__ proto __]都是一样的 ③ 属性问题 读取对象的属性值时: 会自动到原型链中查找 设置对象的属性值时: 不会查找原型链, 如果当前对象中没有此属性, 直接添加此属性并设置其值 方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上 代码示例 function Fn() { } Fn.prototype.a = 'xxx' var fn1 = new Fn() console.log(fn1.a, fn1) //xxx Fn{} var fn2 = new Fn() fn2.a = 'yyy' console.log(fn1.a, fn2.a, fn2) //xxx yyy Fn{a: \"yyy\"} function Person(name, age) { this.name = name this.age = age } Person.prototype.setName = function (name) { this.name = name } var p1 = new Person('Tom', 12) p1.setName('Bob') console.log(p1) //Person {name: \"Bob\", age: 12} var p2 = new Person('Jack', 12) p2.setName('Cat') console.log(p2) //Person {name: \"Cat\", age: 12} console.log(p1.__proto__===p2.__proto__) // true --所以方法一般定义在原型中 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:1:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-原型链-1"},{"categories":["前端"],"content":"Ⅲ-原型链① 原型链 原型链 访问一个对象的属性时， 先在自身属性中查找，找到返回 如果没有, 再沿着[__ proto __]这条链向上查找, 找到返回 如果最终没找到, 返回undefined 别名: 隐式原型链 作用: 查找对象的属性(方法) ②构造函数/原型/实例对象的关系(图解) var o1 = new Object(); var o2 = {}; function Foo(){ } ps:所有函数的[__ proto __]都是一样的 ③ 属性问题 读取对象的属性值时: 会自动到原型链中查找 设置对象的属性值时: 不会查找原型链, 如果当前对象中没有此属性, 直接添加此属性并设置其值 方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上 代码示例 function Fn() { } Fn.prototype.a = 'xxx' var fn1 = new Fn() console.log(fn1.a, fn1) //xxx Fn{} var fn2 = new Fn() fn2.a = 'yyy' console.log(fn1.a, fn2.a, fn2) //xxx yyy Fn{a: \"yyy\"} function Person(name, age) { this.name = name this.age = age } Person.prototype.setName = function (name) { this.name = name } var p1 = new Person('Tom', 12) p1.setName('Bob') console.log(p1) //Person {name: \"Bob\", age: 12} var p2 = new Person('Jack', 12) p2.setName('Cat') console.log(p2) //Person {name: \"Cat\", age: 12} console.log(p1.__proto__===p2.__proto__) // true --所以方法一般定义在原型中 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:1:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#构造函数原型实例对象的关系图解"},{"categories":["前端"],"content":"Ⅲ-原型链① 原型链 原型链 访问一个对象的属性时， 先在自身属性中查找，找到返回 如果没有, 再沿着[__ proto __]这条链向上查找, 找到返回 如果最终没找到, 返回undefined 别名: 隐式原型链 作用: 查找对象的属性(方法) ②构造函数/原型/实例对象的关系(图解) var o1 = new Object(); var o2 = {}; function Foo(){ } ps:所有函数的[__ proto __]都是一样的 ③ 属性问题 读取对象的属性值时: 会自动到原型链中查找 设置对象的属性值时: 不会查找原型链, 如果当前对象中没有此属性, 直接添加此属性并设置其值 方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上 代码示例 function Fn() { } Fn.prototype.a = 'xxx' var fn1 = new Fn() console.log(fn1.a, fn1) //xxx Fn{} var fn2 = new Fn() fn2.a = 'yyy' console.log(fn1.a, fn2.a, fn2) //xxx yyy Fn{a: \"yyy\"} function Person(name, age) { this.name = name this.age = age } Person.prototype.setName = function (name) { this.name = name } var p1 = new Person('Tom', 12) p1.setName('Bob') console.log(p1) //Person {name: \"Bob\", age: 12} var p2 = new Person('Jack', 12) p2.setName('Cat') console.log(p2) //Person {name: \"Cat\", age: 12} console.log(p1.__proto__===p2.__proto__) // true --所以方法一般定义在原型中 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:1:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-属性问题"},{"categories":["前端"],"content":"Ⅳ-instanceof instanceof是如何判断的? 表达式: A instanceof B 如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false Function是通过new自己产生的实例 /* 案例1 */ function Foo() { } var f1 = new Foo() console.log(f1 instanceof Foo) // true console.log(f1 instanceof Object) // true /* 案例2 */ console.log(Object instanceof Function) // true console.log(Object instanceof Object) // true console.log(Function instanceof Function) // true console.log(Function instanceof Object) // true function Foo() {} console.log(Object instanceof Foo) // false ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:1:4","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-instanceof"},{"categories":["前端"],"content":"Ⅴ-相关面试题 测试题1: /* 测试题1 */ function A () {} A.prototype.n = 1 let b = new A() A.prototype = { n: 2, m: 3} //注意这里直接改写了A.prototype的原型地址。如果是写成A.prototype.n=2则前后的对象都会改变。 let c = new A() console.log(b.n, b.m, c.n, c.m) // 1 undefined 2 3 测试题2:原理看②构造函数/原型/实例对象的关系(图解) /* 测试题2 */ function F (){} Object.prototype.a = function(){ console.log('a()') } Function.prototype.b = function(){ console.log('b()') } let f = new F() f.a() //a() f.b() //f.b is not a function --\u003e找不到 F.a() //a() F.b() //b() console.log(f) console.log(Object.prototype) console.log(Function.prototype) 结果图例 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:1:5","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-相关面试题"},{"categories":["前端"],"content":"2、执行上下文与执行上下文栈 当代码在 JavaScript 中运行时，执行代码的环境非常重要，并将概括为以下几点： 全局代码——第一次执行代码的默认环境。 函数代码——当执行流进入函数体时。 (…) —— 我们当作 执行上下文 是当前代码执行的一个环境与范围。 换句话说，当我们启动程序时，我们从全局执行上下文中开始。一些变量是在全局执行上下文中声明的。我们称之为全局变量。当程序调用一个函数时，会发生什么? 以下几个步骤： JavaScript 创建一个新的执行上下文，我们叫作本地执行上下文。 这个本地执行上下文将有它自己的一组变量，这些变量将是这个执行上下文的本地变量。 新的执行上下文被推到到执行堆栈中。可以将执行堆栈看作是一种保存程序在其执行中的位置的容器。 函数什么时候结束?当它遇到一个 return 语句或一个结束括号}。 当一个函数结束时，会发生以下情况: 这个本地执行上下文从执行堆栈中弹出。 函数将返回值返回调用上下文。调用上下文是调用这个本地的执行上下文，它可以是全局执行上下文，也可以是另外一个本地的执行上下文。这取决于调用执行上下文来处理此时的返回值，返回的值可以是一个对象、一个数组、一个函数、一个布尔值等等，如果函数没有 return 语句，则返回 undefined。 这个本地执行上下文被销毁，销毁是很重要，这个本地执行上下文中声明的所有变量都将被删除，不在有变量，这个就是为什么 称为本地执行上下文中自有的变量。 此图出于CSDN的Free Joe ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:2:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#2执行上下文与执行上下文栈"},{"categories":["前端"],"content":"Ⅰ-变量提升与函数提升 变量声明提升 通过var定义(声明)的变量, 在定义语句之前就可以访问到 值: undefined 函数声明提升 通过function声明的函数, 在之前就可以直接调用 值: 函数定义(对象) 引出一个问题: 变量提升和函数提升是如何产生的? /* 面试题 : 输出 undefined */ var a = 3 function fn () { console.log(a) var a = 4 //变量提升 } fn() //undefined '--------------------------------------------' console.log(b) //undefined 变量提升 fn2() //可调用 函数提升 // fn3() //不能 变量提升 var b = 3 function fn2() { console.log('fn2()') } var fn3 = function () { console.log('fn3()') } ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:2:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-变量提升与函数提升"},{"categories":["前端"],"content":"Ⅱ-执行上下文 代码分类(位置) 全局代码 函数(局部)代码 全局执行上下文 在执行全局代码前将window确定为全局执行上下文 对全局数据进行预处理 var定义的全局变量==\u003eundefined, 添加为window的属性 function声明的全局函数==\u003e赋值(fun), 添加为window的方法 this==\u003e赋值(window) 开始执行全局代码 函数执行上下文 在调用函数, 准备执行函数体之前, 创建对应的函数执行上下文对象(虚拟的, 存在于栈中) 对局部数据进行预处理 形参变量==\u003e赋值(实参)==\u003e添加为执行上下文的属性 arguments==\u003e赋值(实参列表), 添加为执行上下文的属性 –\u003e不懂的同学看这里 var定义的局部变量==\u003eundefined, 添加为执行上下文的属性 function声明的函数 ==\u003e赋值(fun), 添加为执行上下文的方法 this==\u003e赋值(调用函数的对象) 开始执行函数体代码 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:2:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-执行上下文"},{"categories":["前端"],"content":"Ⅲ-执行上下文栈 在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象 在全局执行上下文(window)确定后, 将其添加到栈中(压栈)–\u003e所以栈底百分百是[window] 在函数执行上下文创建后, 将其添加到栈中(压栈) 在当前函数执行完后,将栈顶的对象移除(出栈) 当所有的代码执行完后, 栈中只剩下window 上下文栈数==函数调用数+1 //1. 进入全局执行上下文 var a = 10 var bar = function (x) { var b = 5 foo(x + b) //3. 进入foo执行上下文 } var foo = function (y) { var c = 5 console.log(a + c + y) } bar(10) //2. 进入bar函数执行上下文 此处用一个动态图来展示: 举个栗子: //栗子 \u003c!-- 1. 依次输出什么? gb: undefined fb: 1 fb: 2 fb: 3 fe: 3 fe: 2 fe: 1 ge: 1 2. 整个过程中产生了几个执行上下文? 5 --\u003e \u003cscript type=\"text/javascript\"\u003e console.log('gb: '+ i) var i = 1 foo(1) function foo(i) { if (i == 4) { return } console.log('fb:' + i) foo(i + 1) //递归调用: 在函数内部调用自己 console.log('fe:' + i) //出栈 所以会 3 2 1这样的结果 } console.log('ge: ' + i) \u003c/script\u003e ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:2:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-执行上下文栈"},{"categories":["前端"],"content":"Ⅳ-相关面试题 函数提升优先级高于变量提升,且不会被变量声明覆盖,但是会被变量赋值覆盖 /* 测试题1: 先执行变量提升, 再执行函数提升 */ function a() {} var a console.log(typeof a) // 'function' /* 测试题2: */ if (!(b in window)) { var b = 1 } console.log(b) // undefined /* 测试题3: */ var c = 1 function c(c) { console.log(c) var c = 3 //与此行无关 } c(2) // 报错 c is not a function ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:2:4","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-相关面试题-1"},{"categories":["前端"],"content":"3、作用域与作用域链","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:3:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#3作用域与作用域链"},{"categories":["前端"],"content":"Ⅰ-作用域 理解 就是一块\"地盘\", 一个代码段所在的区域 它是静态的(相对于上下文对象), 在编写代码时就确定了 分类 全局作用域 函数作用域 没有块作用域(ES6有了) –\u003e(java语言也有) 作用 隔离变量，不同作用域下同名变量不会有冲突 /* //没块作用域 if(true) { var c = 3 } console.log(c) */ var a = 10, b = 20 function fn(x) { var a = 100, c = 300; console.log('fn()', a, b, c, x) //100 20 300 10 function bar(x) { var a = 1000, d = 400 console.log('bar()', a, b, c, d, x) } bar(100)//1000 20 300 400 100 bar(200)//1000 20 300 400 200 } fn(10) ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:3:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-作用域"},{"categories":["前端"],"content":"Ⅱ-作用域与执行上下文的区别与联系 区别1: 全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时 全局执行上下文环境是在全局作用域确定之后, js代码马上执行之前创建 函数执行上下文是在调用函数时, 函数体代码执行之前创建 区别2: 作用域是静态的, 只要函数定义好了就一直存在, 且不会再变化 执行上下文是动态的, 调用函数时创建, 函数调用结束时就会自动释放 联系: 执行上下文(对象)是从属于所在的作用域 全局上下文环境==\u003e全局作用域 函数上下文环境==\u003e对应的函数使用域 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:3:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-作用域与执行上下文的区别与联系"},{"categories":["前端"],"content":"Ⅲ-作用域链 理解 多个上下级关系的作用域形成的链, 它的方向是从下向上的(从内到外) 查找变量时就是沿着作用域链来查找的 查找一个变量的查找规则 在当前作用域下的执行上下文中查找对应的属性, 如果有直接返回, 否则进入2 在上一级作用域的执行上下文中查找对应的属性, 如果有直接返回, 否则进入3 再次执行2的相同操作, 直到全局作用域, 如果还找不到就抛出找不到的异常 var a = 1 function fn1() { var b = 2 function fn2() { var c = 3 console.log(c) console.log(b) console.log(a) console.log(d) } fn2() } fn1() ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:3:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-作用域链"},{"categories":["前端"],"content":"Ⅳ-相关面试题① 作用域在函数定义时就已经确定了。而不是在函数调用时 作用域1:作用域在函数定义时就已经确定了。而不是在函数调用时 var x = 10; function fn() { console.log(x); } function show(f) { var x = 20; f(); } show(fn); //输出10 ② 对象变量不能产生局部作用域 var fn = function () { console.log(fn) } fn() var obj = { //对象变量不能产生局部作用域,所以会找到全局去,导致报错 fn2: function () { console.log(fn2) //console.log(this.fn2) } } obj.fn2() ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:3:4","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-相关面试题-2"},{"categories":["前端"],"content":"Ⅳ-相关面试题① 作用域在函数定义时就已经确定了。而不是在函数调用时 作用域1:作用域在函数定义时就已经确定了。而不是在函数调用时 var x = 10; function fn() { console.log(x); } function show(f) { var x = 20; f(); } show(fn); //输出10 ② 对象变量不能产生局部作用域 var fn = function () { console.log(fn) } fn() var obj = { //对象变量不能产生局部作用域,所以会找到全局去,导致报错 fn2: function () { console.log(fn2) //console.log(this.fn2) } } obj.fn2() ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:3:4","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-作用域在函数定义时就已经确定了而不是在函数调用时"},{"categories":["前端"],"content":"Ⅳ-相关面试题① 作用域在函数定义时就已经确定了。而不是在函数调用时 作用域1:作用域在函数定义时就已经确定了。而不是在函数调用时 var x = 10; function fn() { console.log(x); } function show(f) { var x = 20; f(); } show(fn); //输出10 ② 对象变量不能产生局部作用域 var fn = function () { console.log(fn) } fn() var obj = { //对象变量不能产生局部作用域,所以会找到全局去,导致报错 fn2: function () { console.log(fn2) //console.log(this.fn2) } } obj.fn2() ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:3:4","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-对象变量不能产生局部作用域"},{"categories":["前端"],"content":"4、闭包预备知识点梳理 在进入闭包之前,你要确保上面知识点你能掌握.你不确定 ? 噢好吧,那你就跟着我看下这部分梳理(如果懂得直接跳过即可) ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:4:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#4闭包预备知识点梳理"},{"categories":["前端"],"content":"Ⅰ- 举个栗子分析执行上下文 在讨论闭包之前，让我们看下下方的代码(建议先只看代码自己头脑风暴再看笔记中的描述),也算是对上面知识点的梳理回顾： 1: let a = 3 2: function addTwo(x) { 3: let ret = x + 2 4: return ret 5: } 6: let b = addTwo(a) 7: console.log(b) 为了理解 JavaScript 引擎是如何工作的，让我们详细分析一下： 在第 1 行，我们在全局执行上下文中声明了一个新变量 a，并将赋值为 3。 接下来就变得棘手了，第 2 行到第 5 行实际上是在一起的。这里发生了什么? 我们在全局执行上下文中声明了一个名为addTwo的新变量,我们给它分配了什么? –\u003e一个函数定义。 两个括号{}之间的任何内容都被分配给addTwo，函数内部的代码没有被求值，没有被执行，只是存储在一个变量中以备将来使用。 现在我们在第 6 行。 它看起来很简单，但是这里有很多东西需要拆开分析。首先，我们在全局执行上下文中声明一个新变量，并将其标记为[b]，变量一经声明，其值即为 undefined。 接下来，仍然在第 6 行，我们看到一个赋值操作符。我们准备给变量b赋一个新值，接下来我们看到一个函数被调用。当您看到一个变量后面跟着一个圆括号(…)时，这就是调用函数的信号，接着，每个函数都返回一些东西(值、对象或 undefined)，无论从函数返回什么，都将赋值给变量b。 但是首先我们需要调用标记为addTwo的函数。JavaScript 将在其全局执行上下文内存中查找名为addTwo的变量。噢，它找到了一个，它是在[步骤 2(或第 2 - 5 行)中定义]的。变量[addTwo]包含一个函数定义。 注意:变量[a]作为参数传递给函数。 JavaScript 在全局执行上下文内存中搜索变量a，找到它，发现它的值是 3，并将数字 3 作为参数传递给函数，准备好执行函数。 现在执行上下文将切换,创建了一个新的本地执行上下文，我们将其命名为[“addTwo 执行上下文”，执行上下文被推送到调用堆栈上。在 addTwo 执行上下文中，我们要做的第一件事是什么? 你可能会说，“在 addTwo 执行上下文中声明了一个新的变量 ret”，这是不对的。 正确的答案是:我们需要先看函数的参数。在 addTwo 执行上下文中声明一个新的变量[x]，因为值 3 是作为参数传递的，所以变量 x 被赋值为 3。 下一步才是在 addTwo 执行上下文中声明一个新的变量ret。它的值被设置为 undefined(第三行)。 仍然是第 3 行，需要执行一个相加操作。 首先我们需要x的值，JavaScript 会寻找一个变量x，它会首先在addTwo执行上下文中寻找，找到了一个值为 3。第二个操作数是数字 2。两个相加结果为 5 就被分配给变量ret。 第 4 行，我们返回变量ret的内容，在 addTwo 执行上下文中查找，找到值为 5，返回，函数结束。 第 4 - 5 行，函数结束。 addTwo 执行上下文被销毁，变量x和ret被消去了，它们已经不存在了。addTwo 执行上下文从调用堆栈中弹出，返回值返回给调用上下文，在这种情况下，调用上下文是全局执行上下文，因为函数addTwo 是从全局执行上下文调用的。 现在我们继续第 4 步的内容，返回值 5 被分配给变量b，此时实际上程序仍然在第 6 行(盗梦空间既视感🐶) 在第 7 行，b的值 5 被打印到控制台了。 对于一个非常简单的程序，这是一个非常冗长的解释，我们甚至还没有涉及闭包。但肯定会涉及的，不过首先我们得绕一两个弯。 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:4:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#--举个栗子分析执行上下文"},{"categories":["前端"],"content":"Ⅱ-举个栗子分析词法作用域 这里想说明，我们在函数执行上下文中有变量，在全局执行上下文中有变量。JavaScript 的一个复杂之处在于它如何查找变量，如果在函数执行上下文中找不到变量，它将在调用上下文中寻找它，如果在它的调用上下文中没有找到，就一直往上一级，直到它在全局执行上下文中查找为止。(如果最后找不到，它就是 undefined)。 1: let val1 = 2 2: function multiplyThis(n) { 3: let ret = n * val1 4: return ret 5: } 6: let multiplied = multiplyThis(6) 7: console.log('example of scope:', multiplied) 下面列出向个步骤来解释一下（如果你已经熟悉了，请跳过）： 在全局执行上下文中声明一个新的变量val1，并将其赋值为 2。 行 2 - 5，声明一个新的变量 multiplyThis，并给它分配一个函数定义。 第六行，声明一个在全局执行上下文 multiplied 新变量。 从全局执行上下文内存中查找变量multiplyThis，并将其作为函数执行，传递数字 6 作为参数。 新函数调用(创建新执行上下文），创建一个新的 multiplyThis 函数执行上下文。 在 multiplyThis 执行上下文中，声明一个变量 n 并将其赋值为 6 –\u003e声明后才会进入函数体内部执行 执行函数回到第 3 行。 在multiplyThis执行上下文中，声明一个变量ret。 继续第 3 行。对两个操作数 n 和 val1 进行乘法运算.在multiplyThis执行上下文中查找变量 n。 我们在步骤 6 中声明了它,它的内容是数字 6。在multiplyThis执行上下文中查找变量val1。 multiplyThis执行上下文没有一个标记为 val1 的变量。我们向调用上下文查找，调用上下文是全局执行上下文，在全局执行上下文中寻找 [val1]。哦，是的、在那儿，它在步骤 1 中定义，数值是 2。 继续第 3 行。将两个操作数相乘并将其赋值给ret变量，6 * 2 = 12，ret 现在值为 12。 返回ret变量，销毁multiplyThis执行上下文及其变量 ret 和 n 。变量 val1 没有被销毁，因为它是全局执行上下文的一部分。 回到第 6 行。在调用上下文中，数字 12 赋值给 multiplied 的变量。 最后在第 7 行，我们在控制台中打印 multiplied 变量的值 在这个例子中，我们需要记住一个函数可以访问在它的调用上下文中定义的变量，这个就是词法作用域（Lexical scope）。 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:4:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-举个栗子分析词法作用域"},{"categories":["前端"],"content":"Ⅲ- 返回函数的函数[高阶函数] 在第一个例子中，函数addTwo返回一个数字。请记住，函数可以返回任何东西。让我们看一个返回函数的函数示例，因为这对于下方理解闭包非常重要。看栗子： 1: let val = 7 2: function createAdder() { 3: function addNumbers(a, b) { 4: let ret = a + b 5: return ret 6: } 7: return addNumbers 8: } 9: let adder = createAdder() 10: let sum = adder(val, 8) 11: console.log('example of function returning a function: ', sum) 让我们回到分步分解： 第一行。我们在全局执行上下文中声明一个变量val并赋值为 7。 行 2 - 8。我们在全局执行上下文中声明了一个名为 createAdder 的变量，并为其分配了一个函数定义。 内部的第 3 至 7 行描述了上述函数定义，和以前一样，在这一点上，我们没有直接讨论这个函数。我们只是将函数定义存储到[createAdder]变量中。 第 9 行。 我们在全局执行上下文中声明了一个名为 adder 的新变量，暂时，值为 undefined 我们看到括号()，我们需要执行或调用一个函数，查找全局执行上下文的内存并查找名为createAdder 的变量，它是在步骤 2 中创建的。好吧，我们调用它。 调用函数时，执行到第 2 行。 创建一个新的createAdder执行上下文。我们可以在createAdder的执行上下文中创建自有变量。js 引擎将createAdder的上下文添加到调用堆栈。这个函数没有参数，让我们直接跳到它的主体部分. 第 3 - 6 行(执行到主体函数中)。 我们有一个新的函数声明，我们在createAdder执行上下文中创建一个变量 addNumbers。这很重要，addnumber只存在于createAdder执行上下文中。我们将函数定义存储在名为 addNumbers 的自有变量中。 在第 7 行，我们返回变量addNumbers的内容。js 引擎查找一个名为addNumbers的变量并找到它，这是一个函数定义。好的，函数可以返回任何东西，包括函数定义。我们返addNumbers的定义。第 4 行和第 5 行括号之间的内容构成该函数定义。 [return addNumbers]时，createAdder执行上下文将被销毁。addNumbers 变量不再存在。但addNumbers函数定义仍然存在，因为它返回并赋值给了 adder 变量。 此处很重要!!!此时的[adder=createAdder()]实际上它的值是[addNumbers]的函数定义而不是[createAdder]了,adder现在是一个匿名函数–这里有点绕,要确定理解 第 10 行。我们在全局执行上下文中定义了一个新的变量 sum，先赋值为 undefined; 接下来我们需要执行一个函数。哪个函数? 是名为adder变量中定义的函数。我们在全局执行上下文中查找它，果然找到了它，这个函数有两个参数。 让我们查找这两个参数，第一个是我们在步骤 1 中定义的变量val，它表示数字 7，第二个是数字 8。 现在我们要执行这个函数，函数定义概述在第 3-5 行，因为这个函数是匿名，为了方便理解，我们暂且叫它adder吧。这时创建一个adder函数执行上下文，在adder执行上下文中创建了两个新变量 a 和 b。它们分别被赋值为 7 和 8，因为这些是我们在上一步传递给函数的参数。 执行回到第 4 行。 在adder执行上下文中声明了一个名为ret的新变量, 将变量a的内容和变量b的内容相加得 15 并赋给 ret 变量。 ret变量从该函数返回。这个匿名函数执行上下文被销毁，从调用堆栈中删除，变量a、b和ret不再存在。 返回值被分配给我们在步骤 9 中定义的sum变量。 我们将sum的值打印到控制台。 如预期，控制台将打印 15。我们在这里确实经历了很多困难，我想在这里说明几点。首先，函数定义可以存储在变量中，函数定义在程序调用之前是不可见的。其次，每次调用函数时，都会(临时)创建一个本地执行上下文。当函数完成时，执行上下文将消失。函数在遇到 return 或右括号}时执行完成。 高阶函数是什么? 所谓高阶函数，就是一个函数就可以接收另一个函数作为参数，或者是返回一个函数–\u003e常见的高阶函数有map、reduce、filter、sort等 var ADD =function add(a) { return function(b) { return a+b } } 调用：ADD(2)(3)即可获得结果 map // map接受一个函数作为参数，不改变原来的数组，只是返回一个全新的数组 var arr = [1,2,3,4,5] var arr1 = arr.map(item =\u003e item = 2) //arr 输出[1,2,3,4,5] //arr1 输出[2,2,2,2,2] 2. reduce - ```js // reduce也是返回一个全新的数组。reduce接受一个函数作为参数，这个函数要有两个形参，代表数组中的前两项，reduce会将这个函数的结果与数组中的第三项再次组成这个函数的两个形参以此类推进行累积操作 var arr = [1,2,3,4,5] var arr2 = arr.reduce((a,b)=\u003e a+b) console.log(arr2) // 15 filter // filter返回过滤后的数组。filter也接收一个函数作为参数，这个函数将作用于数组中的每个元素，根据该函数每次执行后返回的布尔值来保留结果，如果是true就保留，如果是false就过滤掉（这点与map要区分） var arr = [1,2,3,4,5] var arr3 = arr.filter(item =\u003e item % 2 == 0) console.log(arr3)// [2,4] ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:4:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#--返回函数的函数高阶函数"},{"categories":["前端"],"content":"Ⅲ- 返回函数的函数[高阶函数] 在第一个例子中，函数addTwo返回一个数字。请记住，函数可以返回任何东西。让我们看一个返回函数的函数示例，因为这对于下方理解闭包非常重要。看栗子： 1: let val = 7 2: function createAdder() { 3: function addNumbers(a, b) { 4: let ret = a + b 5: return ret 6: } 7: return addNumbers 8: } 9: let adder = createAdder() 10: let sum = adder(val, 8) 11: console.log('example of function returning a function: ', sum) 让我们回到分步分解： 第一行。我们在全局执行上下文中声明一个变量val并赋值为 7。 行 2 - 8。我们在全局执行上下文中声明了一个名为 createAdder 的变量，并为其分配了一个函数定义。 内部的第 3 至 7 行描述了上述函数定义，和以前一样，在这一点上，我们没有直接讨论这个函数。我们只是将函数定义存储到[createAdder]变量中。 第 9 行。 我们在全局执行上下文中声明了一个名为 adder 的新变量，暂时，值为 undefined 我们看到括号()，我们需要执行或调用一个函数，查找全局执行上下文的内存并查找名为createAdder 的变量，它是在步骤 2 中创建的。好吧，我们调用它。 调用函数时，执行到第 2 行。 创建一个新的createAdder执行上下文。我们可以在createAdder的执行上下文中创建自有变量。js 引擎将createAdder的上下文添加到调用堆栈。这个函数没有参数，让我们直接跳到它的主体部分. 第 3 - 6 行(执行到主体函数中)。 我们有一个新的函数声明，我们在createAdder执行上下文中创建一个变量 addNumbers。这很重要，addnumber只存在于createAdder执行上下文中。我们将函数定义存储在名为 addNumbers 的自有变量中。 在第 7 行，我们返回变量addNumbers的内容。js 引擎查找一个名为addNumbers的变量并找到它，这是一个函数定义。好的，函数可以返回任何东西，包括函数定义。我们返addNumbers的定义。第 4 行和第 5 行括号之间的内容构成该函数定义。 [return addNumbers]时，createAdder执行上下文将被销毁。addNumbers 变量不再存在。但addNumbers函数定义仍然存在，因为它返回并赋值给了 adder 变量。 此处很重要!!!此时的[adder=createAdder()]实际上它的值是[addNumbers]的函数定义而不是[createAdder]了,adder现在是一个匿名函数–这里有点绕,要确定理解 第 10 行。我们在全局执行上下文中定义了一个新的变量 sum，先赋值为 undefined; 接下来我们需要执行一个函数。哪个函数? 是名为adder变量中定义的函数。我们在全局执行上下文中查找它，果然找到了它，这个函数有两个参数。 让我们查找这两个参数，第一个是我们在步骤 1 中定义的变量val，它表示数字 7，第二个是数字 8。 现在我们要执行这个函数，函数定义概述在第 3-5 行，因为这个函数是匿名，为了方便理解，我们暂且叫它adder吧。这时创建一个adder函数执行上下文，在adder执行上下文中创建了两个新变量 a 和 b。它们分别被赋值为 7 和 8，因为这些是我们在上一步传递给函数的参数。 执行回到第 4 行。 在adder执行上下文中声明了一个名为ret的新变量, 将变量a的内容和变量b的内容相加得 15 并赋给 ret 变量。 ret变量从该函数返回。这个匿名函数执行上下文被销毁，从调用堆栈中删除，变量a、b和ret不再存在。 返回值被分配给我们在步骤 9 中定义的sum变量。 我们将sum的值打印到控制台。 如预期，控制台将打印 15。我们在这里确实经历了很多困难，我想在这里说明几点。首先，函数定义可以存储在变量中，函数定义在程序调用之前是不可见的。其次，每次调用函数时，都会(临时)创建一个本地执行上下文。当函数完成时，执行上下文将消失。函数在遇到 return 或右括号}时执行完成。 高阶函数是什么? 所谓高阶函数，就是一个函数就可以接收另一个函数作为参数，或者是返回一个函数–常见的高阶函数有map、reduce、filter、sort等 var ADD =function add(a) { return function(b) { return a+b } } 调用：ADD(2)(3)即可获得结果 map // map接受一个函数作为参数，不改变原来的数组，只是返回一个全新的数组 var arr = [1,2,3,4,5] var arr1 = arr.map(item = item = 2) //arr 输出[1,2,3,4,5] //arr1 输出[2,2,2,2,2] 2. reduce - ```js // reduce也是返回一个全新的数组。reduce接受一个函数作为参数，这个函数要有两个形参，代表数组中的前两项，reduce会将这个函数的结果与数组中的第三项再次组成这个函数的两个形参以此类推进行累积操作 var arr = [1,2,3,4,5] var arr2 = arr.reduce((a,b)= a+b) console.log(arr2) // 15 filter // filter返回过滤后的数组。filter也接收一个函数作为参数，这个函数将作用于数组中的每个元素，根据该函数每次执行后返回的布尔值来保留结果，如果是true就保留，如果是false就过滤掉（这点与map要区分） var arr = [1,2,3,4,5] var arr3 = arr.filter(item = item % 2 == 0) console.log(arr3)// [2,4] ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:4:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#高阶函数是什么"},{"categories":["前端"],"content":"5、闭包 一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。 本来闭包部分是看尚硅谷的教学视频,当时那位老师在此部分讲解的让我觉得并没特别清晰(在刚开始时没讲到重点,导致难以理解,但是在后面有提到就懂了),所以我自己看完后再去翻阅许多关于闭包的资料进行自学,随后将其梳理整合并加以自己感悟记录于此 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#5闭包"},{"categories":["前端"],"content":"Ⅰ-引出闭包概念① 错误场景 需求: 点击某个按钮, 提示\"点击的是第n个按钮\" \u003cbutton\u003e测试1\u003c/button\u003e \u003cbutton\u003e测试2\u003c/button\u003e \u003cbutton\u003e测试3\u003c/button\u003e \u003c!-- 需求: 点击某个按钮, 提示\"点击的是第n个按钮\" --\u003e \u003cscript type=\"text/javascript\"\u003e var btns = document.getElementsByTagName('button') //注意[btns]不是一个数组,它是一个伪数组 //每次获取[btns.length]其实都是需要进行计算的(因为它是伪数组) //所以为了性能更好,在此处赋值,就只需要计算一次 for (var i = 0,length=btns.length; i \u003c length; i++) { var btn = btns[i] btn.onclick = function () { //遍历加监听 alert('第'+(i+1)+'个') //结果 全是[4] } } \u003c/script\u003e 此处错误是,直接修改并使用全局变量[i],导致for循环结束后,所有点击按钮绑定的弹窗值都是[i+1] 随后调用时,都会找到[i]这个变量,但是此时i==3,所以所有结果都是4 ② 将变量挂载到自身来解决 解决方式:将btn所对应的下标保存在btn上 \u003cbutton\u003e测试1\u003c/button\u003e \u003cbutton\u003e测试2\u003c/button\u003e \u003cbutton\u003e测试3\u003c/button\u003e \u003c!-- 需求: 点击某个按钮, 提示\"点击的是第n个按钮\" --\u003e \u003cscript type=\"text/javascript\"\u003e var btns = document.getElementsByTagName('button') for(var i=0,length=btns.length;i\u003clength;i++) { var btn = btns[i] btn.index = i //存到自身 btn.onclick = function () { alert('第'+(this.index+1)+'个') //结果正确 } } \u003c/script\u003e 将其放在自己的身上,需要时自己找自己拿,这样就能解决 ③ 利用闭包 利用闭包知识点解决,引出下方知识点,不懂的可以带着疑问继续往下看 \u003cbody\u003e \u003cbutton\u003e测试1\u003c/button\u003e \u003cbutton\u003e测试2\u003c/button\u003e \u003cbutton\u003e测试3\u003c/button\u003e \u003cscript type=\"text/javascript\"\u003e //利用闭包 for (var i = 0,length=btns.length; i \u003c length; i++) { //此处的j是局部的,它将传入的[i]存入局部的[j]中,这样就能实现效果 (function (j) { var btn = btns[j] btn.onclick = function () { alert('第'+(j+1)+'个') } })(i) } \u003c/script\u003e \u003c/body\u003e ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-引出闭包概念"},{"categories":["前端"],"content":"Ⅰ-引出闭包概念① 错误场景 需求: 点击某个按钮, 提示\"点击的是第n个按钮\" 测试1 测试2 测试3 var btns = document.getElementsByTagName('button') //注意[btns]不是一个数组,它是一个伪数组 //每次获取[btns.length]其实都是需要进行计算的(因为它是伪数组) //所以为了性能更好,在此处赋值,就只需要计算一次 for (var i = 0,length=btns.length; i 此处错误是,直接修改并使用全局变量[i],导致for循环结束后,所有点击按钮绑定的弹窗值都是[i+1] 随后调用时,都会找到[i]这个变量,但是此时i==3,所以所有结果都是4 ② 将变量挂载到自身来解决 解决方式:将btn所对应的下标保存在btn上 测试1 测试2 测试3 var btns = document.getElementsByTagName('button') for(var i=0,length=btns.length;i将其放在自己的身上,需要时自己找自己拿,这样就能解决 ③ 利用闭包 利用闭包知识点解决,引出下方知识点,不懂的可以带着疑问继续往下看 测试1 测试2 测试3 //利用闭包 for (var i = 0,length=btns.length; i ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-错误场景"},{"categories":["前端"],"content":"Ⅰ-引出闭包概念① 错误场景 需求: 点击某个按钮, 提示\"点击的是第n个按钮\" 测试1 测试2 测试3 var btns = document.getElementsByTagName('button') //注意[btns]不是一个数组,它是一个伪数组 //每次获取[btns.length]其实都是需要进行计算的(因为它是伪数组) //所以为了性能更好,在此处赋值,就只需要计算一次 for (var i = 0,length=btns.length; i 此处错误是,直接修改并使用全局变量[i],导致for循环结束后,所有点击按钮绑定的弹窗值都是[i+1] 随后调用时,都会找到[i]这个变量,但是此时i==3,所以所有结果都是4 ② 将变量挂载到自身来解决 解决方式:将btn所对应的下标保存在btn上 测试1 测试2 测试3 var btns = document.getElementsByTagName('button') for(var i=0,length=btns.length;i将其放在自己的身上,需要时自己找自己拿,这样就能解决 ③ 利用闭包 利用闭包知识点解决,引出下方知识点,不懂的可以带着疑问继续往下看 测试1 测试2 测试3 //利用闭包 for (var i = 0,length=btns.length; i ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-将变量挂载到自身来解决"},{"categories":["前端"],"content":"Ⅰ-引出闭包概念① 错误场景 需求: 点击某个按钮, 提示\"点击的是第n个按钮\" 测试1 测试2 测试3 var btns = document.getElementsByTagName('button') //注意[btns]不是一个数组,它是一个伪数组 //每次获取[btns.length]其实都是需要进行计算的(因为它是伪数组) //所以为了性能更好,在此处赋值,就只需要计算一次 for (var i = 0,length=btns.length; i 此处错误是,直接修改并使用全局变量[i],导致for循环结束后,所有点击按钮绑定的弹窗值都是[i+1] 随后调用时,都会找到[i]这个变量,但是此时i==3,所以所有结果都是4 ② 将变量挂载到自身来解决 解决方式:将btn所对应的下标保存在btn上 测试1 测试2 测试3 var btns = document.getElementsByTagName('button') for(var i=0,length=btns.length;i将其放在自己的身上,需要时自己找自己拿,这样就能解决 ③ 利用闭包 利用闭包知识点解决,引出下方知识点,不懂的可以带着疑问继续往下看 测试1 测试2 测试3 //利用闭包 for (var i = 0,length=btns.length; i ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-利用闭包"},{"categories":["前端"],"content":"Ⅱ-举个闭包栗子分析理解 按照上方 [4]代码举例分析流程的方式 来尝试理解闭包概念 提前给出一个闭包栗子进行分析,先看看发生什么,再去看它的概念进行印证,相信我,你会有种拨开迷雾的感受 ① 按照正常逻辑理解 先说,此部分不是按照闭包机制进行理解,所以中途发觉不对(肯定有地方不对劲)请勿钻牛角尖,主要用作后方对照 1: function createCounter() { 2: let counter = 0 3: const myFunction = function() { 4: counter = counter + 1 5: return counter 6: } 7: return myFunction 8: } 9: const increment = createCounter() 10: const c1 = increment() 11: const c2 = increment() 12: const c3 = increment() 13: console.log('example increment', c1, c2, c3) 现在，我们已经从前几个示例中掌握了它的诀窍，让我们按照预期的方式快速执行它： (错误的流程理解,故意按照正常的逻辑流程走,做印证) 行 1 - 8。我们在全局执行上下文中创建了一个新的变量createCounter，并赋值了一个的函数定义。 第 9 行。 我们在全局执行上下文中声明了一个名为increment的新变量。 我们需要调用createCounter函数并将其返回值赋给increment变量。 返回执行 行 1 - 8。调用函数，创建新的本地执行上下文。 第 2 行。在本地执行上下文中，声明一个名为counter的新变量并赋值为 0; 行 3 - 6。声明一个名为myFunction的新变量，变量在本地执行上下文中声明,变量的内容是为第 4 行和第 5 行所定义。 第 7 行。返回myFunction变量的内容，删除本地执行上下文。变量myFunction和counter不再存在。此时控制权回到了调用上下文。 再次回到 第 9 行 在调用上下文(全局执行上下文)中，createCounter返回的值赋给了increment，变量increment现在包含一个函数定义内容为createCounter返回的函数。 它不再标记为myFunction，但它的定义是相同的。在全局上下文中，它是的标记为 labeledincrement。 第 10 行。声明一个新变量(c1)。 继续第 10 行。查找increment变量，它是一个函数并调用它。它包含前面返回的函数定义，如第 4-5 行所定义的。 创建一个新的执行上下文。没有参数。开始执行函数。 回到 第 4 行。 counter=counter + 1。在本地执行上下文中查找counter变量。 我们只是创建了那个上下文，从来没有声明任何局部变量。让我们看看全局执行上下文。这里也没有counter变量。 Javascript 会将其计算为 counter = undefined + 1，声明一个标记为counter的新局部变量，并将其赋值为 number 1，因为 undefined 被当作值为 0。 –\u003e此处是错误的哦,别钻牛角尖,正确的理解在下方,此处是做错误对比 第 5 行。我们变量counter的值(1)，我们销毁本地执行上下文和counter变量。 回到第 10 行。返回值(1)被赋给 c1。 第 11 行。重复步骤 10-14，c2 也被赋值为 1。 第 12 行。重复步骤 10-14，c3 也被赋值为 1。 第 13 行。我们打印变量 c1 c2 和 c3 的内容。 你自己试试，看看会发生什么。你会将注意到，它并不像从我上面的解释中所期望的那样记录 1,1,1。而是记录 1,2,3。这个是为什么? ②正确的理解 不知怎么滴，increment函数记住了那个cunter的值。这是怎么回事? counter是全局执行上下文的一部分吗? 尝试 console.log(counter)，得到undefined的结果,显然不是这样的。 也许，当你调用increment时，它会以某种方式返回它创建的函数(createCounter)? 这怎么可能呢?变量increment包含函数定义，而不是函数的来源，显然也不是这样的。 所以一定有另一种机制。闭包，我们终于找到了，丢失的那块。 **-它是这样工作的，无论何时声明新函数并将其赋值给变量，都要存储函数定义和闭包。闭包包含在函数创建时作用域中的所有变量，它类似于背包。函数定义附带一个小背包，它的包中存储了函数定义创建时作用域中的所有变 ** 所以我们上面的解释都是错的，让我们再试一次，但是这次是正确的 1: function createCounter() { 2: let counter = 0 3: const myFunction = function() { 4: counter = counter + 1 5: return counter 6: } 7: return myFunction 8: } 9: const increment = createCounter() 10: const c1 = increment() 11: const c2 = increment() 12: const c3 = increment() 13: console.log('example increment', c1, c2, c3) 同上，第1-8行。我们在全局执行上下文中创建了一个新的变量createCounter，它得到了指定的函数定义。 同上，第9行。 我们在全局执行上下文中声明了一个名为increment的新变量。 我们需要调用createCounter函数并将其返回值赋给increment变量。 同上，第1-8行。调用函数，创建新的本地执行上下文。 第2行。在本地执行上下文中，声明一个名为counter的新变量并赋值为 0 。 第3-6行。声明一个名为myFunction的新变量，变量在本地执行上下文中声明,变量的内容是另一个函数定义。如第4行和第5行所定义，现在我们还创建了一个闭包，并将其作为函数定义的一部分。闭包包含作用域中的变量，在本例中是变量counter(值为0)。 第7行。返回myFunction变量的内容,删除本地执行上下文。myFunction和counter不再存在。控制权交给了调用上下文，我们返回函数定义和它的闭包，闭包中包含了创建它时在作用域内的变量。 回到第9行。 在调用上下文(全局执行上下文)中，createCounter返回的值被指定为increment 变量increment现在包含一个函数定义(和闭包),由createCounter返回的函数定义,它不再标记为myFunction，但它的定义是相同的,在全局上下文中，称为increment。 第10行。声明一个新变量c1。 继续第10行。查找变量increment，它是一个函数，调用它。它包含前面返回的函数定义,如第4-5行所定义的。(它还有一个带有变量的闭包)。 创建一个新的执行上下文，没有参数，开始执行函数。 第4行。[counter = counter + 1]，寻找变量 [counter]，在查找本地或全局执行上下文之前，让我们检查一下闭包，瞧，闭包包含一个名为[counter]的变量，其值为0。在第4行表达式之后，它的值被设置为1。它再次被储存在闭包里，闭包现在包含值为1的变量 [counter]。 第5行。我们返回counter的值，销毁本地执行上下文。 回到第10行。返回值1被赋给变量c1。 第11行。我们重复步骤10-14。这一次，在闭包中此时变量counter的值是1。它在第12行设置的，它的值被递增并以2的形式存储在递增函数的闭包中,c2被赋值为2。 第12行。重复步骤10-14行,c3被赋值为3。 第13行。我们打印变量c1 c2和c3的值。 ** 你此时可能会问，是否有任何函数具有闭包，甚至是在全局范围内创建的函数? ** 答案是肯定的。在全局作用域中创建的函数创建闭包，但是由于这些函数是在全局作用域中创建的，所以它们可以访问全局作用域中的所有变量，闭包的概念并不重要。 但当函数返回函数时，闭包的概念就变得更加重要了。返回的函数可以访问不属于全局作用域的变量，但它们仅存在于其闭包中。 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-举个闭包栗子分析理解"},{"categories":["前端"],"content":"Ⅱ-举个闭包栗子分析理解 按照上方 [4]代码举例分析流程的方式 来尝试理解闭包概念 提前给出一个闭包栗子进行分析,先看看发生什么,再去看它的概念进行印证,相信我,你会有种拨开迷雾的感受 ① 按照正常逻辑理解 先说,此部分不是按照闭包机制进行理解,所以中途发觉不对(肯定有地方不对劲)请勿钻牛角尖,主要用作后方对照 1: function createCounter() { 2: let counter = 0 3: const myFunction = function() { 4: counter = counter + 1 5: return counter 6: } 7: return myFunction 8: } 9: const increment = createCounter() 10: const c1 = increment() 11: const c2 = increment() 12: const c3 = increment() 13: console.log('example increment', c1, c2, c3) 现在，我们已经从前几个示例中掌握了它的诀窍，让我们按照预期的方式快速执行它： (错误的流程理解,故意按照正常的逻辑流程走,做印证) 行 1 - 8。我们在全局执行上下文中创建了一个新的变量createCounter，并赋值了一个的函数定义。 第 9 行。 我们在全局执行上下文中声明了一个名为increment的新变量。 我们需要调用createCounter函数并将其返回值赋给increment变量。 返回执行 行 1 - 8。调用函数，创建新的本地执行上下文。 第 2 行。在本地执行上下文中，声明一个名为counter的新变量并赋值为 0; 行 3 - 6。声明一个名为myFunction的新变量，变量在本地执行上下文中声明,变量的内容是为第 4 行和第 5 行所定义。 第 7 行。返回myFunction变量的内容，删除本地执行上下文。变量myFunction和counter不再存在。此时控制权回到了调用上下文。 再次回到 第 9 行 在调用上下文(全局执行上下文)中，createCounter返回的值赋给了increment，变量increment现在包含一个函数定义内容为createCounter返回的函数。 它不再标记为myFunction，但它的定义是相同的。在全局上下文中，它是的标记为 labeledincrement。 第 10 行。声明一个新变量(c1)。 继续第 10 行。查找increment变量，它是一个函数并调用它。它包含前面返回的函数定义，如第 4-5 行所定义的。 创建一个新的执行上下文。没有参数。开始执行函数。 回到 第 4 行。 counter=counter + 1。在本地执行上下文中查找counter变量。 我们只是创建了那个上下文，从来没有声明任何局部变量。让我们看看全局执行上下文。这里也没有counter变量。 Javascript 会将其计算为 counter = undefined + 1，声明一个标记为counter的新局部变量，并将其赋值为 number 1，因为 undefined 被当作值为 0。 –此处是错误的哦,别钻牛角尖,正确的理解在下方,此处是做错误对比 第 5 行。我们变量counter的值(1)，我们销毁本地执行上下文和counter变量。 回到第 10 行。返回值(1)被赋给 c1。 第 11 行。重复步骤 10-14，c2 也被赋值为 1。 第 12 行。重复步骤 10-14，c3 也被赋值为 1。 第 13 行。我们打印变量 c1 c2 和 c3 的内容。 你自己试试，看看会发生什么。你会将注意到，它并不像从我上面的解释中所期望的那样记录 1,1,1。而是记录 1,2,3。这个是为什么? ②正确的理解 不知怎么滴，increment函数记住了那个cunter的值。这是怎么回事? counter是全局执行上下文的一部分吗? 尝试 console.log(counter)，得到undefined的结果,显然不是这样的。 也许，当你调用increment时，它会以某种方式返回它创建的函数(createCounter)? 这怎么可能呢?变量increment包含函数定义，而不是函数的来源，显然也不是这样的。 所以一定有另一种机制。闭包，我们终于找到了，丢失的那块。 **-它是这样工作的，无论何时声明新函数并将其赋值给变量，都要存储函数定义和闭包。闭包包含在函数创建时作用域中的所有变量，它类似于背包。函数定义附带一个小背包，它的包中存储了函数定义创建时作用域中的所有变 ** 所以我们上面的解释都是错的，让我们再试一次，但是这次是正确的 1: function createCounter() { 2: let counter = 0 3: const myFunction = function() { 4: counter = counter + 1 5: return counter 6: } 7: return myFunction 8: } 9: const increment = createCounter() 10: const c1 = increment() 11: const c2 = increment() 12: const c3 = increment() 13: console.log('example increment', c1, c2, c3) 同上，第1-8行。我们在全局执行上下文中创建了一个新的变量createCounter，它得到了指定的函数定义。 同上，第9行。 我们在全局执行上下文中声明了一个名为increment的新变量。 我们需要调用createCounter函数并将其返回值赋给increment变量。 同上，第1-8行。调用函数，创建新的本地执行上下文。 第2行。在本地执行上下文中，声明一个名为counter的新变量并赋值为 0 。 第3-6行。声明一个名为myFunction的新变量，变量在本地执行上下文中声明,变量的内容是另一个函数定义。如第4行和第5行所定义，现在我们还创建了一个闭包，并将其作为函数定义的一部分。闭包包含作用域中的变量，在本例中是变量counter(值为0)。 第7行。返回myFunction变量的内容,删除本地执行上下文。myFunction和counter不再存在。控制权交给了调用上下文，我们返回函数定义和它的闭包，闭包中包含了创建它时在作用域内的变量。 回到第9行。 在调用上下文(全局执行上下文)中，createCounter返回的值被指定为increment 变量increment现在包含一个函数定义(和闭包),由createCounter返回的函数定义,它不再标记为myFunction，但它的定义是相同的,在全局上下文中，称为increment。 第10行。声明一个新变量c1。 继续第10行。查找变量increment，它是一个函数，调用它。它包含前面返回的函数定义,如第4-5行所定义的。(它还有一个带有变量的闭包)。 创建一个新的执行上下文，没有参数，开始执行函数。 第4行。[counter = counter + 1]，寻找变量 [counter]，在查找本地或全局执行上下文之前，让我们检查一下闭包，瞧，闭包包含一个名为[counter]的变量，其值为0。在第4行表达式之后，它的值被设置为1。它再次被储存在闭包里，闭包现在包含值为1的变量 [counter]。 第5行。我们返回counter的值，销毁本地执行上下文。 回到第10行。返回值1被赋给变量c1。 第11行。我们重复步骤10-14。这一次，在闭包中此时变量counter的值是1。它在第12行设置的，它的值被递增并以2的形式存储在递增函数的闭包中,c2被赋值为2。 第12行。重复步骤10-14行,c3被赋值为3。 第13行。我们打印变量c1 c2和c3的值。 ** 你此时可能会问，是否有任何函数具有闭包，甚至是在全局范围内创建的函数? ** 答案是肯定的。在全局作用域中创建的函数创建闭包，但是由于这些函数是在全局作用域中创建的，所以它们可以访问全局作用域中的所有变量，闭包的概念并不重要。 但当函数返回函数时，闭包的概念就变得更加重要了。返回的函数可以访问不属于全局作用域的变量，但它们仅存在于其闭包中。 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-按照正常逻辑理解"},{"categories":["前端"],"content":"Ⅱ-举个闭包栗子分析理解 按照上方 [4]代码举例分析流程的方式 来尝试理解闭包概念 提前给出一个闭包栗子进行分析,先看看发生什么,再去看它的概念进行印证,相信我,你会有种拨开迷雾的感受 ① 按照正常逻辑理解 先说,此部分不是按照闭包机制进行理解,所以中途发觉不对(肯定有地方不对劲)请勿钻牛角尖,主要用作后方对照 1: function createCounter() { 2: let counter = 0 3: const myFunction = function() { 4: counter = counter + 1 5: return counter 6: } 7: return myFunction 8: } 9: const increment = createCounter() 10: const c1 = increment() 11: const c2 = increment() 12: const c3 = increment() 13: console.log('example increment', c1, c2, c3) 现在，我们已经从前几个示例中掌握了它的诀窍，让我们按照预期的方式快速执行它： (错误的流程理解,故意按照正常的逻辑流程走,做印证) 行 1 - 8。我们在全局执行上下文中创建了一个新的变量createCounter，并赋值了一个的函数定义。 第 9 行。 我们在全局执行上下文中声明了一个名为increment的新变量。 我们需要调用createCounter函数并将其返回值赋给increment变量。 返回执行 行 1 - 8。调用函数，创建新的本地执行上下文。 第 2 行。在本地执行上下文中，声明一个名为counter的新变量并赋值为 0; 行 3 - 6。声明一个名为myFunction的新变量，变量在本地执行上下文中声明,变量的内容是为第 4 行和第 5 行所定义。 第 7 行。返回myFunction变量的内容，删除本地执行上下文。变量myFunction和counter不再存在。此时控制权回到了调用上下文。 再次回到 第 9 行 在调用上下文(全局执行上下文)中，createCounter返回的值赋给了increment，变量increment现在包含一个函数定义内容为createCounter返回的函数。 它不再标记为myFunction，但它的定义是相同的。在全局上下文中，它是的标记为 labeledincrement。 第 10 行。声明一个新变量(c1)。 继续第 10 行。查找increment变量，它是一个函数并调用它。它包含前面返回的函数定义，如第 4-5 行所定义的。 创建一个新的执行上下文。没有参数。开始执行函数。 回到 第 4 行。 counter=counter + 1。在本地执行上下文中查找counter变量。 我们只是创建了那个上下文，从来没有声明任何局部变量。让我们看看全局执行上下文。这里也没有counter变量。 Javascript 会将其计算为 counter = undefined + 1，声明一个标记为counter的新局部变量，并将其赋值为 number 1，因为 undefined 被当作值为 0。 –此处是错误的哦,别钻牛角尖,正确的理解在下方,此处是做错误对比 第 5 行。我们变量counter的值(1)，我们销毁本地执行上下文和counter变量。 回到第 10 行。返回值(1)被赋给 c1。 第 11 行。重复步骤 10-14，c2 也被赋值为 1。 第 12 行。重复步骤 10-14，c3 也被赋值为 1。 第 13 行。我们打印变量 c1 c2 和 c3 的内容。 你自己试试，看看会发生什么。你会将注意到，它并不像从我上面的解释中所期望的那样记录 1,1,1。而是记录 1,2,3。这个是为什么? ②正确的理解 不知怎么滴，increment函数记住了那个cunter的值。这是怎么回事? counter是全局执行上下文的一部分吗? 尝试 console.log(counter)，得到undefined的结果,显然不是这样的。 也许，当你调用increment时，它会以某种方式返回它创建的函数(createCounter)? 这怎么可能呢?变量increment包含函数定义，而不是函数的来源，显然也不是这样的。 所以一定有另一种机制。闭包，我们终于找到了，丢失的那块。 **-它是这样工作的，无论何时声明新函数并将其赋值给变量，都要存储函数定义和闭包。闭包包含在函数创建时作用域中的所有变量，它类似于背包。函数定义附带一个小背包，它的包中存储了函数定义创建时作用域中的所有变 ** 所以我们上面的解释都是错的，让我们再试一次，但是这次是正确的 1: function createCounter() { 2: let counter = 0 3: const myFunction = function() { 4: counter = counter + 1 5: return counter 6: } 7: return myFunction 8: } 9: const increment = createCounter() 10: const c1 = increment() 11: const c2 = increment() 12: const c3 = increment() 13: console.log('example increment', c1, c2, c3) 同上，第1-8行。我们在全局执行上下文中创建了一个新的变量createCounter，它得到了指定的函数定义。 同上，第9行。 我们在全局执行上下文中声明了一个名为increment的新变量。 我们需要调用createCounter函数并将其返回值赋给increment变量。 同上，第1-8行。调用函数，创建新的本地执行上下文。 第2行。在本地执行上下文中，声明一个名为counter的新变量并赋值为 0 。 第3-6行。声明一个名为myFunction的新变量，变量在本地执行上下文中声明,变量的内容是另一个函数定义。如第4行和第5行所定义，现在我们还创建了一个闭包，并将其作为函数定义的一部分。闭包包含作用域中的变量，在本例中是变量counter(值为0)。 第7行。返回myFunction变量的内容,删除本地执行上下文。myFunction和counter不再存在。控制权交给了调用上下文，我们返回函数定义和它的闭包，闭包中包含了创建它时在作用域内的变量。 回到第9行。 在调用上下文(全局执行上下文)中，createCounter返回的值被指定为increment 变量increment现在包含一个函数定义(和闭包),由createCounter返回的函数定义,它不再标记为myFunction，但它的定义是相同的,在全局上下文中，称为increment。 第10行。声明一个新变量c1。 继续第10行。查找变量increment，它是一个函数，调用它。它包含前面返回的函数定义,如第4-5行所定义的。(它还有一个带有变量的闭包)。 创建一个新的执行上下文，没有参数，开始执行函数。 第4行。[counter = counter + 1]，寻找变量 [counter]，在查找本地或全局执行上下文之前，让我们检查一下闭包，瞧，闭包包含一个名为[counter]的变量，其值为0。在第4行表达式之后，它的值被设置为1。它再次被储存在闭包里，闭包现在包含值为1的变量 [counter]。 第5行。我们返回counter的值，销毁本地执行上下文。 回到第10行。返回值1被赋给变量c1。 第11行。我们重复步骤10-14。这一次，在闭包中此时变量counter的值是1。它在第12行设置的，它的值被递增并以2的形式存储在递增函数的闭包中,c2被赋值为2。 第12行。重复步骤10-14行,c3被赋值为3。 第13行。我们打印变量c1 c2和c3的值。 ** 你此时可能会问，是否有任何函数具有闭包，甚至是在全局范围内创建的函数? ** 答案是肯定的。在全局作用域中创建的函数创建闭包，但是由于这些函数是在全局作用域中创建的，所以它们可以访问全局作用域中的所有变量，闭包的概念并不重要。 但当函数返回函数时，闭包的概念就变得更加重要了。返回的函数可以访问不属于全局作用域的变量，但它们仅存在于其闭包中。 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#正确的理解"},{"categories":["前端"],"content":"Ⅲ-常见的闭包① 将函数作为另一个函数的返回值 // 1. 将函数作为另一个函数的返回值 function fn1() { var a = 2 function fn2() { a++ console.log(a) } return fn2 } var f = fn1() f() // 3 f() // 4 ② 将函数作为实参传递给另一个函数调用 // 2. 将函数作为实参传递给另一个函数调用 function showDelay(msg, time) { setTimeout(function () { alert(msg) }, time) } showDelay('atguigu', 2000) ③ 高阶函数与柯里化 有时候闭包在你甚至没有注意到它的时候就会出现，你可能已经看到了我们称为部分应用程序的示例 当然如果你还不理解的话可以,可以完整的多看几次本笔记闭包知识点部分,或者结合上方Ⅱ-举个闭包栗子分析理解 进行理解 1、从 ES6 高阶箭头函数理解函数柯里化(运用到闭包) 首先看到了这样的一个例子： let add = a =\u003e b =\u003e a + b 以上是一个很简单的相加函数，把它转化成 ES5 的写法如下 function add(a) { return function(b) { return a + b } } var add3 = add(3) //add3表示一个指向函数的变量 可以当成函数调用名来用 add3(4) === 3 + 4 //true 再简化一下，可以写成如下形式： let add = function(a) { var param = a; var innerFun = function(b) { return param + b; } return innerFun; } 虽然好像没什么意义，但是很显然上述使用了[闭包]，而且该函数的返回值是一个函数。其实，这就是高阶函数的定义：以函数为参数或者返回值是函数的函数。 2、柯里化 图例: 关键就是理解柯里化，其实可以把它理解成，柯里化后，将第一个参数变量存在函数里面了(闭包)，然后本来需要n个参数的函数可以变成只需要剩下的（n - 1个）参数就可以调用，比如 let add = x =\u003e y =\u003e x + y let add2 = add(2) -*---------------------------------- 本来完成 add 这个操作，应该是这样调用 let add = (x, y) =\u003e x + y add(2,3) ---------------------------------- 1. 而现在 add2 函数完成同样操作只需要一个参数，这在函数式编程中广泛应用。 let add = x =\u003e y =\u003e x + y let add2 = add(2) 2.详细解释一下，就是 add2 函数 等价于 有了 x 这个闭包变量的 y =\u003e x + y 函数,并且此时 x = 2，所以此时调用 add2(3) === 2 + 3 4、总结 如果是a =\u003e b =\u003e c =\u003e {xxx}这种多次柯里化的,如何理解? 理解:前n - 1次调用，其实是提前将参数传递进去，并没有调用最内层函数体，最后一次调用才会调用最内层函数体，并返回最内层函数体的返回值 结合上文可知，这里的多个连续箭头（无论俩个箭头函数三个及以上）函数连在一起 就是在柯里化。所以连续箭头函数就是多次柯里化函数的 es6 写法。 调用特点:let test = a =\u003e b =\u003e c =\u003e {xxx} 比如对于上面的 test 函数，它有 3 个箭头， 这个函数要被调用 3 次 test(a)(b)(c)，前两次调用只是在传递参数，只有最后依次调用才会返回 {xxx} 代码段的返回值，并且在 {xxx} 代码段中可以调用 a,b,c ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-常见的闭包"},{"categories":["前端"],"content":"Ⅲ-常见的闭包① 将函数作为另一个函数的返回值 // 1. 将函数作为另一个函数的返回值 function fn1() { var a = 2 function fn2() { a++ console.log(a) } return fn2 } var f = fn1() f() // 3 f() // 4 ② 将函数作为实参传递给另一个函数调用 // 2. 将函数作为实参传递给另一个函数调用 function showDelay(msg, time) { setTimeout(function () { alert(msg) }, time) } showDelay('atguigu', 2000) ③ 高阶函数与柯里化 有时候闭包在你甚至没有注意到它的时候就会出现，你可能已经看到了我们称为部分应用程序的示例 当然如果你还不理解的话可以,可以完整的多看几次本笔记闭包知识点部分,或者结合上方Ⅱ-举个闭包栗子分析理解 进行理解 1、从 ES6 高阶箭头函数理解函数柯里化(运用到闭包) 首先看到了这样的一个例子： let add = a = b = a + b 以上是一个很简单的相加函数，把它转化成 ES5 的写法如下 function add(a) { return function(b) { return a + b } } var add3 = add(3) //add3表示一个指向函数的变量 可以当成函数调用名来用 add3(4) === 3 + 4 //true 再简化一下，可以写成如下形式： let add = function(a) { var param = a; var innerFun = function(b) { return param + b; } return innerFun; } 虽然好像没什么意义，但是很显然上述使用了[闭包]，而且该函数的返回值是一个函数。其实，这就是高阶函数的定义：以函数为参数或者返回值是函数的函数。 2、柯里化 图例: 关键就是理解柯里化，其实可以把它理解成，柯里化后，将第一个参数变量存在函数里面了(闭包)，然后本来需要n个参数的函数可以变成只需要剩下的（n - 1个）参数就可以调用，比如 let add = x = y = x + y let add2 = add(2) -*---------------------------------- 本来完成 add 这个操作，应该是这样调用 let add = (x, y) = x + y add(2,3) ---------------------------------- 1. 而现在 add2 函数完成同样操作只需要一个参数，这在函数式编程中广泛应用。 let add = x = y = x + y let add2 = add(2) 2.详细解释一下，就是 add2 函数 等价于 有了 x 这个闭包变量的 y = x + y 函数,并且此时 x = 2，所以此时调用 add2(3) === 2 + 3 4、总结 如果是a = b = c = {xxx}这种多次柯里化的,如何理解? 理解:前n - 1次调用，其实是提前将参数传递进去，并没有调用最内层函数体，最后一次调用才会调用最内层函数体，并返回最内层函数体的返回值 结合上文可知，这里的多个连续箭头（无论俩个箭头函数三个及以上）函数连在一起 就是在柯里化。所以连续箭头函数就是多次柯里化函数的 es6 写法。 调用特点:let test = a = b = c = {xxx} 比如对于上面的 test 函数，它有 3 个箭头， 这个函数要被调用 3 次 test(a)(b)(c)，前两次调用只是在传递参数，只有最后依次调用才会返回 {xxx} 代码段的返回值，并且在 {xxx} 代码段中可以调用 a,b,c ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-将函数作为另一个函数的返回值"},{"categories":["前端"],"content":"Ⅲ-常见的闭包① 将函数作为另一个函数的返回值 // 1. 将函数作为另一个函数的返回值 function fn1() { var a = 2 function fn2() { a++ console.log(a) } return fn2 } var f = fn1() f() // 3 f() // 4 ② 将函数作为实参传递给另一个函数调用 // 2. 将函数作为实参传递给另一个函数调用 function showDelay(msg, time) { setTimeout(function () { alert(msg) }, time) } showDelay('atguigu', 2000) ③ 高阶函数与柯里化 有时候闭包在你甚至没有注意到它的时候就会出现，你可能已经看到了我们称为部分应用程序的示例 当然如果你还不理解的话可以,可以完整的多看几次本笔记闭包知识点部分,或者结合上方Ⅱ-举个闭包栗子分析理解 进行理解 1、从 ES6 高阶箭头函数理解函数柯里化(运用到闭包) 首先看到了这样的一个例子： let add = a = b = a + b 以上是一个很简单的相加函数，把它转化成 ES5 的写法如下 function add(a) { return function(b) { return a + b } } var add3 = add(3) //add3表示一个指向函数的变量 可以当成函数调用名来用 add3(4) === 3 + 4 //true 再简化一下，可以写成如下形式： let add = function(a) { var param = a; var innerFun = function(b) { return param + b; } return innerFun; } 虽然好像没什么意义，但是很显然上述使用了[闭包]，而且该函数的返回值是一个函数。其实，这就是高阶函数的定义：以函数为参数或者返回值是函数的函数。 2、柯里化 图例: 关键就是理解柯里化，其实可以把它理解成，柯里化后，将第一个参数变量存在函数里面了(闭包)，然后本来需要n个参数的函数可以变成只需要剩下的（n - 1个）参数就可以调用，比如 let add = x = y = x + y let add2 = add(2) -*---------------------------------- 本来完成 add 这个操作，应该是这样调用 let add = (x, y) = x + y add(2,3) ---------------------------------- 1. 而现在 add2 函数完成同样操作只需要一个参数，这在函数式编程中广泛应用。 let add = x = y = x + y let add2 = add(2) 2.详细解释一下，就是 add2 函数 等价于 有了 x 这个闭包变量的 y = x + y 函数,并且此时 x = 2，所以此时调用 add2(3) === 2 + 3 4、总结 如果是a = b = c = {xxx}这种多次柯里化的,如何理解? 理解:前n - 1次调用，其实是提前将参数传递进去，并没有调用最内层函数体，最后一次调用才会调用最内层函数体，并返回最内层函数体的返回值 结合上文可知，这里的多个连续箭头（无论俩个箭头函数三个及以上）函数连在一起 就是在柯里化。所以连续箭头函数就是多次柯里化函数的 es6 写法。 调用特点:let test = a = b = c = {xxx} 比如对于上面的 test 函数，它有 3 个箭头， 这个函数要被调用 3 次 test(a)(b)(c)，前两次调用只是在传递参数，只有最后依次调用才会返回 {xxx} 代码段的返回值，并且在 {xxx} 代码段中可以调用 a,b,c ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-将函数作为实参传递给另一个函数调用"},{"categories":["前端"],"content":"Ⅲ-常见的闭包① 将函数作为另一个函数的返回值 // 1. 将函数作为另一个函数的返回值 function fn1() { var a = 2 function fn2() { a++ console.log(a) } return fn2 } var f = fn1() f() // 3 f() // 4 ② 将函数作为实参传递给另一个函数调用 // 2. 将函数作为实参传递给另一个函数调用 function showDelay(msg, time) { setTimeout(function () { alert(msg) }, time) } showDelay('atguigu', 2000) ③ 高阶函数与柯里化 有时候闭包在你甚至没有注意到它的时候就会出现，你可能已经看到了我们称为部分应用程序的示例 当然如果你还不理解的话可以,可以完整的多看几次本笔记闭包知识点部分,或者结合上方Ⅱ-举个闭包栗子分析理解 进行理解 1、从 ES6 高阶箭头函数理解函数柯里化(运用到闭包) 首先看到了这样的一个例子： let add = a = b = a + b 以上是一个很简单的相加函数，把它转化成 ES5 的写法如下 function add(a) { return function(b) { return a + b } } var add3 = add(3) //add3表示一个指向函数的变量 可以当成函数调用名来用 add3(4) === 3 + 4 //true 再简化一下，可以写成如下形式： let add = function(a) { var param = a; var innerFun = function(b) { return param + b; } return innerFun; } 虽然好像没什么意义，但是很显然上述使用了[闭包]，而且该函数的返回值是一个函数。其实，这就是高阶函数的定义：以函数为参数或者返回值是函数的函数。 2、柯里化 图例: 关键就是理解柯里化，其实可以把它理解成，柯里化后，将第一个参数变量存在函数里面了(闭包)，然后本来需要n个参数的函数可以变成只需要剩下的（n - 1个）参数就可以调用，比如 let add = x = y = x + y let add2 = add(2) -*---------------------------------- 本来完成 add 这个操作，应该是这样调用 let add = (x, y) = x + y add(2,3) ---------------------------------- 1. 而现在 add2 函数完成同样操作只需要一个参数，这在函数式编程中广泛应用。 let add = x = y = x + y let add2 = add(2) 2.详细解释一下，就是 add2 函数 等价于 有了 x 这个闭包变量的 y = x + y 函数,并且此时 x = 2，所以此时调用 add2(3) === 2 + 3 4、总结 如果是a = b = c = {xxx}这种多次柯里化的,如何理解? 理解:前n - 1次调用，其实是提前将参数传递进去，并没有调用最内层函数体，最后一次调用才会调用最内层函数体，并返回最内层函数体的返回值 结合上文可知，这里的多个连续箭头（无论俩个箭头函数三个及以上）函数连在一起 就是在柯里化。所以连续箭头函数就是多次柯里化函数的 es6 写法。 调用特点:let test = a = b = c = {xxx} 比如对于上面的 test 函数，它有 3 个箭头， 这个函数要被调用 3 次 test(a)(b)(c)，前两次调用只是在传递参数，只有最后依次调用才会返回 {xxx} 代码段的返回值，并且在 {xxx} 代码段中可以调用 a,b,c ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-高阶函数与柯里化"},{"categories":["前端"],"content":"Ⅲ-常见的闭包① 将函数作为另一个函数的返回值 // 1. 将函数作为另一个函数的返回值 function fn1() { var a = 2 function fn2() { a++ console.log(a) } return fn2 } var f = fn1() f() // 3 f() // 4 ② 将函数作为实参传递给另一个函数调用 // 2. 将函数作为实参传递给另一个函数调用 function showDelay(msg, time) { setTimeout(function () { alert(msg) }, time) } showDelay('atguigu', 2000) ③ 高阶函数与柯里化 有时候闭包在你甚至没有注意到它的时候就会出现，你可能已经看到了我们称为部分应用程序的示例 当然如果你还不理解的话可以,可以完整的多看几次本笔记闭包知识点部分,或者结合上方Ⅱ-举个闭包栗子分析理解 进行理解 1、从 ES6 高阶箭头函数理解函数柯里化(运用到闭包) 首先看到了这样的一个例子： let add = a = b = a + b 以上是一个很简单的相加函数，把它转化成 ES5 的写法如下 function add(a) { return function(b) { return a + b } } var add3 = add(3) //add3表示一个指向函数的变量 可以当成函数调用名来用 add3(4) === 3 + 4 //true 再简化一下，可以写成如下形式： let add = function(a) { var param = a; var innerFun = function(b) { return param + b; } return innerFun; } 虽然好像没什么意义，但是很显然上述使用了[闭包]，而且该函数的返回值是一个函数。其实，这就是高阶函数的定义：以函数为参数或者返回值是函数的函数。 2、柯里化 图例: 关键就是理解柯里化，其实可以把它理解成，柯里化后，将第一个参数变量存在函数里面了(闭包)，然后本来需要n个参数的函数可以变成只需要剩下的（n - 1个）参数就可以调用，比如 let add = x = y = x + y let add2 = add(2) -*---------------------------------- 本来完成 add 这个操作，应该是这样调用 let add = (x, y) = x + y add(2,3) ---------------------------------- 1. 而现在 add2 函数完成同样操作只需要一个参数，这在函数式编程中广泛应用。 let add = x = y = x + y let add2 = add(2) 2.详细解释一下，就是 add2 函数 等价于 有了 x 这个闭包变量的 y = x + y 函数,并且此时 x = 2，所以此时调用 add2(3) === 2 + 3 4、总结 如果是a = b = c = {xxx}这种多次柯里化的,如何理解? 理解:前n - 1次调用，其实是提前将参数传递进去，并没有调用最内层函数体，最后一次调用才会调用最内层函数体，并返回最内层函数体的返回值 结合上文可知，这里的多个连续箭头（无论俩个箭头函数三个及以上）函数连在一起 就是在柯里化。所以连续箭头函数就是多次柯里化函数的 es6 写法。 调用特点:let test = a = b = c = {xxx} 比如对于上面的 test 函数，它有 3 个箭头， 这个函数要被调用 3 次 test(a)(b)(c)，前两次调用只是在传递参数，只有最后依次调用才会返回 {xxx} 代码段的返回值，并且在 {xxx} 代码段中可以调用 a,b,c ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#1从-es6-高阶箭头函数理解函数柯里化运用到闭包"},{"categories":["前端"],"content":"Ⅲ-常见的闭包① 将函数作为另一个函数的返回值 // 1. 将函数作为另一个函数的返回值 function fn1() { var a = 2 function fn2() { a++ console.log(a) } return fn2 } var f = fn1() f() // 3 f() // 4 ② 将函数作为实参传递给另一个函数调用 // 2. 将函数作为实参传递给另一个函数调用 function showDelay(msg, time) { setTimeout(function () { alert(msg) }, time) } showDelay('atguigu', 2000) ③ 高阶函数与柯里化 有时候闭包在你甚至没有注意到它的时候就会出现，你可能已经看到了我们称为部分应用程序的示例 当然如果你还不理解的话可以,可以完整的多看几次本笔记闭包知识点部分,或者结合上方Ⅱ-举个闭包栗子分析理解 进行理解 1、从 ES6 高阶箭头函数理解函数柯里化(运用到闭包) 首先看到了这样的一个例子： let add = a = b = a + b 以上是一个很简单的相加函数，把它转化成 ES5 的写法如下 function add(a) { return function(b) { return a + b } } var add3 = add(3) //add3表示一个指向函数的变量 可以当成函数调用名来用 add3(4) === 3 + 4 //true 再简化一下，可以写成如下形式： let add = function(a) { var param = a; var innerFun = function(b) { return param + b; } return innerFun; } 虽然好像没什么意义，但是很显然上述使用了[闭包]，而且该函数的返回值是一个函数。其实，这就是高阶函数的定义：以函数为参数或者返回值是函数的函数。 2、柯里化 图例: 关键就是理解柯里化，其实可以把它理解成，柯里化后，将第一个参数变量存在函数里面了(闭包)，然后本来需要n个参数的函数可以变成只需要剩下的（n - 1个）参数就可以调用，比如 let add = x = y = x + y let add2 = add(2) -*---------------------------------- 本来完成 add 这个操作，应该是这样调用 let add = (x, y) = x + y add(2,3) ---------------------------------- 1. 而现在 add2 函数完成同样操作只需要一个参数，这在函数式编程中广泛应用。 let add = x = y = x + y let add2 = add(2) 2.详细解释一下，就是 add2 函数 等价于 有了 x 这个闭包变量的 y = x + y 函数,并且此时 x = 2，所以此时调用 add2(3) === 2 + 3 4、总结 如果是a = b = c = {xxx}这种多次柯里化的,如何理解? 理解:前n - 1次调用，其实是提前将参数传递进去，并没有调用最内层函数体，最后一次调用才会调用最内层函数体，并返回最内层函数体的返回值 结合上文可知，这里的多个连续箭头（无论俩个箭头函数三个及以上）函数连在一起 就是在柯里化。所以连续箭头函数就是多次柯里化函数的 es6 写法。 调用特点:let test = a = b = c = {xxx} 比如对于上面的 test 函数，它有 3 个箭头， 这个函数要被调用 3 次 test(a)(b)(c)，前两次调用只是在传递参数，只有最后依次调用才会返回 {xxx} 代码段的返回值，并且在 {xxx} 代码段中可以调用 a,b,c ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#2柯里化"},{"categories":["前端"],"content":"Ⅲ-常见的闭包① 将函数作为另一个函数的返回值 // 1. 将函数作为另一个函数的返回值 function fn1() { var a = 2 function fn2() { a++ console.log(a) } return fn2 } var f = fn1() f() // 3 f() // 4 ② 将函数作为实参传递给另一个函数调用 // 2. 将函数作为实参传递给另一个函数调用 function showDelay(msg, time) { setTimeout(function () { alert(msg) }, time) } showDelay('atguigu', 2000) ③ 高阶函数与柯里化 有时候闭包在你甚至没有注意到它的时候就会出现，你可能已经看到了我们称为部分应用程序的示例 当然如果你还不理解的话可以,可以完整的多看几次本笔记闭包知识点部分,或者结合上方Ⅱ-举个闭包栗子分析理解 进行理解 1、从 ES6 高阶箭头函数理解函数柯里化(运用到闭包) 首先看到了这样的一个例子： let add = a = b = a + b 以上是一个很简单的相加函数，把它转化成 ES5 的写法如下 function add(a) { return function(b) { return a + b } } var add3 = add(3) //add3表示一个指向函数的变量 可以当成函数调用名来用 add3(4) === 3 + 4 //true 再简化一下，可以写成如下形式： let add = function(a) { var param = a; var innerFun = function(b) { return param + b; } return innerFun; } 虽然好像没什么意义，但是很显然上述使用了[闭包]，而且该函数的返回值是一个函数。其实，这就是高阶函数的定义：以函数为参数或者返回值是函数的函数。 2、柯里化 图例: 关键就是理解柯里化，其实可以把它理解成，柯里化后，将第一个参数变量存在函数里面了(闭包)，然后本来需要n个参数的函数可以变成只需要剩下的（n - 1个）参数就可以调用，比如 let add = x = y = x + y let add2 = add(2) -*---------------------------------- 本来完成 add 这个操作，应该是这样调用 let add = (x, y) = x + y add(2,3) ---------------------------------- 1. 而现在 add2 函数完成同样操作只需要一个参数，这在函数式编程中广泛应用。 let add = x = y = x + y let add2 = add(2) 2.详细解释一下，就是 add2 函数 等价于 有了 x 这个闭包变量的 y = x + y 函数,并且此时 x = 2，所以此时调用 add2(3) === 2 + 3 4、总结 如果是a = b = c = {xxx}这种多次柯里化的,如何理解? 理解:前n - 1次调用，其实是提前将参数传递进去，并没有调用最内层函数体，最后一次调用才会调用最内层函数体，并返回最内层函数体的返回值 结合上文可知，这里的多个连续箭头（无论俩个箭头函数三个及以上）函数连在一起 就是在柯里化。所以连续箭头函数就是多次柯里化函数的 es6 写法。 调用特点:let test = a = b = c = {xxx} 比如对于上面的 test 函数，它有 3 个箭头， 这个函数要被调用 3 次 test(a)(b)(c)，前两次调用只是在传递参数，只有最后依次调用才会返回 {xxx} 代码段的返回值，并且在 {xxx} 代码段中可以调用 a,b,c ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#4总结"},{"categories":["前端"],"content":"Ⅳ-闭包的作用 使用函数内部的变量在函数执行完后, 仍然存活在内存中(延长了局部变量的生命周期) 让函数外部可以操作(读写)到函数内部的数据(变量/函数) 问题: 函数执行完后, 函数内部声明的局部变量是否还存在? 一般是不存在, 存在于闭中的变量才可能存在 在函数外部能直接访问函数内部的局部变量吗? 不能, 但我们可以通过闭包让外部操作它 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:4","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-闭包的作用"},{"categories":["前端"],"content":"Ⅴ-闭包的生命周期 产生: 在嵌套内部函数定义执行完时就产生了(不是在调用) 死亡: 在嵌套的内部函数成为垃圾对象时 即没有人指向它时死亡,通常置为[null],当然指向其他也行,但不安全(容易污染变量) //闭包的生命周期 function fn1() { //此时闭包就已经产生了(函数提升,实际上[fn2]提升到了第一行, 内部函数对象已经创建了) var a = 2 function fn2 () { //如果时[let fn2=function(){}],那么在这行才会产生闭包 a++ console.log(a) } return fn2 } var f = fn1() f() // 3 f() // 4 f = null //闭包死亡(包含闭包的函数对象成为垃圾对象) ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:5","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-闭包的生命周期"},{"categories":["前端"],"content":"Ⅵ-闭包的应用 闭包的应用 : 定义JS模块 具有特定功能的js文件 将所有的数据和功能都封装在一个函数内部(私有的) 只向外暴露一个包信n个方法的对象或函数 模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能 模块定义: //myModule.js function myModule() { //私有数据 var msg = ‘My atguigu’ //操作数据的函数 function doSomething() { console.log(‘doSomething() ‘+msg.toUpperCase()) } function doOtherthing () { console.log(‘doOtherthing() ‘+msg.toLowerCase()) } //向外暴露对象(给外部使用的方法) return { doSomething: doSomething, doOtherthing: doOtherthing } } // myModule2.js (function () { //私有数据 var msg = ‘My atguigu’ //操作数据的函数 function doSomething() { console.log(‘doSomething() ‘+msg.toUpperCase()) } function doOtherthing () { console.log(‘doOtherthing() ‘+msg.toLowerCase()) } //向外暴露对象(给外部使用的方法) window.myModule2 = { doSomething: doSomething, doOtherthing: doOtherthing } })() 2. 模块调用 - ```js //调用示例 ------------ 模块调用1 -------------------------------------------- \u003cscript type=\"text/javascript\" src=\"myModule.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\"\u003e var module = myModule() module.doSomething() module.doOtherthing() \u003c/script\u003e ------------ 模块调用2 -------------------------------------------- \u003cscript type=\"text/javascript\" src=\"myModule2.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\"\u003e myModule2.doSomething() myModule2.doOtherthing() \u003c/script\u003e ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:6","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-闭包的应用"},{"categories":["前端"],"content":"Ⅶ-闭包的缺点及解决 缺点: 函数执行完后, 函数内的局部变量没有释放, 占用内存时间会变长 容易造成内存泄露 解决: 能不用闭包就不用 及时释放 function fn1() { var arr = new Array(100000) function fn2() { console.log(arr.length) } return fn2 } var f = fn1() f() f = null //让内部函数成为垃圾对象–\u003e回收闭包 我还有一个解决方式,调用时直接`f()()`直接运行调用即可--\u003e匿名函数,用完自动就销毁了 ![image-20210727191229838](前端学习第4章js高级.assets/202112151732518.png) ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:7","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-闭包的缺点及解决"},{"categories":["前端"],"content":"Ⅷ-内存溢出与内存泄露 内存溢出 一种程序运行出现的错误 当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误 内存泄露 占用的内存没有及时释放 内存泄露积累多了就容易导致内存溢出 常见的内存泄露: 意外的全局变量 没有及时清理的计时器或回调函数 闭包 \u003cscript type=\"text/javascript\"\u003e // 1. 内存溢出 var obj = {} for (var i = 0; i \u003c 10000; i++) { obj[i] = new Array(10000000) console.log('-----') } // 2. 内存泄露 // 意外的全局变量 function fn() { a = new Array(10000000) //不使用var let const去承接 console.log(a) } fn() // 没有及时清理的计时器或回调函数 var intervalId = setInterval(function () { //启动循环定时器后不清理 console.log('----') }, 1000) // clearInterval(intervalId) // 闭包 function fn1() { var a = 4 function fn2() { console.log(++a) } return fn2 } var f = fn1() f() // f = null \u003c/script\u003e 不使用let const var等去声明,实际上是挂载到[window]上的,所以导致内存泄露 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:8","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-内存溢出与内存泄露"},{"categories":["前端"],"content":"Ⅸ-相关面试题1 //代码片段一 --\u003e没有产生闭包:因为内部函数没有调用外部变量 var name = \"The Window\"; var object = { name : \"My Object\", getNameFunc : function(){ return function(){ return this.name; }; } }; alert(object.getNameFunc()()); //? the window //函数体的this是window //代码片段二 var name2 = \"The Window\"; var object2 = { name2 : \"My Object\", getNameFunc : function(){ //此处的this指向是[getNameFunc],他是对象中的属性,所以this指向就是object var that = this; return function(){ //此处用的是保存的 that return that.name2; }; } }; alert(object2.getNameFunc()()); //? my object 代码片段一: 函数体的this指向是[window] 没有产生闭包:因为内部函数没有调用外部变量 代码片段二为何指向是对象? this指向是调用它的[getNameFunc],他是对象中的属性,所以this指向就是object 产生了闭包 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:9","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-相关面试题1"},{"categories":["前端"],"content":"Ⅹ-相关面试题2 function fun(n,o) { console.log(o) return { fun:function(m){ return fun(m,n) } } } var a = fun(0) //undefined a.fun(1) //0 a.fun(2) //0 a.fun(3) //0 var b = fun(0).fun(1).fun(2).fun(3) //undefined 0 1 2 var c = fun(0).fun(1) //undefined 0 c.fun(2)//1 --\u003e经过上方定义后 n固定为1 c.fun(3)//1 --\u003e此处是陷阱!!! 一直没有改到n,所以一直是1 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:10","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-相关面试题2"},{"categories":["前端"],"content":"三、面向对象高级 此部分要求你对前方函数高级部分的1、原型与原型链比较熟悉,如果掌握不够好理解会相对困难 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:0:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#三面向对象高级"},{"categories":["前端"],"content":"1、对象创建模式","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:1:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#1对象创建模式"},{"categories":["前端"],"content":"Ⅰ-Object构造函数模式 方式一: Object构造函数模式 套路: 先创建空Object对象, 再动态添加属性/方法 适用场景: 起始时不确定对象内部数据 问题: 语句太多 /*一个人: name:\"Tom\", age: 12*/ // 先创建空Object对象 var p = new Object() p = {} //此时内部数据是不确定的 // 再动态添加属性/方法 p.name = 'Tom' p.age = 12 p.setName = function (name) { this.name = name } //测试 console.log(p.name, p.age) p.setName('Bob') console.log(p.name, p.age) ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:1:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-object构造函数模式"},{"categories":["前端"],"content":"Ⅱ-对象字面量模式 方式二: 对象字面量模式 套路: 使用{}创建对象, 同时指定属性/方法 适用场景: 起始时对象内部数据是确定的 问题: 如果创建多个对象, 有重复代码 //对象字面量模式 var p = { name: 'Tom', age: 12, setName: function (name) { this.name = name } } //测试 console.log(p.name, p.age) p.setName('JACK') console.log(p.name, p.age) var p2 = { //如果创建多个对象代码很重复 name: 'Bob', age: 13, setName: function (name) { this.name = name } } ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:1:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-对象字面量模式"},{"categories":["前端"],"content":"Ⅲ-工厂模式 方式三: 工厂模式 套路: 通过工厂函数动态创建对象并返回 适用场景: 需要创建多个对象 问题: 对象没有一个具体的类型, 都是Object类型 //返回一个对象的函数===\u003e工厂函数 function createPerson(name, age) { var obj = { name: name, age: age, setName: function (name) { this.name = name } } return obj } // 创建2个人 var p1 = createPerson('Tom', 12) var p2 = createPerson('Bob', 13) // p1/p2是Object类型 function createStudent(name, price) { var obj = { name: name, price: price } return obj } var s = createStudent('张三', 12000) // s也是Object ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:1:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-工厂模式"},{"categories":["前端"],"content":"Ⅳ-自定义构造函数模式 方式四: 自定义构造函数模式 套路: 自定义构造函数, 通过new创建对象 适用场景: 需要创建多个类型确定的对象,与上方工厂模式有所对比 问题: 每个对象都有相同的数据, 浪费内存 //定义类型 function Person(name, age) { this.name = name this.age = age this.setName = function (name) { this.name = name } } var p1 = new Person('Tom', 12) p1.setName('Jack') console.log(p1.name, p1.age) console.log(p1 instanceof Person) function Student (name, price) { this.name = name this.price = price } var s = new Student('Bob', 13000) console.log(s instanceof Student) var p2 = new Person('JACK', 23) console.log(p1, p2) ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:1:4","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-自定义构造函数模式"},{"categories":["前端"],"content":"Ⅴ-构造函数+原型的组合模式 方式六: 构造函数+原型的组合模式–\u003e最好用这个写法 套路: 自定义构造函数, 属性在函数中初始化, 方法添加到原型上 适用场景: 需要创建多个类型确定的对象 放在原型上可以节省空间(只需要加载一遍方法) //在构造函数中只初始化一般函数 function Person(name, age) { this.name = name this.age = age } Person.prototype.setName = function (name) { this.name = name } var p1 = new Person('Tom', 23) var p2 = new Person('Jack', 24) console.log(p1, p2) ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:1:5","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-构造函数原型的组合模式"},{"categories":["前端"],"content":"2、继承模式","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:2:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#2继承模式"},{"categories":["前端"],"content":"Ⅰ-原型链继承 方式1: 原型链继承 套路 定义父类型构造函数 给父类型的原型添加方法 定义子类型的构造函数 创建父类型的对象赋值给子类型的原型 将子类型原型的构造属性设置为子类型–\u003e此处有疑惑的可以看本笔记函数高级部分的1、原型与原型链 给子类型原型添加方法 创建子类型的对象: 可以调用父类型的方法 关键 子类型的原型为父类型的一个实例对象 //父类型 function Supper() { this.supProp = '父亲的原型链' } //给父类型的原型上增加一个[showSupperProp]方法,打印自身subProp Supper.prototype.showSupperProp = function () { console.log(this.supProp) } //子类型 function Sub() { this.subProp = '儿子的原型链' } // 子类型的原型为父类型的一个实例对象 Sub.prototype = new Supper() // 让子类型的原型的constructor指向子类型 // 如果不加,其构造函数找的[`new Supper()`]时从顶层Object继承来的构造函数,指向[`Supper()`] Sub.prototype.constructor = Sub //给子类型的原型上增加一个[showSubProp]方法,打印自身subProp Sub.prototype.showSubProp = function () { console.log(this.subProp) } var sub = new Sub() sub.showSupperProp() //父亲的原型链 sub.showSubProp() //儿子的原型链 console.log(sub) /** Sub {subProp: \"儿子的原型链\"} subProp: \"儿子的原型链\" __proto__: Supper constructor: ƒ Sub() showSubProp: ƒ () supProp: \"父亲的原型链\" __proto__: Object */ ① 示例图 注意:此图中没有体现[constructor构造函数 ],会在下方构造函数补充处指出 ② 构造函数补充 对于代码中[Sub.prototype.constructor = Sub]是否有疑惑? 如果不加,其构造函数找的[new Supper()]是从顶层Object继承来的构造函数,指向[Supper()],虽然如果你不加这句话,大体上使用是不受影响的,但是你有一个属性指向是错误的,如果在大型项目中万一万一哪里再调用到了呢? 这里可以补充一下constructor 的概念： constructor 我们称为构造函数，因为它指回构造函数本身 其作用是让某个构造函数产生的 所有实例对象（比如f） 能够找到他的构造函数（比如Fun），用法就是f.constructor 此时实例对象里没有constructor 这个属性，于是沿着原型链往上找到Fun.prototype 里的constructor，并指向Fun 函数本身 constructor本就存在于原型中,指向构造函数,成为子对象后，如果该原型链中的constructor在自身没有而是在父原型中找到,所以指向父类的构造函数 由于这里的继承是直接改了构造函数的prototype 的指向，所以在 sub的原型链中，Sub.prototype 没有constructor 属性，反而是看到了一个super 实例 这就让sub 实例的constructor 无法使用了。为了他还能用，就在那个super 实例中手动加了一个constructor 属性，且指向Sub 函数看到了一个super 实例 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:2:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-原型链继承"},{"categories":["前端"],"content":"Ⅰ-原型链继承 方式1: 原型链继承 套路 定义父类型构造函数 给父类型的原型添加方法 定义子类型的构造函数 创建父类型的对象赋值给子类型的原型 将子类型原型的构造属性设置为子类型–此处有疑惑的可以看本笔记函数高级部分的1、原型与原型链 给子类型原型添加方法 创建子类型的对象: 可以调用父类型的方法 关键 子类型的原型为父类型的一个实例对象 //父类型 function Supper() { this.supProp = '父亲的原型链' } //给父类型的原型上增加一个[showSupperProp]方法,打印自身subProp Supper.prototype.showSupperProp = function () { console.log(this.supProp) } //子类型 function Sub() { this.subProp = '儿子的原型链' } // 子类型的原型为父类型的一个实例对象 Sub.prototype = new Supper() // 让子类型的原型的constructor指向子类型 // 如果不加,其构造函数找的[`new Supper()`]时从顶层Object继承来的构造函数,指向[`Supper()`] Sub.prototype.constructor = Sub //给子类型的原型上增加一个[showSubProp]方法,打印自身subProp Sub.prototype.showSubProp = function () { console.log(this.subProp) } var sub = new Sub() sub.showSupperProp() //父亲的原型链 sub.showSubProp() //儿子的原型链 console.log(sub) /** Sub {subProp: \"儿子的原型链\"} subProp: \"儿子的原型链\" __proto__: Supper constructor: ƒ Sub() showSubProp: ƒ () supProp: \"父亲的原型链\" __proto__: Object */ ① 示例图 注意:此图中没有体现[constructor构造函数 ],会在下方构造函数补充处指出 ② 构造函数补充 对于代码中[Sub.prototype.constructor = Sub]是否有疑惑? 如果不加,其构造函数找的[new Supper()]是从顶层Object继承来的构造函数,指向[Supper()],虽然如果你不加这句话,大体上使用是不受影响的,但是你有一个属性指向是错误的,如果在大型项目中万一万一哪里再调用到了呢? 这里可以补充一下constructor 的概念： constructor 我们称为构造函数，因为它指回构造函数本身 其作用是让某个构造函数产生的 所有实例对象（比如f） 能够找到他的构造函数（比如Fun），用法就是f.constructor 此时实例对象里没有constructor 这个属性，于是沿着原型链往上找到Fun.prototype 里的constructor，并指向Fun 函数本身 constructor本就存在于原型中,指向构造函数,成为子对象后，如果该原型链中的constructor在自身没有而是在父原型中找到,所以指向父类的构造函数 由于这里的继承是直接改了构造函数的prototype 的指向，所以在 sub的原型链中，Sub.prototype 没有constructor 属性，反而是看到了一个super 实例 这就让sub 实例的constructor 无法使用了。为了他还能用，就在那个super 实例中手动加了一个constructor 属性，且指向Sub 函数看到了一个super 实例 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:2:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-示例图"},{"categories":["前端"],"content":"Ⅰ-原型链继承 方式1: 原型链继承 套路 定义父类型构造函数 给父类型的原型添加方法 定义子类型的构造函数 创建父类型的对象赋值给子类型的原型 将子类型原型的构造属性设置为子类型–此处有疑惑的可以看本笔记函数高级部分的1、原型与原型链 给子类型原型添加方法 创建子类型的对象: 可以调用父类型的方法 关键 子类型的原型为父类型的一个实例对象 //父类型 function Supper() { this.supProp = '父亲的原型链' } //给父类型的原型上增加一个[showSupperProp]方法,打印自身subProp Supper.prototype.showSupperProp = function () { console.log(this.supProp) } //子类型 function Sub() { this.subProp = '儿子的原型链' } // 子类型的原型为父类型的一个实例对象 Sub.prototype = new Supper() // 让子类型的原型的constructor指向子类型 // 如果不加,其构造函数找的[`new Supper()`]时从顶层Object继承来的构造函数,指向[`Supper()`] Sub.prototype.constructor = Sub //给子类型的原型上增加一个[showSubProp]方法,打印自身subProp Sub.prototype.showSubProp = function () { console.log(this.subProp) } var sub = new Sub() sub.showSupperProp() //父亲的原型链 sub.showSubProp() //儿子的原型链 console.log(sub) /** Sub {subProp: \"儿子的原型链\"} subProp: \"儿子的原型链\" __proto__: Supper constructor: ƒ Sub() showSubProp: ƒ () supProp: \"父亲的原型链\" __proto__: Object */ ① 示例图 注意:此图中没有体现[constructor构造函数 ],会在下方构造函数补充处指出 ② 构造函数补充 对于代码中[Sub.prototype.constructor = Sub]是否有疑惑? 如果不加,其构造函数找的[new Supper()]是从顶层Object继承来的构造函数,指向[Supper()],虽然如果你不加这句话,大体上使用是不受影响的,但是你有一个属性指向是错误的,如果在大型项目中万一万一哪里再调用到了呢? 这里可以补充一下constructor 的概念： constructor 我们称为构造函数，因为它指回构造函数本身 其作用是让某个构造函数产生的 所有实例对象（比如f） 能够找到他的构造函数（比如Fun），用法就是f.constructor 此时实例对象里没有constructor 这个属性，于是沿着原型链往上找到Fun.prototype 里的constructor，并指向Fun 函数本身 constructor本就存在于原型中,指向构造函数,成为子对象后，如果该原型链中的constructor在自身没有而是在父原型中找到,所以指向父类的构造函数 由于这里的继承是直接改了构造函数的prototype 的指向，所以在 sub的原型链中，Sub.prototype 没有constructor 属性，反而是看到了一个super 实例 这就让sub 实例的constructor 无法使用了。为了他还能用，就在那个super 实例中手动加了一个constructor 属性，且指向Sub 函数看到了一个super 实例 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:2:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-构造函数补充"},{"categories":["前端"],"content":"Ⅱ-借用构造函数继承(假的) 方式2: 借用构造函数继承(假的) 套路: 定义父类型构造函数 定义子类型构造函数 在子类型构造函数中调用父类型构造 关键: 在子类型构造函数中通用call()调用父类型构造函数 作用: 能借用父类中的构造方法,但是不灵活 function Person(name, age) { this.name = name this.age = age } function Student(name, age, price) { //此处利用call(),将 [Student]的this传递给Person构造函数 Person.call(this, name, age) // 相当于: this.Person(name, age) /*this.name = name this.age = age*/ this.price = price } var s = new Student('Tom', 20, 14000) console.log(s.name, s.age, s.price) [Person]中的this是动态变化的,在[Student]中利用[Person.call(this, name, age)]改变了其this指向,所以可以实现此效果 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:2:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-借用构造函数继承假的"},{"categories":["前端"],"content":"Ⅲ-组合继承 方式3: 原型链+借用构造函数的组合继承 利用原型链实现对父类型对象的方法继承 利用super()借用父类型构建函数初始化相同属性 function Person(name, age) { this.name = name this.age = age } Person.prototype.setName = function (name) { this.name = name } function Student(name, age, price) { Person.call(this, name, age) // 为了得到属性 this.price = price } Student.prototype = new Person() // 为了能看到父类型的方法 Student.prototype.constructor = Student //修正constructor属性 Student.prototype.setPrice = function (price) { this.price = price } var s = new Student('Tom', 24, 15000) s.setName('Bob') s.setPrice(16000) console.log(s.name, s.age, s.price) ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:2:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-组合继承"},{"categories":["前端"],"content":"三、线程机制与事件机制","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:0:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#三线程机制与事件机制"},{"categories":["前端"],"content":"1、进程与线程 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:1:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#1进程与线程"},{"categories":["前端"],"content":"Ⅰ- 进程 程序的一次执行,它占有一片独有的内存空间 可以通过windows任务管理器查看进程 可以看出每个程序的内存空间是相互独立的 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:1:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#--进程"},{"categories":["前端"],"content":"Ⅱ-线程 概念: 是进程内的一个独立执行单元 是程序执行的一个完整流程 是CPU的最小的调度单元 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:1:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-线程"},{"categories":["前端"],"content":"Ⅲ-进程与线程 应用程序必须运行在某个进程的某个线程上 一个进程中至少有一个运行的线程:主线程 –\u003e进程启动后自动创建 一个进程中也可以同时运行多个线程:此时我们会说这个程序是多线程运行的 多个进程之间的数据是不能直接共享的 –\u003e内存相互独立(隔离) 线程池(thread pool):保存多个线程对象的容器,实现线程对象的反复利用 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:1:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-进程与线程"},{"categories":["前端"],"content":"Ⅳ-引出的问题① 何为多进程与多线程? 多进程运行: 一应用程序可以同时启动多个实例运行 多线程: 在一个进程内, 同时有多个线程运行 ②比较单线程与多线程? 多线程: 优点:能有效提升CPU的利用率 缺点 创建多线程开销 线程间切换开销 死锁与状态同步问题 单线程: 优点:顺序编程简单易懂 缺点:效率低 ③ JS是单线程还是多线程? JS是单线程运行的 , 但使用H5中的 Web Workers可以多线程运行 只能由一个线程去操作DOM界面 具体原因可看下方3、JS是单线程的部分给出的详解 ④ 浏览器运行是单线程还是多线程? 都是多线程运行的 ⑤ 浏览器运行是单进程还是多进程? 有的是单进程: firefox 老版IE 有的是多进程: chrome 新版IE 如何查看浏览器是否是多进程运行的呢? 任务管理器–\u003e进程 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:1:4","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-引出的问题"},{"categories":["前端"],"content":"Ⅳ-引出的问题① 何为多进程与多线程? 多进程运行: 一应用程序可以同时启动多个实例运行 多线程: 在一个进程内, 同时有多个线程运行 ②比较单线程与多线程? 多线程: 优点:能有效提升CPU的利用率 缺点 创建多线程开销 线程间切换开销 死锁与状态同步问题 单线程: 优点:顺序编程简单易懂 缺点:效率低 ③ JS是单线程还是多线程? JS是单线程运行的 , 但使用H5中的 Web Workers可以多线程运行 只能由一个线程去操作DOM界面 具体原因可看下方3、JS是单线程的部分给出的详解 ④ 浏览器运行是单线程还是多线程? 都是多线程运行的 ⑤ 浏览器运行是单进程还是多进程? 有的是单进程: firefox 老版IE 有的是多进程: chrome 新版IE 如何查看浏览器是否是多进程运行的呢? 任务管理器–进程 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:1:4","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-何为多进程与多线程"},{"categories":["前端"],"content":"Ⅳ-引出的问题① 何为多进程与多线程? 多进程运行: 一应用程序可以同时启动多个实例运行 多线程: 在一个进程内, 同时有多个线程运行 ②比较单线程与多线程? 多线程: 优点:能有效提升CPU的利用率 缺点 创建多线程开销 线程间切换开销 死锁与状态同步问题 单线程: 优点:顺序编程简单易懂 缺点:效率低 ③ JS是单线程还是多线程? JS是单线程运行的 , 但使用H5中的 Web Workers可以多线程运行 只能由一个线程去操作DOM界面 具体原因可看下方3、JS是单线程的部分给出的详解 ④ 浏览器运行是单线程还是多线程? 都是多线程运行的 ⑤ 浏览器运行是单进程还是多进程? 有的是单进程: firefox 老版IE 有的是多进程: chrome 新版IE 如何查看浏览器是否是多进程运行的呢? 任务管理器–进程 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:1:4","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#比较单线程与多线程"},{"categories":["前端"],"content":"Ⅳ-引出的问题① 何为多进程与多线程? 多进程运行: 一应用程序可以同时启动多个实例运行 多线程: 在一个进程内, 同时有多个线程运行 ②比较单线程与多线程? 多线程: 优点:能有效提升CPU的利用率 缺点 创建多线程开销 线程间切换开销 死锁与状态同步问题 单线程: 优点:顺序编程简单易懂 缺点:效率低 ③ JS是单线程还是多线程? JS是单线程运行的 , 但使用H5中的 Web Workers可以多线程运行 只能由一个线程去操作DOM界面 具体原因可看下方3、JS是单线程的部分给出的详解 ④ 浏览器运行是单线程还是多线程? 都是多线程运行的 ⑤ 浏览器运行是单进程还是多进程? 有的是单进程: firefox 老版IE 有的是多进程: chrome 新版IE 如何查看浏览器是否是多进程运行的呢? 任务管理器–进程 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:1:4","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-js是单线程还是多线程"},{"categories":["前端"],"content":"Ⅳ-引出的问题① 何为多进程与多线程? 多进程运行: 一应用程序可以同时启动多个实例运行 多线程: 在一个进程内, 同时有多个线程运行 ②比较单线程与多线程? 多线程: 优点:能有效提升CPU的利用率 缺点 创建多线程开销 线程间切换开销 死锁与状态同步问题 单线程: 优点:顺序编程简单易懂 缺点:效率低 ③ JS是单线程还是多线程? JS是单线程运行的 , 但使用H5中的 Web Workers可以多线程运行 只能由一个线程去操作DOM界面 具体原因可看下方3、JS是单线程的部分给出的详解 ④ 浏览器运行是单线程还是多线程? 都是多线程运行的 ⑤ 浏览器运行是单进程还是多进程? 有的是单进程: firefox 老版IE 有的是多进程: chrome 新版IE 如何查看浏览器是否是多进程运行的呢? 任务管理器–进程 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:1:4","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-浏览器运行是单线程还是多线程"},{"categories":["前端"],"content":"Ⅳ-引出的问题① 何为多进程与多线程? 多进程运行: 一应用程序可以同时启动多个实例运行 多线程: 在一个进程内, 同时有多个线程运行 ②比较单线程与多线程? 多线程: 优点:能有效提升CPU的利用率 缺点 创建多线程开销 线程间切换开销 死锁与状态同步问题 单线程: 优点:顺序编程简单易懂 缺点:效率低 ③ JS是单线程还是多线程? JS是单线程运行的 , 但使用H5中的 Web Workers可以多线程运行 只能由一个线程去操作DOM界面 具体原因可看下方3、JS是单线程的部分给出的详解 ④ 浏览器运行是单线程还是多线程? 都是多线程运行的 ⑤ 浏览器运行是单进程还是多进程? 有的是单进程: firefox 老版IE 有的是多进程: chrome 新版IE 如何查看浏览器是否是多进程运行的呢? 任务管理器–进程 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:1:4","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-浏览器运行是单进程还是多进程"},{"categories":["前端"],"content":"2、浏览器内核 支撑浏览器运行的最核心的程序 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:2:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#2浏览器内核"},{"categories":["前端"],"content":"Ⅰ-不同浏览器的内核 Chrome, Safari : webkit firefox : Gecko IE : Trident 360,搜狗等国内浏览器: Trident + webkit ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:2:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-不同浏览器的内核"},{"categories":["前端"],"content":"Ⅱ-内核由什么模块组成? 主线程 js引擎模块 : 负责js程序的编译与运行 html,css文档解析模块 : 负责页面文本的解析(拆解) dom/css模块 : 负责dom/css在内存中的相关处理 布局和渲染模块 : 负责页面的布局和效果的绘制 布局和渲染模块 : 负责页面的布局和效果的绘制 分线程 定时器模块 : 负责定时器的管理 网络请求模块 : 负责服务器请求(常规/Ajax) 事件响应模块 : 负责事件的管理 图例 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:2:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-内核由什么模块组成"},{"categories":["前端"],"content":"3、定时器引发的思考 \u003cbody\u003e \u003cbutton id=\"btn\"\u003e启动定时器\u003c/button\u003e \u003cscript type=\"text/javascript\"\u003e document.getElementById('btn').onclick = function () { var start = Date.now() console.log('启动定时器前...') setTimeout(function () { console.log('定时器执行了', Date.now()-start) //定时器并不能保证真正定时执行,一般会延迟一丁点 }, 200) console.log('启动定时器后...') // 做一个长时间的工作 for (var i = 0; i \u003c 1000000000; i++) { //会造成定时器延长很长时间 ... } } \u003c/script\u003e \u003c/body\u003e ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:3:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#3定时器引发的思考"},{"categories":["前端"],"content":"Ⅰ-定时器真是定时执行的吗? 定时器并不能保证真正定时执行 一般会延迟一丁点(可以接受), 也有可能延迟很长时间(不能接受) ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:3:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-定时器真是定时执行的吗"},{"categories":["前端"],"content":"Ⅱ-定时器回调函数是在分线程执行的吗? 在主线程执行的, JS是单线程的 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:3:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-定时器回调函数是在分线程执行的吗"},{"categories":["前端"],"content":"Ⅲ-定时器是如何实现的? 事件循环模型,在下方给出详解 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:3:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-定时器是如何实现的"},{"categories":["前端"],"content":"3、JS是单线程的","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:4:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#3js是单线程的"},{"categories":["前端"],"content":"Ⅰ-如何证明JS执行是单线程的 setTimeout()的回调函数是在主线程执行的 定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行 // 如何证明JS执行是单线程的 setTimeout(function () { //4. 在将[timeout 1111]弹窗关闭后,再等一秒 执行此处 console.log('timeout 2222') alert('22222222') }, 2000) setTimeout(function () { //3. 过了一秒后 打印 timeout 1111并弹窗,此处如果不将弹窗关闭,不会继续执行上方222 console.log('timeout 1111') alert('1111111') }, 1000) setTimeout(function () { //2. 然后打印timeout() 00000 console.log('timeout() 00000') }, 0) function fn() { //1. fn() console.log('fn()') } fn() //---------------------- console.log('alert()之前') alert('------') //暂停当前主线程的执行, 同时暂停计时, 点击确定后, 恢复程序执行和计时 console.log('alert()之后') 流程结果: 先打印了[fn()],然后马上就打印了[timeout() 00000] 过了一秒后 打印 timeout 1111并弹窗,此处如果不将弹窗关闭,不会继续执行上方222 在将[timeout 1111]弹窗关闭后,再等一秒 执行此处 问:为何明明写的是2秒,却关闭上一个弹窗再过一秒就执行? 解:并不是关闭后再计算的,而是一起计算的,alert只是暂停了主线程执行 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:4:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-如何证明js执行是单线程的"},{"categories":["前端"],"content":"Ⅱ-JS引擎执行代码的基本流程与代码分类 代码分类: 初始化代码 回调代码 js引擎执行代码的基本流程 先执行初始化代码: 包含一些特别的代码 回调函数(异步执行) 设置定时器 绑定事件监听 发送ajax请求 后面在某个时刻才会执行回调代码 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:4:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-js引擎执行代码的基本流程与代码分类"},{"categories":["前端"],"content":"Ⅲ-为什么js要用单线程模式, 而不用多线程模式? JavaScript的单线程，与它的用途有关。 作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。 这决定了它只能是单线程，否则会带来很复杂的同步问题 举个栗子:如果我们要实现更新页面上一个dom节点然后删除,用单线程是没问题的 但是如果多线程,当我删除线程先删除了dom节点,更新线程要去更新的时候就会出错 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:4:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-为什么js要用单线程模式-而不用多线程模式"},{"categories":["前端"],"content":"4、事件循环模型(Event Loop)机制","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#4事件循环模型event-loop机制"},{"categories":["前端"],"content":"Ⅰ-概念引出 我们都知道，javascript从诞生之日起就是一门单线程的非阻塞的脚本语言。这是由其最初的用途来决定的：与浏览器交互。 单线程意味着，javascript代码在执行的任何时候，都只有一个主线程来处理所有的任务。 非阻塞: 而非阻塞则是当代码需要进行一项异步任务（无法立刻返回结果，需要花一定时间才能返回的任务，如I/O事件）的时候，主线程会挂起（pending）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。 单线程是必要的: 也是javascript这门语言的基石，原因之一在其最初也是最主要的执行环境——浏览器中，我们需要进行各种各样的dom操作。试想一下 如果javascript是多线程的，那么当两个线程同时对dom进行一项操作，例如一个向其添加事件，而另一个删除了这个dom，此时该如何处理呢？因此，为了保证不会 发生类似于这个例子中的情景，javascript选择只用一个主线程来执行代码，这样就保证了程序执行的一致性。 当然，现如今人们也意识到，单线程在保证了执行顺序的同时也限制了javascript的效率，因此开发出了web workers技术。这项技术号称可以让javaScript成为一门多线程语言。 然而，使用web workers技术开的多线程有着诸多限制，例如：所有新线程都受主线程的完全控制，不能独立执行。这意味着这些“线程” 实际上应属于主线程的子线程。另外，这些子线程并没有执行I/O操作的权限，只能为主线程分担一些诸如计算等任务。所以严格来讲这些线程并没有完整的功能，也因此这项技术并非改变了javascript语言的单线程本质。 可以预见，未来的javascript也会一直是一门单线程的语言。 话说回来，前面提到javascript的另一个特点是“非阻塞”，那么javascript引擎到底是如何实现的这一点呢？ 答案就是——event loop（事件循环）。 注：虽然nodejs中的也存在与传统浏览器环境下的相似的事件循环。然而两者间却有着诸多不同，故把两者分开，单独解释。 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-概念引出"},{"categories":["前端"],"content":"Ⅱ-浏览器环境下JS引擎的事件循环机制① 执行栈概念 执行上下文栈详情可以看上方笔记 –\u003e函数高级的2、执行上下文与执行上下文栈,此处继续进行一次概述加深理解 当javascript代码执行的时候会将不同的变量存于内存中的不同位置：堆（heap）和栈（stack）中来加以区分。其中，堆里存放着一些对象。而栈中则存放着一些基础类型变量以及对象的指针。 但是我们这里说的执行栈和上面这个栈的意义却有些不同。 执行栈: 当我们调用一个方法的时候，js会生成一个与这个方法对应的执行环境（context），又叫执行上下文。这个执行环境中存在着这个方法的私有作用域、上层作用域的指向、方法的参数，这个作用域中定义的变量以及这个作用域的this对象。 而当一系列方法被依次调用的时候，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为执行栈。 当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么js会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，js会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境。这个过程反复进行，直到执行栈中的代码全部执行完毕。 此处继续拿出栈图加深理解:从图片可知，一个方法执行会向执行栈中加入这个方法的执行环境，在这个执行环境中还可以调用其他方法，甚至是自己，其结果不过是在执行栈中再添加一个执行环境。这个过程可以是无限进行下去的，除非发生了栈溢出，即超过了所能使用内存的最大值。 以上的过程说的都是同步代码的执行。那么当一个异步代码（如发送ajax请求数据）执行后会如何呢？ 刚刚说过js的另一大特点是非阻塞，实现这一点的关键在于下面要说的这项机制——事件队列（Task Queue）。 ② 事件队列（Task Queue） JS引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务,当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。 被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码…，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。 这里还有一张图来展示这个过程:图中的stack表示我们所说的执行栈，web apis则是代表一些异步事件，而callback queue即事件队列。 以上的事件循环过程是一个宏观的表述，实际上因为异步任务之间并不相同，因此他们的执行优先级也有区别。不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task）,此部分看下方详解 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-浏览器环境下js引擎的事件循环机制"},{"categories":["前端"],"content":"Ⅱ-浏览器环境下JS引擎的事件循环机制① 执行栈概念 执行上下文栈详情可以看上方笔记 –函数高级的2、执行上下文与执行上下文栈,此处继续进行一次概述加深理解 当javascript代码执行的时候会将不同的变量存于内存中的不同位置：堆（heap）和栈（stack）中来加以区分。其中，堆里存放着一些对象。而栈中则存放着一些基础类型变量以及对象的指针。 但是我们这里说的执行栈和上面这个栈的意义却有些不同。 执行栈: 当我们调用一个方法的时候，js会生成一个与这个方法对应的执行环境（context），又叫执行上下文。这个执行环境中存在着这个方法的私有作用域、上层作用域的指向、方法的参数，这个作用域中定义的变量以及这个作用域的this对象。 而当一系列方法被依次调用的时候，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为执行栈。 当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么js会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，js会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境。这个过程反复进行，直到执行栈中的代码全部执行完毕。 此处继续拿出栈图加深理解:从图片可知，一个方法执行会向执行栈中加入这个方法的执行环境，在这个执行环境中还可以调用其他方法，甚至是自己，其结果不过是在执行栈中再添加一个执行环境。这个过程可以是无限进行下去的，除非发生了栈溢出，即超过了所能使用内存的最大值。 以上的过程说的都是同步代码的执行。那么当一个异步代码（如发送ajax请求数据）执行后会如何呢？ 刚刚说过js的另一大特点是非阻塞，实现这一点的关键在于下面要说的这项机制——事件队列（Task Queue）。 ② 事件队列（Task Queue） JS引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务,当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。 被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码…，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。 这里还有一张图来展示这个过程:图中的stack表示我们所说的执行栈，web apis则是代表一些异步事件，而callback queue即事件队列。 以上的事件循环过程是一个宏观的表述，实际上因为异步任务之间并不相同，因此他们的执行优先级也有区别。不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task）,此部分看下方详解 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-执行栈概念"},{"categories":["前端"],"content":"Ⅱ-浏览器环境下JS引擎的事件循环机制① 执行栈概念 执行上下文栈详情可以看上方笔记 –函数高级的2、执行上下文与执行上下文栈,此处继续进行一次概述加深理解 当javascript代码执行的时候会将不同的变量存于内存中的不同位置：堆（heap）和栈（stack）中来加以区分。其中，堆里存放着一些对象。而栈中则存放着一些基础类型变量以及对象的指针。 但是我们这里说的执行栈和上面这个栈的意义却有些不同。 执行栈: 当我们调用一个方法的时候，js会生成一个与这个方法对应的执行环境（context），又叫执行上下文。这个执行环境中存在着这个方法的私有作用域、上层作用域的指向、方法的参数，这个作用域中定义的变量以及这个作用域的this对象。 而当一系列方法被依次调用的时候，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为执行栈。 当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么js会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，js会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境。这个过程反复进行，直到执行栈中的代码全部执行完毕。 此处继续拿出栈图加深理解:从图片可知，一个方法执行会向执行栈中加入这个方法的执行环境，在这个执行环境中还可以调用其他方法，甚至是自己，其结果不过是在执行栈中再添加一个执行环境。这个过程可以是无限进行下去的，除非发生了栈溢出，即超过了所能使用内存的最大值。 以上的过程说的都是同步代码的执行。那么当一个异步代码（如发送ajax请求数据）执行后会如何呢？ 刚刚说过js的另一大特点是非阻塞，实现这一点的关键在于下面要说的这项机制——事件队列（Task Queue）。 ② 事件队列（Task Queue） JS引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务,当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。 被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码…，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。 这里还有一张图来展示这个过程:图中的stack表示我们所说的执行栈，web apis则是代表一些异步事件，而callback queue即事件队列。 以上的事件循环过程是一个宏观的表述，实际上因为异步任务之间并不相同，因此他们的执行优先级也有区别。不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task）,此部分看下方详解 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-事件队列task-queue"},{"categories":["前端"],"content":"Ⅲ-宏任务(macro task)与微任务(micro task) 宏任务与微任务亦属于Ⅱ-浏览器环境下JS引擎的事件循环机制内知识点,但本人觉得比较重要,将其提高至其知识点 ① 宏任务队列与微任务队列解释 顾名思义,宏任务放至宏任务队列(简称宏队列)中、微任务放至微任务队列(简称微队列)中 JS中用来存储待执行回调函数的队列包含2个不同特定的列队 宏队列:用来保存待执行的宏任务(回调),比如:定时器回调/ajax回调/dom事件回调 微队列:用来保存待执行的微任务(回调),比如:Promise的回调/muntation回调 JS执行时会区别这2个队列: JS执行引擎首先必须执行所有的初始化同步任务代码 每次准备取出第一个宏任务执行前,都要将所有的微任务一个一个取出来执行 前面我们介绍过，在一个事件循环中，异步事件返回结果后会被放到一个任务队列中。然而，根据这个异步事件的类型，这个事件实际上会被对应的宏任务队列或者微任务队列中去。并且在当前执行栈为空的时候，主线程会 查看微任务队列是否有事件存在。如果不存在，那么再去宏任务队列中取出一个事件并把对应的回到加入当前执行栈；如果存在，则会依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈…如此反复，进入循环。 我们只需记住:** 当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行 ** ② 原理图 ③ 由代码逆向理解宏任务与微任务 代码示例 setTimeout(() =\u003e { console.log('timeout callback1（）')//立即放入宏队列 Promise.resolve(3).then( value =\u003e { console.log('Promise onResolved3()', value)//当这个宏任务执行后 立马放入微队列,所以这个微任务执行完后下个宏任务才能执行 } ) }, 0) setTimeout(() =\u003e { console.log('timeout callback2（）') //立即放入宏队列, }, 0) Promise.resolve(1).then( value =\u003e { console.log('Promise onResolved1()', value)//立即放入微队列 setTimeout(() =\u003e { console.log('timeout callback3（）', value) //立即放入宏任务 }, 0) } ) Promise.resolve(2).then( value =\u003e { console.log('Promise onResolved2()', value)//立即放入微队列 } ) console.log('同步代码') //同步代码立即执行 结果 '同步代码', 'Promise onResolved1()', 'Promise onResolved2()', 'timeout callback1（）', 'Promise onResolved3()', 'timeout callback2（）', 'timeout callback3（）' ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-宏任务macro-task与微任务micro-task"},{"categories":["前端"],"content":"Ⅲ-宏任务(macro task)与微任务(micro task) 宏任务与微任务亦属于Ⅱ-浏览器环境下JS引擎的事件循环机制内知识点,但本人觉得比较重要,将其提高至其知识点 ① 宏任务队列与微任务队列解释 顾名思义,宏任务放至宏任务队列(简称宏队列)中、微任务放至微任务队列(简称微队列)中 JS中用来存储待执行回调函数的队列包含2个不同特定的列队 宏队列:用来保存待执行的宏任务(回调),比如:定时器回调/ajax回调/dom事件回调 微队列:用来保存待执行的微任务(回调),比如:Promise的回调/muntation回调 JS执行时会区别这2个队列: JS执行引擎首先必须执行所有的初始化同步任务代码 每次准备取出第一个宏任务执行前,都要将所有的微任务一个一个取出来执行 前面我们介绍过，在一个事件循环中，异步事件返回结果后会被放到一个任务队列中。然而，根据这个异步事件的类型，这个事件实际上会被对应的宏任务队列或者微任务队列中去。并且在当前执行栈为空的时候，主线程会 查看微任务队列是否有事件存在。如果不存在，那么再去宏任务队列中取出一个事件并把对应的回到加入当前执行栈；如果存在，则会依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈…如此反复，进入循环。 我们只需记住:** 当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行 ** ② 原理图 ③ 由代码逆向理解宏任务与微任务 代码示例 setTimeout(() = { console.log('timeout callback1（）')//立即放入宏队列 Promise.resolve(3).then( value = { console.log('Promise onResolved3()', value)//当这个宏任务执行后 立马放入微队列,所以这个微任务执行完后下个宏任务才能执行 } ) }, 0) setTimeout(() = { console.log('timeout callback2（）') //立即放入宏队列, }, 0) Promise.resolve(1).then( value = { console.log('Promise onResolved1()', value)//立即放入微队列 setTimeout(() = { console.log('timeout callback3（）', value) //立即放入宏任务 }, 0) } ) Promise.resolve(2).then( value = { console.log('Promise onResolved2()', value)//立即放入微队列 } ) console.log('同步代码') //同步代码立即执行 结果 '同步代码', 'Promise onResolved1()', 'Promise onResolved2()', 'timeout callback1（）', 'Promise onResolved3()', 'timeout callback2（）', 'timeout callback3（）' ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-宏任务队列与微任务队列解释"},{"categories":["前端"],"content":"Ⅲ-宏任务(macro task)与微任务(micro task) 宏任务与微任务亦属于Ⅱ-浏览器环境下JS引擎的事件循环机制内知识点,但本人觉得比较重要,将其提高至其知识点 ① 宏任务队列与微任务队列解释 顾名思义,宏任务放至宏任务队列(简称宏队列)中、微任务放至微任务队列(简称微队列)中 JS中用来存储待执行回调函数的队列包含2个不同特定的列队 宏队列:用来保存待执行的宏任务(回调),比如:定时器回调/ajax回调/dom事件回调 微队列:用来保存待执行的微任务(回调),比如:Promise的回调/muntation回调 JS执行时会区别这2个队列: JS执行引擎首先必须执行所有的初始化同步任务代码 每次准备取出第一个宏任务执行前,都要将所有的微任务一个一个取出来执行 前面我们介绍过，在一个事件循环中，异步事件返回结果后会被放到一个任务队列中。然而，根据这个异步事件的类型，这个事件实际上会被对应的宏任务队列或者微任务队列中去。并且在当前执行栈为空的时候，主线程会 查看微任务队列是否有事件存在。如果不存在，那么再去宏任务队列中取出一个事件并把对应的回到加入当前执行栈；如果存在，则会依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈…如此反复，进入循环。 我们只需记住:** 当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行 ** ② 原理图 ③ 由代码逆向理解宏任务与微任务 代码示例 setTimeout(() = { console.log('timeout callback1（）')//立即放入宏队列 Promise.resolve(3).then( value = { console.log('Promise onResolved3()', value)//当这个宏任务执行后 立马放入微队列,所以这个微任务执行完后下个宏任务才能执行 } ) }, 0) setTimeout(() = { console.log('timeout callback2（）') //立即放入宏队列, }, 0) Promise.resolve(1).then( value = { console.log('Promise onResolved1()', value)//立即放入微队列 setTimeout(() = { console.log('timeout callback3（）', value) //立即放入宏任务 }, 0) } ) Promise.resolve(2).then( value = { console.log('Promise onResolved2()', value)//立即放入微队列 } ) console.log('同步代码') //同步代码立即执行 结果 '同步代码', 'Promise onResolved1()', 'Promise onResolved2()', 'timeout callback1（）', 'Promise onResolved3()', 'timeout callback2（）', 'timeout callback3（）' ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-原理图"},{"categories":["前端"],"content":"Ⅲ-宏任务(macro task)与微任务(micro task) 宏任务与微任务亦属于Ⅱ-浏览器环境下JS引擎的事件循环机制内知识点,但本人觉得比较重要,将其提高至其知识点 ① 宏任务队列与微任务队列解释 顾名思义,宏任务放至宏任务队列(简称宏队列)中、微任务放至微任务队列(简称微队列)中 JS中用来存储待执行回调函数的队列包含2个不同特定的列队 宏队列:用来保存待执行的宏任务(回调),比如:定时器回调/ajax回调/dom事件回调 微队列:用来保存待执行的微任务(回调),比如:Promise的回调/muntation回调 JS执行时会区别这2个队列: JS执行引擎首先必须执行所有的初始化同步任务代码 每次准备取出第一个宏任务执行前,都要将所有的微任务一个一个取出来执行 前面我们介绍过，在一个事件循环中，异步事件返回结果后会被放到一个任务队列中。然而，根据这个异步事件的类型，这个事件实际上会被对应的宏任务队列或者微任务队列中去。并且在当前执行栈为空的时候，主线程会 查看微任务队列是否有事件存在。如果不存在，那么再去宏任务队列中取出一个事件并把对应的回到加入当前执行栈；如果存在，则会依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈…如此反复，进入循环。 我们只需记住:** 当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行 ** ② 原理图 ③ 由代码逆向理解宏任务与微任务 代码示例 setTimeout(() = { console.log('timeout callback1（）')//立即放入宏队列 Promise.resolve(3).then( value = { console.log('Promise onResolved3()', value)//当这个宏任务执行后 立马放入微队列,所以这个微任务执行完后下个宏任务才能执行 } ) }, 0) setTimeout(() = { console.log('timeout callback2（）') //立即放入宏队列, }, 0) Promise.resolve(1).then( value = { console.log('Promise onResolved1()', value)//立即放入微队列 setTimeout(() = { console.log('timeout callback3（）', value) //立即放入宏任务 }, 0) } ) Promise.resolve(2).then( value = { console.log('Promise onResolved2()', value)//立即放入微队列 } ) console.log('同步代码') //同步代码立即执行 结果 '同步代码', 'Promise onResolved1()', 'Promise onResolved2()', 'timeout callback1（）', 'Promise onResolved3()', 'timeout callback2（）', 'timeout callback3（）' ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-由代码逆向理解宏任务与微任务"},{"categories":["前端"],"content":"Ⅳ-node环境下的事件循环机制 不学node的小伙伴就跳过此部分直接去下一节Web Workers笔记吧 ① 与浏览器环境有何不同? 在node中，事件循环表现出的状态与浏览器中大致相同。不同的是node中有一套自己的模型。node中事件循环的实现是依靠的libuv引擎。我们知道node选择chrome v8引擎作为js解释器，v8引擎将js代码分析后去调用对应的node api，而这些api最后则由libuv引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。 因此实际上node中的事件循环存在于libuv引擎中。 ② 事件循环模型 下面是一个libuv引擎中的事件循环的模型: //libuv引擎中的事件循环的模型 ┌───────────────────────┐ ┌─\u003e│ timers │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ I/O callbacks │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ idle, prepare │ │ └──────────┬────────────┘ ┌───────────────┐ │ ┌──────────┴────────────┐ │ incoming: │ │ │ poll │\u003c──connections─── │ │ └──────────┬────────────┘ │ data, etc. │ │ ┌──────────┴────────────┐ └───────────────┘ │ │ check │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ └──┤ close callbacks │ └───────────────────────┘ 注：模型中的每一个方块代表事件循环的一个阶段 这个模型是node官网上的一篇文章中给出的，我下面的解释也都来源于这篇文章。我会在文末把文章地址贴出来，有兴趣的朋友可以亲自与看看原文。 ③ 事件循环各阶段详解 从上面这个模型中，我们可以大致分析出node中的事件循环的顺序： 外部输入数据–\u003e轮询阶段(poll)–\u003e检查阶段(check)–\u003e关闭事件回调阶段(close callback)–\u003e定时器检测阶段(timer)–\u003eI/O事件回调阶段(I/O callbacks)–\u003e闲置阶段(idle, prepare)–\u003e轮询阶段… 这些阶段大致的功能如下： timers(定时器检测阶段): 这个阶段执行定时器队列中的回调如 setTimeout() 和 setInterval()。 I/O callbacks(I/O事件回调阶段): 这个阶段执行几乎所有的回调。但是不包括close事件，定时器和setImmediate()的回调。 idle, prepare: 这个阶段仅在内部使用，可以不必理会。 poll(轮询阶段): 等待新的I/O事件，node在一些特殊情况下会阻塞在这里。 check(检查阶段): setImmediate()的回调会在这个阶段执行。 close callbacks(关闭事件回调阶段): 例如socket.on('close', ...)这种close事件的回调。 下面我们来按照代码第一次进入libuv引擎后的顺序来详细解说这些阶段： poll(轮询阶段) 当个v8引擎将js代码解析后传入libuv引擎后，循环首先进入poll阶段。poll阶段的执行逻辑如下： 先查看poll queue中是否有事件，有任务就按先进先出的顺序依次执行回调。 当queue为空时，会检查是否有setImmediate()的callback，如果有就进入check阶段执行这些callback。但同时也会检查是否有到期的timer，如果有，就把这些到期的timer的callback按照调用顺序放到timer queue中，之后循环会进入timer阶段执行queue中的 callback。 这两者的顺序是不固定的，收到代码运行的环境的影响。如果两者的queue都是空的，那么loop会在poll阶段停留，直到有一个i/o事件返回，循环会进入i/o callback阶段并立即执行这个事件的callback。 值得注意的是，poll阶段在执行poll queue中的回调时实际上不会无限的执行下去。有两种情况poll阶段会终止执行poll queue中的下一个回调：1.所有回调执行完毕。2.执行数超过了node的限制。 check(检查阶段) check阶段专门用来执行setImmediate()方法的回调，当poll阶段进入空闲状态，并且setImmediate queue中有callback时，事件循环进入这个阶段。 close callbacks(关闭事件回调阶段) 当一个socket连接或者一个handle被突然关闭时（例如调用了socket.destroy()方法），close事件会被发送到这个阶段执行回调。否则事件会用process.nextTick（）方法发送出去。 timers(定时器检测阶段) 这个阶段以先进先出的方式执行所有到期的timer加入timer队列里的callback，一个timer callback指得是一个通过setTimeout或者setInterval函数设置的回调函数。 I/O callbacks(I/O事件回调阶段) 如上文所言，这个阶段主要执行大部分I/O事件的回调，包括一些为操作系统执行的回调。例如一个TCP连接生错误时，系统需要执行回调来获得这个错误的报告。 ④ process.nextTick,setTimeout与setImmediate的区别与使用场景 在node中有三个常用的用来推迟任务执行的方法：process.nextTick,setTimeout（setInterval与之相同）与setImmediate 这三者间存在着一些非常不同的区别： process.nextTick() 尽管没有提及，但是实际上node中存在着一个特殊的队列，即nextTick queue。这个队列中的回调执行虽然没有被表示为一个阶段，当时这些事件却会在每一个阶段执行完毕准备进入下一个阶段时优先执行。当事件循环准备进入下一个阶段之前，会先检查nextTick queue中是否有任务，如果有，那么会先清空这个队列。与执行poll queue中的任务不同的是，这个操作在队列清空前是不会停止的。这也就意味着，错误的使用process.nextTick()方法会导致node进入一个死循环。。直到内存泄漏。 使用这个方法比较合适呢？下面有一个例子： const server = net.createServer(() =\u003e {}).listen(8080); server.on('listening', () =\u003e {}); 这个例子中当，当listen方法被调用时，除非端口被占用，否则会立刻绑定在对应的端口上。这意味着此时这个端口可以立刻触发listening事件并执行其回调。然而，这时候on('listening)还没有将callback设置好，自然没有callback可以执行。为了避免出现这种情况，node会在listen事件中使用process.nextTick()方法，确保事件在回调函数绑定后被触发。 setTimeout()和setImmediate() 在三个方法中，这两个方法最容易被弄混。实际上，某些情况下这两个方法的表现也非常相似。然而实际上，这两个方法的意义却大为不同。 setTimeout()方法是定义一个回调，并且希望这个回调在我们所指定的时间间隔后第一时间去执行。注意这个“第一时间执行”，这意味着，受到操作系统和当前执行任务的诸多影响，该回调并不会在我们预期的时间间隔后精准的执行。执行的时间存在一定的延迟和误差，这是不可避免的。node会在可以执行timer回调的第一时间去执行你所设定的任务。 setImmediate()方法从意义上将是立刻执行的意思，但是实际上它却是在一个固定的阶段才会执行回调，即poll阶段之后。有趣的是，这个名字的意义和之前提到过的process.nextTick()方法才是最匹配的。node的开发者们也清楚这两个方法的命名上存在一定的混淆，他们表示不会把这两个方法的名字调换过来—因为有大量的node程序使用着这两个方法，调换命名所带来的好处与它的影响相比不值一提。 setTimeout()和不设置时间间隔的setImmediate()表现上及其相似。猜猜下面这段代码的结果是什么？ setTimeout(() =\u003e { console.log('timeout'); }, 0); setImmediate(() =\u003e { console.log('immediate'); }); 实际上，答案是不一定。没错，就连node的开发者都无法准确的判断这两者的顺序谁前谁后。这取决于这段代码的运行环境。运行环境中的各种复杂的情况会导致在同步队列里两个方法的顺序随机决定。但是，在一种情况下可以准确判断两个方法回调的执行顺序，那就是在一个I/O事件的回调中。下面这段代码的顺序永远是固定的： const fs = require('fs'); fs.readFile(__filename, () =\u003e { setTimeout(() =\u003e { console.l","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:4","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-node环境下的事件循环机制"},{"categories":["前端"],"content":"Ⅳ-node环境下的事件循环机制 不学node的小伙伴就跳过此部分直接去下一节Web Workers笔记吧 ① 与浏览器环境有何不同? 在node中，事件循环表现出的状态与浏览器中大致相同。不同的是node中有一套自己的模型。node中事件循环的实现是依靠的libuv引擎。我们知道node选择chrome v8引擎作为js解释器，v8引擎将js代码分析后去调用对应的node api，而这些api最后则由libuv引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。 因此实际上node中的事件循环存在于libuv引擎中。 ② 事件循环模型 下面是一个libuv引擎中的事件循环的模型: //libuv引擎中的事件循环的模型 ┌───────────────────────┐ ┌─│ timers │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ I/O callbacks │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ idle, prepare │ │ └──────────┬────────────┘ ┌───────────────┐ │ ┌──────────┴────────────┐ │ incoming: │ │ │ poll │轮询阶段(poll)–检查阶段(check)–关闭事件回调阶段(close callback)–定时器检测阶段(timer)–I/O事件回调阶段(I/O callbacks)–闲置阶段(idle, prepare)–轮询阶段… 这些阶段大致的功能如下： timers(定时器检测阶段): 这个阶段执行定时器队列中的回调如 setTimeout() 和 setInterval()。 I/O callbacks(I/O事件回调阶段): 这个阶段执行几乎所有的回调。但是不包括close事件，定时器和setImmediate()的回调。 idle, prepare: 这个阶段仅在内部使用，可以不必理会。 poll(轮询阶段): 等待新的I/O事件，node在一些特殊情况下会阻塞在这里。 check(检查阶段): setImmediate()的回调会在这个阶段执行。 close callbacks(关闭事件回调阶段): 例如socket.on('close', ...)这种close事件的回调。 下面我们来按照代码第一次进入libuv引擎后的顺序来详细解说这些阶段： poll(轮询阶段) 当个v8引擎将js代码解析后传入libuv引擎后，循环首先进入poll阶段。poll阶段的执行逻辑如下： 先查看poll queue中是否有事件，有任务就按先进先出的顺序依次执行回调。 当queue为空时，会检查是否有setImmediate()的callback，如果有就进入check阶段执行这些callback。但同时也会检查是否有到期的timer，如果有，就把这些到期的timer的callback按照调用顺序放到timer queue中，之后循环会进入timer阶段执行queue中的 callback。 这两者的顺序是不固定的，收到代码运行的环境的影响。如果两者的queue都是空的，那么loop会在poll阶段停留，直到有一个i/o事件返回，循环会进入i/o callback阶段并立即执行这个事件的callback。 值得注意的是，poll阶段在执行poll queue中的回调时实际上不会无限的执行下去。有两种情况poll阶段会终止执行poll queue中的下一个回调：1.所有回调执行完毕。2.执行数超过了node的限制。 check(检查阶段) check阶段专门用来执行setImmediate()方法的回调，当poll阶段进入空闲状态，并且setImmediate queue中有callback时，事件循环进入这个阶段。 close callbacks(关闭事件回调阶段) 当一个socket连接或者一个handle被突然关闭时（例如调用了socket.destroy()方法），close事件会被发送到这个阶段执行回调。否则事件会用process.nextTick（）方法发送出去。 timers(定时器检测阶段) 这个阶段以先进先出的方式执行所有到期的timer加入timer队列里的callback，一个timer callback指得是一个通过setTimeout或者setInterval函数设置的回调函数。 I/O callbacks(I/O事件回调阶段) 如上文所言，这个阶段主要执行大部分I/O事件的回调，包括一些为操作系统执行的回调。例如一个TCP连接生错误时，系统需要执行回调来获得这个错误的报告。 ④ process.nextTick,setTimeout与setImmediate的区别与使用场景 在node中有三个常用的用来推迟任务执行的方法：process.nextTick,setTimeout（setInterval与之相同）与setImmediate 这三者间存在着一些非常不同的区别： process.nextTick() 尽管没有提及，但是实际上node中存在着一个特殊的队列，即nextTick queue。这个队列中的回调执行虽然没有被表示为一个阶段，当时这些事件却会在每一个阶段执行完毕准备进入下一个阶段时优先执行。当事件循环准备进入下一个阶段之前，会先检查nextTick queue中是否有任务，如果有，那么会先清空这个队列。与执行poll queue中的任务不同的是，这个操作在队列清空前是不会停止的。这也就意味着，错误的使用process.nextTick()方法会导致node进入一个死循环。。直到内存泄漏。 使用这个方法比较合适呢？下面有一个例子： const server = net.createServer(() = {}).listen(8080); server.on('listening', () = {}); 这个例子中当，当listen方法被调用时，除非端口被占用，否则会立刻绑定在对应的端口上。这意味着此时这个端口可以立刻触发listening事件并执行其回调。然而，这时候on('listening)还没有将callback设置好，自然没有callback可以执行。为了避免出现这种情况，node会在listen事件中使用process.nextTick()方法，确保事件在回调函数绑定后被触发。 setTimeout()和setImmediate() 在三个方法中，这两个方法最容易被弄混。实际上，某些情况下这两个方法的表现也非常相似。然而实际上，这两个方法的意义却大为不同。 setTimeout()方法是定义一个回调，并且希望这个回调在我们所指定的时间间隔后第一时间去执行。注意这个“第一时间执行”，这意味着，受到操作系统和当前执行任务的诸多影响，该回调并不会在我们预期的时间间隔后精准的执行。执行的时间存在一定的延迟和误差，这是不可避免的。node会在可以执行timer回调的第一时间去执行你所设定的任务。 setImmediate()方法从意义上将是立刻执行的意思，但是实际上它却是在一个固定的阶段才会执行回调，即poll阶段之后。有趣的是，这个名字的意义和之前提到过的process.nextTick()方法才是最匹配的。node的开发者们也清楚这两个方法的命名上存在一定的混淆，他们表示不会把这两个方法的名字调换过来—因为有大量的node程序使用着这两个方法，调换命名所带来的好处与它的影响相比不值一提。 setTimeout()和不设置时间间隔的setImmediate()表现上及其相似。猜猜下面这段代码的结果是什么？ setTimeout(() = { console.log('timeout'); }, 0); setImmediate(() = { console.log('immediate'); }); 实际上，答案是不一定。没错，就连node的开发者都无法准确的判断这两者的顺序谁前谁后。这取决于这段代码的运行环境。运行环境中的各种复杂的情况会导致在同步队列里两个方法的顺序随机决定。但是，在一种情况下可以准确判断两个方法回调的执行顺序，那就是在一个I/O事件的回调中。下面这段代码的顺序永远是固定的： const fs = require('fs'); fs.readFile(__filename, () = { setTimeout(() = { console.l","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:4","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-与浏览器环境有何不同"},{"categories":["前端"],"content":"Ⅳ-node环境下的事件循环机制 不学node的小伙伴就跳过此部分直接去下一节Web Workers笔记吧 ① 与浏览器环境有何不同? 在node中，事件循环表现出的状态与浏览器中大致相同。不同的是node中有一套自己的模型。node中事件循环的实现是依靠的libuv引擎。我们知道node选择chrome v8引擎作为js解释器，v8引擎将js代码分析后去调用对应的node api，而这些api最后则由libuv引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。 因此实际上node中的事件循环存在于libuv引擎中。 ② 事件循环模型 下面是一个libuv引擎中的事件循环的模型: //libuv引擎中的事件循环的模型 ┌───────────────────────┐ ┌─│ timers │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ I/O callbacks │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ idle, prepare │ │ └──────────┬────────────┘ ┌───────────────┐ │ ┌──────────┴────────────┐ │ incoming: │ │ │ poll │轮询阶段(poll)–检查阶段(check)–关闭事件回调阶段(close callback)–定时器检测阶段(timer)–I/O事件回调阶段(I/O callbacks)–闲置阶段(idle, prepare)–轮询阶段… 这些阶段大致的功能如下： timers(定时器检测阶段): 这个阶段执行定时器队列中的回调如 setTimeout() 和 setInterval()。 I/O callbacks(I/O事件回调阶段): 这个阶段执行几乎所有的回调。但是不包括close事件，定时器和setImmediate()的回调。 idle, prepare: 这个阶段仅在内部使用，可以不必理会。 poll(轮询阶段): 等待新的I/O事件，node在一些特殊情况下会阻塞在这里。 check(检查阶段): setImmediate()的回调会在这个阶段执行。 close callbacks(关闭事件回调阶段): 例如socket.on('close', ...)这种close事件的回调。 下面我们来按照代码第一次进入libuv引擎后的顺序来详细解说这些阶段： poll(轮询阶段) 当个v8引擎将js代码解析后传入libuv引擎后，循环首先进入poll阶段。poll阶段的执行逻辑如下： 先查看poll queue中是否有事件，有任务就按先进先出的顺序依次执行回调。 当queue为空时，会检查是否有setImmediate()的callback，如果有就进入check阶段执行这些callback。但同时也会检查是否有到期的timer，如果有，就把这些到期的timer的callback按照调用顺序放到timer queue中，之后循环会进入timer阶段执行queue中的 callback。 这两者的顺序是不固定的，收到代码运行的环境的影响。如果两者的queue都是空的，那么loop会在poll阶段停留，直到有一个i/o事件返回，循环会进入i/o callback阶段并立即执行这个事件的callback。 值得注意的是，poll阶段在执行poll queue中的回调时实际上不会无限的执行下去。有两种情况poll阶段会终止执行poll queue中的下一个回调：1.所有回调执行完毕。2.执行数超过了node的限制。 check(检查阶段) check阶段专门用来执行setImmediate()方法的回调，当poll阶段进入空闲状态，并且setImmediate queue中有callback时，事件循环进入这个阶段。 close callbacks(关闭事件回调阶段) 当一个socket连接或者一个handle被突然关闭时（例如调用了socket.destroy()方法），close事件会被发送到这个阶段执行回调。否则事件会用process.nextTick（）方法发送出去。 timers(定时器检测阶段) 这个阶段以先进先出的方式执行所有到期的timer加入timer队列里的callback，一个timer callback指得是一个通过setTimeout或者setInterval函数设置的回调函数。 I/O callbacks(I/O事件回调阶段) 如上文所言，这个阶段主要执行大部分I/O事件的回调，包括一些为操作系统执行的回调。例如一个TCP连接生错误时，系统需要执行回调来获得这个错误的报告。 ④ process.nextTick,setTimeout与setImmediate的区别与使用场景 在node中有三个常用的用来推迟任务执行的方法：process.nextTick,setTimeout（setInterval与之相同）与setImmediate 这三者间存在着一些非常不同的区别： process.nextTick() 尽管没有提及，但是实际上node中存在着一个特殊的队列，即nextTick queue。这个队列中的回调执行虽然没有被表示为一个阶段，当时这些事件却会在每一个阶段执行完毕准备进入下一个阶段时优先执行。当事件循环准备进入下一个阶段之前，会先检查nextTick queue中是否有任务，如果有，那么会先清空这个队列。与执行poll queue中的任务不同的是，这个操作在队列清空前是不会停止的。这也就意味着，错误的使用process.nextTick()方法会导致node进入一个死循环。。直到内存泄漏。 使用这个方法比较合适呢？下面有一个例子： const server = net.createServer(() = {}).listen(8080); server.on('listening', () = {}); 这个例子中当，当listen方法被调用时，除非端口被占用，否则会立刻绑定在对应的端口上。这意味着此时这个端口可以立刻触发listening事件并执行其回调。然而，这时候on('listening)还没有将callback设置好，自然没有callback可以执行。为了避免出现这种情况，node会在listen事件中使用process.nextTick()方法，确保事件在回调函数绑定后被触发。 setTimeout()和setImmediate() 在三个方法中，这两个方法最容易被弄混。实际上，某些情况下这两个方法的表现也非常相似。然而实际上，这两个方法的意义却大为不同。 setTimeout()方法是定义一个回调，并且希望这个回调在我们所指定的时间间隔后第一时间去执行。注意这个“第一时间执行”，这意味着，受到操作系统和当前执行任务的诸多影响，该回调并不会在我们预期的时间间隔后精准的执行。执行的时间存在一定的延迟和误差，这是不可避免的。node会在可以执行timer回调的第一时间去执行你所设定的任务。 setImmediate()方法从意义上将是立刻执行的意思，但是实际上它却是在一个固定的阶段才会执行回调，即poll阶段之后。有趣的是，这个名字的意义和之前提到过的process.nextTick()方法才是最匹配的。node的开发者们也清楚这两个方法的命名上存在一定的混淆，他们表示不会把这两个方法的名字调换过来—因为有大量的node程序使用着这两个方法，调换命名所带来的好处与它的影响相比不值一提。 setTimeout()和不设置时间间隔的setImmediate()表现上及其相似。猜猜下面这段代码的结果是什么？ setTimeout(() = { console.log('timeout'); }, 0); setImmediate(() = { console.log('immediate'); }); 实际上，答案是不一定。没错，就连node的开发者都无法准确的判断这两者的顺序谁前谁后。这取决于这段代码的运行环境。运行环境中的各种复杂的情况会导致在同步队列里两个方法的顺序随机决定。但是，在一种情况下可以准确判断两个方法回调的执行顺序，那就是在一个I/O事件的回调中。下面这段代码的顺序永远是固定的： const fs = require('fs'); fs.readFile(__filename, () = { setTimeout(() = { console.l","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:4","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-事件循环模型"},{"categories":["前端"],"content":"Ⅳ-node环境下的事件循环机制 不学node的小伙伴就跳过此部分直接去下一节Web Workers笔记吧 ① 与浏览器环境有何不同? 在node中，事件循环表现出的状态与浏览器中大致相同。不同的是node中有一套自己的模型。node中事件循环的实现是依靠的libuv引擎。我们知道node选择chrome v8引擎作为js解释器，v8引擎将js代码分析后去调用对应的node api，而这些api最后则由libuv引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。 因此实际上node中的事件循环存在于libuv引擎中。 ② 事件循环模型 下面是一个libuv引擎中的事件循环的模型: //libuv引擎中的事件循环的模型 ┌───────────────────────┐ ┌─│ timers │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ I/O callbacks │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ idle, prepare │ │ └──────────┬────────────┘ ┌───────────────┐ │ ┌──────────┴────────────┐ │ incoming: │ │ │ poll │轮询阶段(poll)–检查阶段(check)–关闭事件回调阶段(close callback)–定时器检测阶段(timer)–I/O事件回调阶段(I/O callbacks)–闲置阶段(idle, prepare)–轮询阶段… 这些阶段大致的功能如下： timers(定时器检测阶段): 这个阶段执行定时器队列中的回调如 setTimeout() 和 setInterval()。 I/O callbacks(I/O事件回调阶段): 这个阶段执行几乎所有的回调。但是不包括close事件，定时器和setImmediate()的回调。 idle, prepare: 这个阶段仅在内部使用，可以不必理会。 poll(轮询阶段): 等待新的I/O事件，node在一些特殊情况下会阻塞在这里。 check(检查阶段): setImmediate()的回调会在这个阶段执行。 close callbacks(关闭事件回调阶段): 例如socket.on('close', ...)这种close事件的回调。 下面我们来按照代码第一次进入libuv引擎后的顺序来详细解说这些阶段： poll(轮询阶段) 当个v8引擎将js代码解析后传入libuv引擎后，循环首先进入poll阶段。poll阶段的执行逻辑如下： 先查看poll queue中是否有事件，有任务就按先进先出的顺序依次执行回调。 当queue为空时，会检查是否有setImmediate()的callback，如果有就进入check阶段执行这些callback。但同时也会检查是否有到期的timer，如果有，就把这些到期的timer的callback按照调用顺序放到timer queue中，之后循环会进入timer阶段执行queue中的 callback。 这两者的顺序是不固定的，收到代码运行的环境的影响。如果两者的queue都是空的，那么loop会在poll阶段停留，直到有一个i/o事件返回，循环会进入i/o callback阶段并立即执行这个事件的callback。 值得注意的是，poll阶段在执行poll queue中的回调时实际上不会无限的执行下去。有两种情况poll阶段会终止执行poll queue中的下一个回调：1.所有回调执行完毕。2.执行数超过了node的限制。 check(检查阶段) check阶段专门用来执行setImmediate()方法的回调，当poll阶段进入空闲状态，并且setImmediate queue中有callback时，事件循环进入这个阶段。 close callbacks(关闭事件回调阶段) 当一个socket连接或者一个handle被突然关闭时（例如调用了socket.destroy()方法），close事件会被发送到这个阶段执行回调。否则事件会用process.nextTick（）方法发送出去。 timers(定时器检测阶段) 这个阶段以先进先出的方式执行所有到期的timer加入timer队列里的callback，一个timer callback指得是一个通过setTimeout或者setInterval函数设置的回调函数。 I/O callbacks(I/O事件回调阶段) 如上文所言，这个阶段主要执行大部分I/O事件的回调，包括一些为操作系统执行的回调。例如一个TCP连接生错误时，系统需要执行回调来获得这个错误的报告。 ④ process.nextTick,setTimeout与setImmediate的区别与使用场景 在node中有三个常用的用来推迟任务执行的方法：process.nextTick,setTimeout（setInterval与之相同）与setImmediate 这三者间存在着一些非常不同的区别： process.nextTick() 尽管没有提及，但是实际上node中存在着一个特殊的队列，即nextTick queue。这个队列中的回调执行虽然没有被表示为一个阶段，当时这些事件却会在每一个阶段执行完毕准备进入下一个阶段时优先执行。当事件循环准备进入下一个阶段之前，会先检查nextTick queue中是否有任务，如果有，那么会先清空这个队列。与执行poll queue中的任务不同的是，这个操作在队列清空前是不会停止的。这也就意味着，错误的使用process.nextTick()方法会导致node进入一个死循环。。直到内存泄漏。 使用这个方法比较合适呢？下面有一个例子： const server = net.createServer(() = {}).listen(8080); server.on('listening', () = {}); 这个例子中当，当listen方法被调用时，除非端口被占用，否则会立刻绑定在对应的端口上。这意味着此时这个端口可以立刻触发listening事件并执行其回调。然而，这时候on('listening)还没有将callback设置好，自然没有callback可以执行。为了避免出现这种情况，node会在listen事件中使用process.nextTick()方法，确保事件在回调函数绑定后被触发。 setTimeout()和setImmediate() 在三个方法中，这两个方法最容易被弄混。实际上，某些情况下这两个方法的表现也非常相似。然而实际上，这两个方法的意义却大为不同。 setTimeout()方法是定义一个回调，并且希望这个回调在我们所指定的时间间隔后第一时间去执行。注意这个“第一时间执行”，这意味着，受到操作系统和当前执行任务的诸多影响，该回调并不会在我们预期的时间间隔后精准的执行。执行的时间存在一定的延迟和误差，这是不可避免的。node会在可以执行timer回调的第一时间去执行你所设定的任务。 setImmediate()方法从意义上将是立刻执行的意思，但是实际上它却是在一个固定的阶段才会执行回调，即poll阶段之后。有趣的是，这个名字的意义和之前提到过的process.nextTick()方法才是最匹配的。node的开发者们也清楚这两个方法的命名上存在一定的混淆，他们表示不会把这两个方法的名字调换过来—因为有大量的node程序使用着这两个方法，调换命名所带来的好处与它的影响相比不值一提。 setTimeout()和不设置时间间隔的setImmediate()表现上及其相似。猜猜下面这段代码的结果是什么？ setTimeout(() = { console.log('timeout'); }, 0); setImmediate(() = { console.log('immediate'); }); 实际上，答案是不一定。没错，就连node的开发者都无法准确的判断这两者的顺序谁前谁后。这取决于这段代码的运行环境。运行环境中的各种复杂的情况会导致在同步队列里两个方法的顺序随机决定。但是，在一种情况下可以准确判断两个方法回调的执行顺序，那就是在一个I/O事件的回调中。下面这段代码的顺序永远是固定的： const fs = require('fs'); fs.readFile(__filename, () = { setTimeout(() = { console.l","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:4","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-事件循环各阶段详解"},{"categories":["前端"],"content":"Ⅳ-node环境下的事件循环机制 不学node的小伙伴就跳过此部分直接去下一节Web Workers笔记吧 ① 与浏览器环境有何不同? 在node中，事件循环表现出的状态与浏览器中大致相同。不同的是node中有一套自己的模型。node中事件循环的实现是依靠的libuv引擎。我们知道node选择chrome v8引擎作为js解释器，v8引擎将js代码分析后去调用对应的node api，而这些api最后则由libuv引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。 因此实际上node中的事件循环存在于libuv引擎中。 ② 事件循环模型 下面是一个libuv引擎中的事件循环的模型: //libuv引擎中的事件循环的模型 ┌───────────────────────┐ ┌─│ timers │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ I/O callbacks │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ idle, prepare │ │ └──────────┬────────────┘ ┌───────────────┐ │ ┌──────────┴────────────┐ │ incoming: │ │ │ poll │轮询阶段(poll)–检查阶段(check)–关闭事件回调阶段(close callback)–定时器检测阶段(timer)–I/O事件回调阶段(I/O callbacks)–闲置阶段(idle, prepare)–轮询阶段… 这些阶段大致的功能如下： timers(定时器检测阶段): 这个阶段执行定时器队列中的回调如 setTimeout() 和 setInterval()。 I/O callbacks(I/O事件回调阶段): 这个阶段执行几乎所有的回调。但是不包括close事件，定时器和setImmediate()的回调。 idle, prepare: 这个阶段仅在内部使用，可以不必理会。 poll(轮询阶段): 等待新的I/O事件，node在一些特殊情况下会阻塞在这里。 check(检查阶段): setImmediate()的回调会在这个阶段执行。 close callbacks(关闭事件回调阶段): 例如socket.on('close', ...)这种close事件的回调。 下面我们来按照代码第一次进入libuv引擎后的顺序来详细解说这些阶段： poll(轮询阶段) 当个v8引擎将js代码解析后传入libuv引擎后，循环首先进入poll阶段。poll阶段的执行逻辑如下： 先查看poll queue中是否有事件，有任务就按先进先出的顺序依次执行回调。 当queue为空时，会检查是否有setImmediate()的callback，如果有就进入check阶段执行这些callback。但同时也会检查是否有到期的timer，如果有，就把这些到期的timer的callback按照调用顺序放到timer queue中，之后循环会进入timer阶段执行queue中的 callback。 这两者的顺序是不固定的，收到代码运行的环境的影响。如果两者的queue都是空的，那么loop会在poll阶段停留，直到有一个i/o事件返回，循环会进入i/o callback阶段并立即执行这个事件的callback。 值得注意的是，poll阶段在执行poll queue中的回调时实际上不会无限的执行下去。有两种情况poll阶段会终止执行poll queue中的下一个回调：1.所有回调执行完毕。2.执行数超过了node的限制。 check(检查阶段) check阶段专门用来执行setImmediate()方法的回调，当poll阶段进入空闲状态，并且setImmediate queue中有callback时，事件循环进入这个阶段。 close callbacks(关闭事件回调阶段) 当一个socket连接或者一个handle被突然关闭时（例如调用了socket.destroy()方法），close事件会被发送到这个阶段执行回调。否则事件会用process.nextTick（）方法发送出去。 timers(定时器检测阶段) 这个阶段以先进先出的方式执行所有到期的timer加入timer队列里的callback，一个timer callback指得是一个通过setTimeout或者setInterval函数设置的回调函数。 I/O callbacks(I/O事件回调阶段) 如上文所言，这个阶段主要执行大部分I/O事件的回调，包括一些为操作系统执行的回调。例如一个TCP连接生错误时，系统需要执行回调来获得这个错误的报告。 ④ process.nextTick,setTimeout与setImmediate的区别与使用场景 在node中有三个常用的用来推迟任务执行的方法：process.nextTick,setTimeout（setInterval与之相同）与setImmediate 这三者间存在着一些非常不同的区别： process.nextTick() 尽管没有提及，但是实际上node中存在着一个特殊的队列，即nextTick queue。这个队列中的回调执行虽然没有被表示为一个阶段，当时这些事件却会在每一个阶段执行完毕准备进入下一个阶段时优先执行。当事件循环准备进入下一个阶段之前，会先检查nextTick queue中是否有任务，如果有，那么会先清空这个队列。与执行poll queue中的任务不同的是，这个操作在队列清空前是不会停止的。这也就意味着，错误的使用process.nextTick()方法会导致node进入一个死循环。。直到内存泄漏。 使用这个方法比较合适呢？下面有一个例子： const server = net.createServer(() = {}).listen(8080); server.on('listening', () = {}); 这个例子中当，当listen方法被调用时，除非端口被占用，否则会立刻绑定在对应的端口上。这意味着此时这个端口可以立刻触发listening事件并执行其回调。然而，这时候on('listening)还没有将callback设置好，自然没有callback可以执行。为了避免出现这种情况，node会在listen事件中使用process.nextTick()方法，确保事件在回调函数绑定后被触发。 setTimeout()和setImmediate() 在三个方法中，这两个方法最容易被弄混。实际上，某些情况下这两个方法的表现也非常相似。然而实际上，这两个方法的意义却大为不同。 setTimeout()方法是定义一个回调，并且希望这个回调在我们所指定的时间间隔后第一时间去执行。注意这个“第一时间执行”，这意味着，受到操作系统和当前执行任务的诸多影响，该回调并不会在我们预期的时间间隔后精准的执行。执行的时间存在一定的延迟和误差，这是不可避免的。node会在可以执行timer回调的第一时间去执行你所设定的任务。 setImmediate()方法从意义上将是立刻执行的意思，但是实际上它却是在一个固定的阶段才会执行回调，即poll阶段之后。有趣的是，这个名字的意义和之前提到过的process.nextTick()方法才是最匹配的。node的开发者们也清楚这两个方法的命名上存在一定的混淆，他们表示不会把这两个方法的名字调换过来—因为有大量的node程序使用着这两个方法，调换命名所带来的好处与它的影响相比不值一提。 setTimeout()和不设置时间间隔的setImmediate()表现上及其相似。猜猜下面这段代码的结果是什么？ setTimeout(() = { console.log('timeout'); }, 0); setImmediate(() = { console.log('immediate'); }); 实际上，答案是不一定。没错，就连node的开发者都无法准确的判断这两者的顺序谁前谁后。这取决于这段代码的运行环境。运行环境中的各种复杂的情况会导致在同步队列里两个方法的顺序随机决定。但是，在一种情况下可以准确判断两个方法回调的执行顺序，那就是在一个I/O事件的回调中。下面这段代码的顺序永远是固定的： const fs = require('fs'); fs.readFile(__filename, () = { setTimeout(() = { console.l","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:4","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#poll轮询阶段"},{"categories":["前端"],"content":"Ⅳ-node环境下的事件循环机制 不学node的小伙伴就跳过此部分直接去下一节Web Workers笔记吧 ① 与浏览器环境有何不同? 在node中，事件循环表现出的状态与浏览器中大致相同。不同的是node中有一套自己的模型。node中事件循环的实现是依靠的libuv引擎。我们知道node选择chrome v8引擎作为js解释器，v8引擎将js代码分析后去调用对应的node api，而这些api最后则由libuv引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。 因此实际上node中的事件循环存在于libuv引擎中。 ② 事件循环模型 下面是一个libuv引擎中的事件循环的模型: //libuv引擎中的事件循环的模型 ┌───────────────────────┐ ┌─│ timers │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ I/O callbacks │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ idle, prepare │ │ └──────────┬────────────┘ ┌───────────────┐ │ ┌──────────┴────────────┐ │ incoming: │ │ │ poll │轮询阶段(poll)–检查阶段(check)–关闭事件回调阶段(close callback)–定时器检测阶段(timer)–I/O事件回调阶段(I/O callbacks)–闲置阶段(idle, prepare)–轮询阶段… 这些阶段大致的功能如下： timers(定时器检测阶段): 这个阶段执行定时器队列中的回调如 setTimeout() 和 setInterval()。 I/O callbacks(I/O事件回调阶段): 这个阶段执行几乎所有的回调。但是不包括close事件，定时器和setImmediate()的回调。 idle, prepare: 这个阶段仅在内部使用，可以不必理会。 poll(轮询阶段): 等待新的I/O事件，node在一些特殊情况下会阻塞在这里。 check(检查阶段): setImmediate()的回调会在这个阶段执行。 close callbacks(关闭事件回调阶段): 例如socket.on('close', ...)这种close事件的回调。 下面我们来按照代码第一次进入libuv引擎后的顺序来详细解说这些阶段： poll(轮询阶段) 当个v8引擎将js代码解析后传入libuv引擎后，循环首先进入poll阶段。poll阶段的执行逻辑如下： 先查看poll queue中是否有事件，有任务就按先进先出的顺序依次执行回调。 当queue为空时，会检查是否有setImmediate()的callback，如果有就进入check阶段执行这些callback。但同时也会检查是否有到期的timer，如果有，就把这些到期的timer的callback按照调用顺序放到timer queue中，之后循环会进入timer阶段执行queue中的 callback。 这两者的顺序是不固定的，收到代码运行的环境的影响。如果两者的queue都是空的，那么loop会在poll阶段停留，直到有一个i/o事件返回，循环会进入i/o callback阶段并立即执行这个事件的callback。 值得注意的是，poll阶段在执行poll queue中的回调时实际上不会无限的执行下去。有两种情况poll阶段会终止执行poll queue中的下一个回调：1.所有回调执行完毕。2.执行数超过了node的限制。 check(检查阶段) check阶段专门用来执行setImmediate()方法的回调，当poll阶段进入空闲状态，并且setImmediate queue中有callback时，事件循环进入这个阶段。 close callbacks(关闭事件回调阶段) 当一个socket连接或者一个handle被突然关闭时（例如调用了socket.destroy()方法），close事件会被发送到这个阶段执行回调。否则事件会用process.nextTick（）方法发送出去。 timers(定时器检测阶段) 这个阶段以先进先出的方式执行所有到期的timer加入timer队列里的callback，一个timer callback指得是一个通过setTimeout或者setInterval函数设置的回调函数。 I/O callbacks(I/O事件回调阶段) 如上文所言，这个阶段主要执行大部分I/O事件的回调，包括一些为操作系统执行的回调。例如一个TCP连接生错误时，系统需要执行回调来获得这个错误的报告。 ④ process.nextTick,setTimeout与setImmediate的区别与使用场景 在node中有三个常用的用来推迟任务执行的方法：process.nextTick,setTimeout（setInterval与之相同）与setImmediate 这三者间存在着一些非常不同的区别： process.nextTick() 尽管没有提及，但是实际上node中存在着一个特殊的队列，即nextTick queue。这个队列中的回调执行虽然没有被表示为一个阶段，当时这些事件却会在每一个阶段执行完毕准备进入下一个阶段时优先执行。当事件循环准备进入下一个阶段之前，会先检查nextTick queue中是否有任务，如果有，那么会先清空这个队列。与执行poll queue中的任务不同的是，这个操作在队列清空前是不会停止的。这也就意味着，错误的使用process.nextTick()方法会导致node进入一个死循环。。直到内存泄漏。 使用这个方法比较合适呢？下面有一个例子： const server = net.createServer(() = {}).listen(8080); server.on('listening', () = {}); 这个例子中当，当listen方法被调用时，除非端口被占用，否则会立刻绑定在对应的端口上。这意味着此时这个端口可以立刻触发listening事件并执行其回调。然而，这时候on('listening)还没有将callback设置好，自然没有callback可以执行。为了避免出现这种情况，node会在listen事件中使用process.nextTick()方法，确保事件在回调函数绑定后被触发。 setTimeout()和setImmediate() 在三个方法中，这两个方法最容易被弄混。实际上，某些情况下这两个方法的表现也非常相似。然而实际上，这两个方法的意义却大为不同。 setTimeout()方法是定义一个回调，并且希望这个回调在我们所指定的时间间隔后第一时间去执行。注意这个“第一时间执行”，这意味着，受到操作系统和当前执行任务的诸多影响，该回调并不会在我们预期的时间间隔后精准的执行。执行的时间存在一定的延迟和误差，这是不可避免的。node会在可以执行timer回调的第一时间去执行你所设定的任务。 setImmediate()方法从意义上将是立刻执行的意思，但是实际上它却是在一个固定的阶段才会执行回调，即poll阶段之后。有趣的是，这个名字的意义和之前提到过的process.nextTick()方法才是最匹配的。node的开发者们也清楚这两个方法的命名上存在一定的混淆，他们表示不会把这两个方法的名字调换过来—因为有大量的node程序使用着这两个方法，调换命名所带来的好处与它的影响相比不值一提。 setTimeout()和不设置时间间隔的setImmediate()表现上及其相似。猜猜下面这段代码的结果是什么？ setTimeout(() = { console.log('timeout'); }, 0); setImmediate(() = { console.log('immediate'); }); 实际上，答案是不一定。没错，就连node的开发者都无法准确的判断这两者的顺序谁前谁后。这取决于这段代码的运行环境。运行环境中的各种复杂的情况会导致在同步队列里两个方法的顺序随机决定。但是，在一种情况下可以准确判断两个方法回调的执行顺序，那就是在一个I/O事件的回调中。下面这段代码的顺序永远是固定的： const fs = require('fs'); fs.readFile(__filename, () = { setTimeout(() = { console.l","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:4","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#check检查阶段"},{"categories":["前端"],"content":"Ⅳ-node环境下的事件循环机制 不学node的小伙伴就跳过此部分直接去下一节Web Workers笔记吧 ① 与浏览器环境有何不同? 在node中，事件循环表现出的状态与浏览器中大致相同。不同的是node中有一套自己的模型。node中事件循环的实现是依靠的libuv引擎。我们知道node选择chrome v8引擎作为js解释器，v8引擎将js代码分析后去调用对应的node api，而这些api最后则由libuv引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。 因此实际上node中的事件循环存在于libuv引擎中。 ② 事件循环模型 下面是一个libuv引擎中的事件循环的模型: //libuv引擎中的事件循环的模型 ┌───────────────────────┐ ┌─│ timers │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ I/O callbacks │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ idle, prepare │ │ └──────────┬────────────┘ ┌───────────────┐ │ ┌──────────┴────────────┐ │ incoming: │ │ │ poll │轮询阶段(poll)–检查阶段(check)–关闭事件回调阶段(close callback)–定时器检测阶段(timer)–I/O事件回调阶段(I/O callbacks)–闲置阶段(idle, prepare)–轮询阶段… 这些阶段大致的功能如下： timers(定时器检测阶段): 这个阶段执行定时器队列中的回调如 setTimeout() 和 setInterval()。 I/O callbacks(I/O事件回调阶段): 这个阶段执行几乎所有的回调。但是不包括close事件，定时器和setImmediate()的回调。 idle, prepare: 这个阶段仅在内部使用，可以不必理会。 poll(轮询阶段): 等待新的I/O事件，node在一些特殊情况下会阻塞在这里。 check(检查阶段): setImmediate()的回调会在这个阶段执行。 close callbacks(关闭事件回调阶段): 例如socket.on('close', ...)这种close事件的回调。 下面我们来按照代码第一次进入libuv引擎后的顺序来详细解说这些阶段： poll(轮询阶段) 当个v8引擎将js代码解析后传入libuv引擎后，循环首先进入poll阶段。poll阶段的执行逻辑如下： 先查看poll queue中是否有事件，有任务就按先进先出的顺序依次执行回调。 当queue为空时，会检查是否有setImmediate()的callback，如果有就进入check阶段执行这些callback。但同时也会检查是否有到期的timer，如果有，就把这些到期的timer的callback按照调用顺序放到timer queue中，之后循环会进入timer阶段执行queue中的 callback。 这两者的顺序是不固定的，收到代码运行的环境的影响。如果两者的queue都是空的，那么loop会在poll阶段停留，直到有一个i/o事件返回，循环会进入i/o callback阶段并立即执行这个事件的callback。 值得注意的是，poll阶段在执行poll queue中的回调时实际上不会无限的执行下去。有两种情况poll阶段会终止执行poll queue中的下一个回调：1.所有回调执行完毕。2.执行数超过了node的限制。 check(检查阶段) check阶段专门用来执行setImmediate()方法的回调，当poll阶段进入空闲状态，并且setImmediate queue中有callback时，事件循环进入这个阶段。 close callbacks(关闭事件回调阶段) 当一个socket连接或者一个handle被突然关闭时（例如调用了socket.destroy()方法），close事件会被发送到这个阶段执行回调。否则事件会用process.nextTick（）方法发送出去。 timers(定时器检测阶段) 这个阶段以先进先出的方式执行所有到期的timer加入timer队列里的callback，一个timer callback指得是一个通过setTimeout或者setInterval函数设置的回调函数。 I/O callbacks(I/O事件回调阶段) 如上文所言，这个阶段主要执行大部分I/O事件的回调，包括一些为操作系统执行的回调。例如一个TCP连接生错误时，系统需要执行回调来获得这个错误的报告。 ④ process.nextTick,setTimeout与setImmediate的区别与使用场景 在node中有三个常用的用来推迟任务执行的方法：process.nextTick,setTimeout（setInterval与之相同）与setImmediate 这三者间存在着一些非常不同的区别： process.nextTick() 尽管没有提及，但是实际上node中存在着一个特殊的队列，即nextTick queue。这个队列中的回调执行虽然没有被表示为一个阶段，当时这些事件却会在每一个阶段执行完毕准备进入下一个阶段时优先执行。当事件循环准备进入下一个阶段之前，会先检查nextTick queue中是否有任务，如果有，那么会先清空这个队列。与执行poll queue中的任务不同的是，这个操作在队列清空前是不会停止的。这也就意味着，错误的使用process.nextTick()方法会导致node进入一个死循环。。直到内存泄漏。 使用这个方法比较合适呢？下面有一个例子： const server = net.createServer(() = {}).listen(8080); server.on('listening', () = {}); 这个例子中当，当listen方法被调用时，除非端口被占用，否则会立刻绑定在对应的端口上。这意味着此时这个端口可以立刻触发listening事件并执行其回调。然而，这时候on('listening)还没有将callback设置好，自然没有callback可以执行。为了避免出现这种情况，node会在listen事件中使用process.nextTick()方法，确保事件在回调函数绑定后被触发。 setTimeout()和setImmediate() 在三个方法中，这两个方法最容易被弄混。实际上，某些情况下这两个方法的表现也非常相似。然而实际上，这两个方法的意义却大为不同。 setTimeout()方法是定义一个回调，并且希望这个回调在我们所指定的时间间隔后第一时间去执行。注意这个“第一时间执行”，这意味着，受到操作系统和当前执行任务的诸多影响，该回调并不会在我们预期的时间间隔后精准的执行。执行的时间存在一定的延迟和误差，这是不可避免的。node会在可以执行timer回调的第一时间去执行你所设定的任务。 setImmediate()方法从意义上将是立刻执行的意思，但是实际上它却是在一个固定的阶段才会执行回调，即poll阶段之后。有趣的是，这个名字的意义和之前提到过的process.nextTick()方法才是最匹配的。node的开发者们也清楚这两个方法的命名上存在一定的混淆，他们表示不会把这两个方法的名字调换过来—因为有大量的node程序使用着这两个方法，调换命名所带来的好处与它的影响相比不值一提。 setTimeout()和不设置时间间隔的setImmediate()表现上及其相似。猜猜下面这段代码的结果是什么？ setTimeout(() = { console.log('timeout'); }, 0); setImmediate(() = { console.log('immediate'); }); 实际上，答案是不一定。没错，就连node的开发者都无法准确的判断这两者的顺序谁前谁后。这取决于这段代码的运行环境。运行环境中的各种复杂的情况会导致在同步队列里两个方法的顺序随机决定。但是，在一种情况下可以准确判断两个方法回调的执行顺序，那就是在一个I/O事件的回调中。下面这段代码的顺序永远是固定的： const fs = require('fs'); fs.readFile(__filename, () = { setTimeout(() = { console.l","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:4","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#close-callbacks关闭事件回调阶段"},{"categories":["前端"],"content":"Ⅳ-node环境下的事件循环机制 不学node的小伙伴就跳过此部分直接去下一节Web Workers笔记吧 ① 与浏览器环境有何不同? 在node中，事件循环表现出的状态与浏览器中大致相同。不同的是node中有一套自己的模型。node中事件循环的实现是依靠的libuv引擎。我们知道node选择chrome v8引擎作为js解释器，v8引擎将js代码分析后去调用对应的node api，而这些api最后则由libuv引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。 因此实际上node中的事件循环存在于libuv引擎中。 ② 事件循环模型 下面是一个libuv引擎中的事件循环的模型: //libuv引擎中的事件循环的模型 ┌───────────────────────┐ ┌─│ timers │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ I/O callbacks │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ idle, prepare │ │ └──────────┬────────────┘ ┌───────────────┐ │ ┌──────────┴────────────┐ │ incoming: │ │ │ poll │轮询阶段(poll)–检查阶段(check)–关闭事件回调阶段(close callback)–定时器检测阶段(timer)–I/O事件回调阶段(I/O callbacks)–闲置阶段(idle, prepare)–轮询阶段… 这些阶段大致的功能如下： timers(定时器检测阶段): 这个阶段执行定时器队列中的回调如 setTimeout() 和 setInterval()。 I/O callbacks(I/O事件回调阶段): 这个阶段执行几乎所有的回调。但是不包括close事件，定时器和setImmediate()的回调。 idle, prepare: 这个阶段仅在内部使用，可以不必理会。 poll(轮询阶段): 等待新的I/O事件，node在一些特殊情况下会阻塞在这里。 check(检查阶段): setImmediate()的回调会在这个阶段执行。 close callbacks(关闭事件回调阶段): 例如socket.on('close', ...)这种close事件的回调。 下面我们来按照代码第一次进入libuv引擎后的顺序来详细解说这些阶段： poll(轮询阶段) 当个v8引擎将js代码解析后传入libuv引擎后，循环首先进入poll阶段。poll阶段的执行逻辑如下： 先查看poll queue中是否有事件，有任务就按先进先出的顺序依次执行回调。 当queue为空时，会检查是否有setImmediate()的callback，如果有就进入check阶段执行这些callback。但同时也会检查是否有到期的timer，如果有，就把这些到期的timer的callback按照调用顺序放到timer queue中，之后循环会进入timer阶段执行queue中的 callback。 这两者的顺序是不固定的，收到代码运行的环境的影响。如果两者的queue都是空的，那么loop会在poll阶段停留，直到有一个i/o事件返回，循环会进入i/o callback阶段并立即执行这个事件的callback。 值得注意的是，poll阶段在执行poll queue中的回调时实际上不会无限的执行下去。有两种情况poll阶段会终止执行poll queue中的下一个回调：1.所有回调执行完毕。2.执行数超过了node的限制。 check(检查阶段) check阶段专门用来执行setImmediate()方法的回调，当poll阶段进入空闲状态，并且setImmediate queue中有callback时，事件循环进入这个阶段。 close callbacks(关闭事件回调阶段) 当一个socket连接或者一个handle被突然关闭时（例如调用了socket.destroy()方法），close事件会被发送到这个阶段执行回调。否则事件会用process.nextTick（）方法发送出去。 timers(定时器检测阶段) 这个阶段以先进先出的方式执行所有到期的timer加入timer队列里的callback，一个timer callback指得是一个通过setTimeout或者setInterval函数设置的回调函数。 I/O callbacks(I/O事件回调阶段) 如上文所言，这个阶段主要执行大部分I/O事件的回调，包括一些为操作系统执行的回调。例如一个TCP连接生错误时，系统需要执行回调来获得这个错误的报告。 ④ process.nextTick,setTimeout与setImmediate的区别与使用场景 在node中有三个常用的用来推迟任务执行的方法：process.nextTick,setTimeout（setInterval与之相同）与setImmediate 这三者间存在着一些非常不同的区别： process.nextTick() 尽管没有提及，但是实际上node中存在着一个特殊的队列，即nextTick queue。这个队列中的回调执行虽然没有被表示为一个阶段，当时这些事件却会在每一个阶段执行完毕准备进入下一个阶段时优先执行。当事件循环准备进入下一个阶段之前，会先检查nextTick queue中是否有任务，如果有，那么会先清空这个队列。与执行poll queue中的任务不同的是，这个操作在队列清空前是不会停止的。这也就意味着，错误的使用process.nextTick()方法会导致node进入一个死循环。。直到内存泄漏。 使用这个方法比较合适呢？下面有一个例子： const server = net.createServer(() = {}).listen(8080); server.on('listening', () = {}); 这个例子中当，当listen方法被调用时，除非端口被占用，否则会立刻绑定在对应的端口上。这意味着此时这个端口可以立刻触发listening事件并执行其回调。然而，这时候on('listening)还没有将callback设置好，自然没有callback可以执行。为了避免出现这种情况，node会在listen事件中使用process.nextTick()方法，确保事件在回调函数绑定后被触发。 setTimeout()和setImmediate() 在三个方法中，这两个方法最容易被弄混。实际上，某些情况下这两个方法的表现也非常相似。然而实际上，这两个方法的意义却大为不同。 setTimeout()方法是定义一个回调，并且希望这个回调在我们所指定的时间间隔后第一时间去执行。注意这个“第一时间执行”，这意味着，受到操作系统和当前执行任务的诸多影响，该回调并不会在我们预期的时间间隔后精准的执行。执行的时间存在一定的延迟和误差，这是不可避免的。node会在可以执行timer回调的第一时间去执行你所设定的任务。 setImmediate()方法从意义上将是立刻执行的意思，但是实际上它却是在一个固定的阶段才会执行回调，即poll阶段之后。有趣的是，这个名字的意义和之前提到过的process.nextTick()方法才是最匹配的。node的开发者们也清楚这两个方法的命名上存在一定的混淆，他们表示不会把这两个方法的名字调换过来—因为有大量的node程序使用着这两个方法，调换命名所带来的好处与它的影响相比不值一提。 setTimeout()和不设置时间间隔的setImmediate()表现上及其相似。猜猜下面这段代码的结果是什么？ setTimeout(() = { console.log('timeout'); }, 0); setImmediate(() = { console.log('immediate'); }); 实际上，答案是不一定。没错，就连node的开发者都无法准确的判断这两者的顺序谁前谁后。这取决于这段代码的运行环境。运行环境中的各种复杂的情况会导致在同步队列里两个方法的顺序随机决定。但是，在一种情况下可以准确判断两个方法回调的执行顺序，那就是在一个I/O事件的回调中。下面这段代码的顺序永远是固定的： const fs = require('fs'); fs.readFile(__filename, () = { setTimeout(() = { console.l","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:4","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#timers定时器检测阶段"},{"categories":["前端"],"content":"Ⅳ-node环境下的事件循环机制 不学node的小伙伴就跳过此部分直接去下一节Web Workers笔记吧 ① 与浏览器环境有何不同? 在node中，事件循环表现出的状态与浏览器中大致相同。不同的是node中有一套自己的模型。node中事件循环的实现是依靠的libuv引擎。我们知道node选择chrome v8引擎作为js解释器，v8引擎将js代码分析后去调用对应的node api，而这些api最后则由libuv引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。 因此实际上node中的事件循环存在于libuv引擎中。 ② 事件循环模型 下面是一个libuv引擎中的事件循环的模型: //libuv引擎中的事件循环的模型 ┌───────────────────────┐ ┌─│ timers │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ I/O callbacks │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ idle, prepare │ │ └──────────┬────────────┘ ┌───────────────┐ │ ┌──────────┴────────────┐ │ incoming: │ │ │ poll │轮询阶段(poll)–检查阶段(check)–关闭事件回调阶段(close callback)–定时器检测阶段(timer)–I/O事件回调阶段(I/O callbacks)–闲置阶段(idle, prepare)–轮询阶段… 这些阶段大致的功能如下： timers(定时器检测阶段): 这个阶段执行定时器队列中的回调如 setTimeout() 和 setInterval()。 I/O callbacks(I/O事件回调阶段): 这个阶段执行几乎所有的回调。但是不包括close事件，定时器和setImmediate()的回调。 idle, prepare: 这个阶段仅在内部使用，可以不必理会。 poll(轮询阶段): 等待新的I/O事件，node在一些特殊情况下会阻塞在这里。 check(检查阶段): setImmediate()的回调会在这个阶段执行。 close callbacks(关闭事件回调阶段): 例如socket.on('close', ...)这种close事件的回调。 下面我们来按照代码第一次进入libuv引擎后的顺序来详细解说这些阶段： poll(轮询阶段) 当个v8引擎将js代码解析后传入libuv引擎后，循环首先进入poll阶段。poll阶段的执行逻辑如下： 先查看poll queue中是否有事件，有任务就按先进先出的顺序依次执行回调。 当queue为空时，会检查是否有setImmediate()的callback，如果有就进入check阶段执行这些callback。但同时也会检查是否有到期的timer，如果有，就把这些到期的timer的callback按照调用顺序放到timer queue中，之后循环会进入timer阶段执行queue中的 callback。 这两者的顺序是不固定的，收到代码运行的环境的影响。如果两者的queue都是空的，那么loop会在poll阶段停留，直到有一个i/o事件返回，循环会进入i/o callback阶段并立即执行这个事件的callback。 值得注意的是，poll阶段在执行poll queue中的回调时实际上不会无限的执行下去。有两种情况poll阶段会终止执行poll queue中的下一个回调：1.所有回调执行完毕。2.执行数超过了node的限制。 check(检查阶段) check阶段专门用来执行setImmediate()方法的回调，当poll阶段进入空闲状态，并且setImmediate queue中有callback时，事件循环进入这个阶段。 close callbacks(关闭事件回调阶段) 当一个socket连接或者一个handle被突然关闭时（例如调用了socket.destroy()方法），close事件会被发送到这个阶段执行回调。否则事件会用process.nextTick（）方法发送出去。 timers(定时器检测阶段) 这个阶段以先进先出的方式执行所有到期的timer加入timer队列里的callback，一个timer callback指得是一个通过setTimeout或者setInterval函数设置的回调函数。 I/O callbacks(I/O事件回调阶段) 如上文所言，这个阶段主要执行大部分I/O事件的回调，包括一些为操作系统执行的回调。例如一个TCP连接生错误时，系统需要执行回调来获得这个错误的报告。 ④ process.nextTick,setTimeout与setImmediate的区别与使用场景 在node中有三个常用的用来推迟任务执行的方法：process.nextTick,setTimeout（setInterval与之相同）与setImmediate 这三者间存在着一些非常不同的区别： process.nextTick() 尽管没有提及，但是实际上node中存在着一个特殊的队列，即nextTick queue。这个队列中的回调执行虽然没有被表示为一个阶段，当时这些事件却会在每一个阶段执行完毕准备进入下一个阶段时优先执行。当事件循环准备进入下一个阶段之前，会先检查nextTick queue中是否有任务，如果有，那么会先清空这个队列。与执行poll queue中的任务不同的是，这个操作在队列清空前是不会停止的。这也就意味着，错误的使用process.nextTick()方法会导致node进入一个死循环。。直到内存泄漏。 使用这个方法比较合适呢？下面有一个例子： const server = net.createServer(() = {}).listen(8080); server.on('listening', () = {}); 这个例子中当，当listen方法被调用时，除非端口被占用，否则会立刻绑定在对应的端口上。这意味着此时这个端口可以立刻触发listening事件并执行其回调。然而，这时候on('listening)还没有将callback设置好，自然没有callback可以执行。为了避免出现这种情况，node会在listen事件中使用process.nextTick()方法，确保事件在回调函数绑定后被触发。 setTimeout()和setImmediate() 在三个方法中，这两个方法最容易被弄混。实际上，某些情况下这两个方法的表现也非常相似。然而实际上，这两个方法的意义却大为不同。 setTimeout()方法是定义一个回调，并且希望这个回调在我们所指定的时间间隔后第一时间去执行。注意这个“第一时间执行”，这意味着，受到操作系统和当前执行任务的诸多影响，该回调并不会在我们预期的时间间隔后精准的执行。执行的时间存在一定的延迟和误差，这是不可避免的。node会在可以执行timer回调的第一时间去执行你所设定的任务。 setImmediate()方法从意义上将是立刻执行的意思，但是实际上它却是在一个固定的阶段才会执行回调，即poll阶段之后。有趣的是，这个名字的意义和之前提到过的process.nextTick()方法才是最匹配的。node的开发者们也清楚这两个方法的命名上存在一定的混淆，他们表示不会把这两个方法的名字调换过来—因为有大量的node程序使用着这两个方法，调换命名所带来的好处与它的影响相比不值一提。 setTimeout()和不设置时间间隔的setImmediate()表现上及其相似。猜猜下面这段代码的结果是什么？ setTimeout(() = { console.log('timeout'); }, 0); setImmediate(() = { console.log('immediate'); }); 实际上，答案是不一定。没错，就连node的开发者都无法准确的判断这两者的顺序谁前谁后。这取决于这段代码的运行环境。运行环境中的各种复杂的情况会导致在同步队列里两个方法的顺序随机决定。但是，在一种情况下可以准确判断两个方法回调的执行顺序，那就是在一个I/O事件的回调中。下面这段代码的顺序永远是固定的： const fs = require('fs'); fs.readFile(__filename, () = { setTimeout(() = { console.l","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:4","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#io-callbacksio事件回调阶段"},{"categories":["前端"],"content":"Ⅳ-node环境下的事件循环机制 不学node的小伙伴就跳过此部分直接去下一节Web Workers笔记吧 ① 与浏览器环境有何不同? 在node中，事件循环表现出的状态与浏览器中大致相同。不同的是node中有一套自己的模型。node中事件循环的实现是依靠的libuv引擎。我们知道node选择chrome v8引擎作为js解释器，v8引擎将js代码分析后去调用对应的node api，而这些api最后则由libuv引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。 因此实际上node中的事件循环存在于libuv引擎中。 ② 事件循环模型 下面是一个libuv引擎中的事件循环的模型: //libuv引擎中的事件循环的模型 ┌───────────────────────┐ ┌─│ timers │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ I/O callbacks │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ idle, prepare │ │ └──────────┬────────────┘ ┌───────────────┐ │ ┌──────────┴────────────┐ │ incoming: │ │ │ poll │轮询阶段(poll)–检查阶段(check)–关闭事件回调阶段(close callback)–定时器检测阶段(timer)–I/O事件回调阶段(I/O callbacks)–闲置阶段(idle, prepare)–轮询阶段… 这些阶段大致的功能如下： timers(定时器检测阶段): 这个阶段执行定时器队列中的回调如 setTimeout() 和 setInterval()。 I/O callbacks(I/O事件回调阶段): 这个阶段执行几乎所有的回调。但是不包括close事件，定时器和setImmediate()的回调。 idle, prepare: 这个阶段仅在内部使用，可以不必理会。 poll(轮询阶段): 等待新的I/O事件，node在一些特殊情况下会阻塞在这里。 check(检查阶段): setImmediate()的回调会在这个阶段执行。 close callbacks(关闭事件回调阶段): 例如socket.on('close', ...)这种close事件的回调。 下面我们来按照代码第一次进入libuv引擎后的顺序来详细解说这些阶段： poll(轮询阶段) 当个v8引擎将js代码解析后传入libuv引擎后，循环首先进入poll阶段。poll阶段的执行逻辑如下： 先查看poll queue中是否有事件，有任务就按先进先出的顺序依次执行回调。 当queue为空时，会检查是否有setImmediate()的callback，如果有就进入check阶段执行这些callback。但同时也会检查是否有到期的timer，如果有，就把这些到期的timer的callback按照调用顺序放到timer queue中，之后循环会进入timer阶段执行queue中的 callback。 这两者的顺序是不固定的，收到代码运行的环境的影响。如果两者的queue都是空的，那么loop会在poll阶段停留，直到有一个i/o事件返回，循环会进入i/o callback阶段并立即执行这个事件的callback。 值得注意的是，poll阶段在执行poll queue中的回调时实际上不会无限的执行下去。有两种情况poll阶段会终止执行poll queue中的下一个回调：1.所有回调执行完毕。2.执行数超过了node的限制。 check(检查阶段) check阶段专门用来执行setImmediate()方法的回调，当poll阶段进入空闲状态，并且setImmediate queue中有callback时，事件循环进入这个阶段。 close callbacks(关闭事件回调阶段) 当一个socket连接或者一个handle被突然关闭时（例如调用了socket.destroy()方法），close事件会被发送到这个阶段执行回调。否则事件会用process.nextTick（）方法发送出去。 timers(定时器检测阶段) 这个阶段以先进先出的方式执行所有到期的timer加入timer队列里的callback，一个timer callback指得是一个通过setTimeout或者setInterval函数设置的回调函数。 I/O callbacks(I/O事件回调阶段) 如上文所言，这个阶段主要执行大部分I/O事件的回调，包括一些为操作系统执行的回调。例如一个TCP连接生错误时，系统需要执行回调来获得这个错误的报告。 ④ process.nextTick,setTimeout与setImmediate的区别与使用场景 在node中有三个常用的用来推迟任务执行的方法：process.nextTick,setTimeout（setInterval与之相同）与setImmediate 这三者间存在着一些非常不同的区别： process.nextTick() 尽管没有提及，但是实际上node中存在着一个特殊的队列，即nextTick queue。这个队列中的回调执行虽然没有被表示为一个阶段，当时这些事件却会在每一个阶段执行完毕准备进入下一个阶段时优先执行。当事件循环准备进入下一个阶段之前，会先检查nextTick queue中是否有任务，如果有，那么会先清空这个队列。与执行poll queue中的任务不同的是，这个操作在队列清空前是不会停止的。这也就意味着，错误的使用process.nextTick()方法会导致node进入一个死循环。。直到内存泄漏。 使用这个方法比较合适呢？下面有一个例子： const server = net.createServer(() = {}).listen(8080); server.on('listening', () = {}); 这个例子中当，当listen方法被调用时，除非端口被占用，否则会立刻绑定在对应的端口上。这意味着此时这个端口可以立刻触发listening事件并执行其回调。然而，这时候on('listening)还没有将callback设置好，自然没有callback可以执行。为了避免出现这种情况，node会在listen事件中使用process.nextTick()方法，确保事件在回调函数绑定后被触发。 setTimeout()和setImmediate() 在三个方法中，这两个方法最容易被弄混。实际上，某些情况下这两个方法的表现也非常相似。然而实际上，这两个方法的意义却大为不同。 setTimeout()方法是定义一个回调，并且希望这个回调在我们所指定的时间间隔后第一时间去执行。注意这个“第一时间执行”，这意味着，受到操作系统和当前执行任务的诸多影响，该回调并不会在我们预期的时间间隔后精准的执行。执行的时间存在一定的延迟和误差，这是不可避免的。node会在可以执行timer回调的第一时间去执行你所设定的任务。 setImmediate()方法从意义上将是立刻执行的意思，但是实际上它却是在一个固定的阶段才会执行回调，即poll阶段之后。有趣的是，这个名字的意义和之前提到过的process.nextTick()方法才是最匹配的。node的开发者们也清楚这两个方法的命名上存在一定的混淆，他们表示不会把这两个方法的名字调换过来—因为有大量的node程序使用着这两个方法，调换命名所带来的好处与它的影响相比不值一提。 setTimeout()和不设置时间间隔的setImmediate()表现上及其相似。猜猜下面这段代码的结果是什么？ setTimeout(() = { console.log('timeout'); }, 0); setImmediate(() = { console.log('immediate'); }); 实际上，答案是不一定。没错，就连node的开发者都无法准确的判断这两者的顺序谁前谁后。这取决于这段代码的运行环境。运行环境中的各种复杂的情况会导致在同步队列里两个方法的顺序随机决定。但是，在一种情况下可以准确判断两个方法回调的执行顺序，那就是在一个I/O事件的回调中。下面这段代码的顺序永远是固定的： const fs = require('fs'); fs.readFile(__filename, () = { setTimeout(() = { console.l","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:4","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-processnextticksettimeout与setimmediate的区别与使用场景"},{"categories":["前端"],"content":"Ⅳ-node环境下的事件循环机制 不学node的小伙伴就跳过此部分直接去下一节Web Workers笔记吧 ① 与浏览器环境有何不同? 在node中，事件循环表现出的状态与浏览器中大致相同。不同的是node中有一套自己的模型。node中事件循环的实现是依靠的libuv引擎。我们知道node选择chrome v8引擎作为js解释器，v8引擎将js代码分析后去调用对应的node api，而这些api最后则由libuv引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。 因此实际上node中的事件循环存在于libuv引擎中。 ② 事件循环模型 下面是一个libuv引擎中的事件循环的模型: //libuv引擎中的事件循环的模型 ┌───────────────────────┐ ┌─│ timers │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ I/O callbacks │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ idle, prepare │ │ └──────────┬────────────┘ ┌───────────────┐ │ ┌──────────┴────────────┐ │ incoming: │ │ │ poll │轮询阶段(poll)–检查阶段(check)–关闭事件回调阶段(close callback)–定时器检测阶段(timer)–I/O事件回调阶段(I/O callbacks)–闲置阶段(idle, prepare)–轮询阶段… 这些阶段大致的功能如下： timers(定时器检测阶段): 这个阶段执行定时器队列中的回调如 setTimeout() 和 setInterval()。 I/O callbacks(I/O事件回调阶段): 这个阶段执行几乎所有的回调。但是不包括close事件，定时器和setImmediate()的回调。 idle, prepare: 这个阶段仅在内部使用，可以不必理会。 poll(轮询阶段): 等待新的I/O事件，node在一些特殊情况下会阻塞在这里。 check(检查阶段): setImmediate()的回调会在这个阶段执行。 close callbacks(关闭事件回调阶段): 例如socket.on('close', ...)这种close事件的回调。 下面我们来按照代码第一次进入libuv引擎后的顺序来详细解说这些阶段： poll(轮询阶段) 当个v8引擎将js代码解析后传入libuv引擎后，循环首先进入poll阶段。poll阶段的执行逻辑如下： 先查看poll queue中是否有事件，有任务就按先进先出的顺序依次执行回调。 当queue为空时，会检查是否有setImmediate()的callback，如果有就进入check阶段执行这些callback。但同时也会检查是否有到期的timer，如果有，就把这些到期的timer的callback按照调用顺序放到timer queue中，之后循环会进入timer阶段执行queue中的 callback。 这两者的顺序是不固定的，收到代码运行的环境的影响。如果两者的queue都是空的，那么loop会在poll阶段停留，直到有一个i/o事件返回，循环会进入i/o callback阶段并立即执行这个事件的callback。 值得注意的是，poll阶段在执行poll queue中的回调时实际上不会无限的执行下去。有两种情况poll阶段会终止执行poll queue中的下一个回调：1.所有回调执行完毕。2.执行数超过了node的限制。 check(检查阶段) check阶段专门用来执行setImmediate()方法的回调，当poll阶段进入空闲状态，并且setImmediate queue中有callback时，事件循环进入这个阶段。 close callbacks(关闭事件回调阶段) 当一个socket连接或者一个handle被突然关闭时（例如调用了socket.destroy()方法），close事件会被发送到这个阶段执行回调。否则事件会用process.nextTick（）方法发送出去。 timers(定时器检测阶段) 这个阶段以先进先出的方式执行所有到期的timer加入timer队列里的callback，一个timer callback指得是一个通过setTimeout或者setInterval函数设置的回调函数。 I/O callbacks(I/O事件回调阶段) 如上文所言，这个阶段主要执行大部分I/O事件的回调，包括一些为操作系统执行的回调。例如一个TCP连接生错误时，系统需要执行回调来获得这个错误的报告。 ④ process.nextTick,setTimeout与setImmediate的区别与使用场景 在node中有三个常用的用来推迟任务执行的方法：process.nextTick,setTimeout（setInterval与之相同）与setImmediate 这三者间存在着一些非常不同的区别： process.nextTick() 尽管没有提及，但是实际上node中存在着一个特殊的队列，即nextTick queue。这个队列中的回调执行虽然没有被表示为一个阶段，当时这些事件却会在每一个阶段执行完毕准备进入下一个阶段时优先执行。当事件循环准备进入下一个阶段之前，会先检查nextTick queue中是否有任务，如果有，那么会先清空这个队列。与执行poll queue中的任务不同的是，这个操作在队列清空前是不会停止的。这也就意味着，错误的使用process.nextTick()方法会导致node进入一个死循环。。直到内存泄漏。 使用这个方法比较合适呢？下面有一个例子： const server = net.createServer(() = {}).listen(8080); server.on('listening', () = {}); 这个例子中当，当listen方法被调用时，除非端口被占用，否则会立刻绑定在对应的端口上。这意味着此时这个端口可以立刻触发listening事件并执行其回调。然而，这时候on('listening)还没有将callback设置好，自然没有callback可以执行。为了避免出现这种情况，node会在listen事件中使用process.nextTick()方法，确保事件在回调函数绑定后被触发。 setTimeout()和setImmediate() 在三个方法中，这两个方法最容易被弄混。实际上，某些情况下这两个方法的表现也非常相似。然而实际上，这两个方法的意义却大为不同。 setTimeout()方法是定义一个回调，并且希望这个回调在我们所指定的时间间隔后第一时间去执行。注意这个“第一时间执行”，这意味着，受到操作系统和当前执行任务的诸多影响，该回调并不会在我们预期的时间间隔后精准的执行。执行的时间存在一定的延迟和误差，这是不可避免的。node会在可以执行timer回调的第一时间去执行你所设定的任务。 setImmediate()方法从意义上将是立刻执行的意思，但是实际上它却是在一个固定的阶段才会执行回调，即poll阶段之后。有趣的是，这个名字的意义和之前提到过的process.nextTick()方法才是最匹配的。node的开发者们也清楚这两个方法的命名上存在一定的混淆，他们表示不会把这两个方法的名字调换过来—因为有大量的node程序使用着这两个方法，调换命名所带来的好处与它的影响相比不值一提。 setTimeout()和不设置时间间隔的setImmediate()表现上及其相似。猜猜下面这段代码的结果是什么？ setTimeout(() = { console.log('timeout'); }, 0); setImmediate(() = { console.log('immediate'); }); 实际上，答案是不一定。没错，就连node的开发者都无法准确的判断这两者的顺序谁前谁后。这取决于这段代码的运行环境。运行环境中的各种复杂的情况会导致在同步队列里两个方法的顺序随机决定。但是，在一种情况下可以准确判断两个方法回调的执行顺序，那就是在一个I/O事件的回调中。下面这段代码的顺序永远是固定的： const fs = require('fs'); fs.readFile(__filename, () = { setTimeout(() = { console.l","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:4","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#processnexttick"},{"categories":["前端"],"content":"Ⅳ-node环境下的事件循环机制 不学node的小伙伴就跳过此部分直接去下一节Web Workers笔记吧 ① 与浏览器环境有何不同? 在node中，事件循环表现出的状态与浏览器中大致相同。不同的是node中有一套自己的模型。node中事件循环的实现是依靠的libuv引擎。我们知道node选择chrome v8引擎作为js解释器，v8引擎将js代码分析后去调用对应的node api，而这些api最后则由libuv引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。 因此实际上node中的事件循环存在于libuv引擎中。 ② 事件循环模型 下面是一个libuv引擎中的事件循环的模型: //libuv引擎中的事件循环的模型 ┌───────────────────────┐ ┌─│ timers │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ I/O callbacks │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ idle, prepare │ │ └──────────┬────────────┘ ┌───────────────┐ │ ┌──────────┴────────────┐ │ incoming: │ │ │ poll │轮询阶段(poll)–检查阶段(check)–关闭事件回调阶段(close callback)–定时器检测阶段(timer)–I/O事件回调阶段(I/O callbacks)–闲置阶段(idle, prepare)–轮询阶段… 这些阶段大致的功能如下： timers(定时器检测阶段): 这个阶段执行定时器队列中的回调如 setTimeout() 和 setInterval()。 I/O callbacks(I/O事件回调阶段): 这个阶段执行几乎所有的回调。但是不包括close事件，定时器和setImmediate()的回调。 idle, prepare: 这个阶段仅在内部使用，可以不必理会。 poll(轮询阶段): 等待新的I/O事件，node在一些特殊情况下会阻塞在这里。 check(检查阶段): setImmediate()的回调会在这个阶段执行。 close callbacks(关闭事件回调阶段): 例如socket.on('close', ...)这种close事件的回调。 下面我们来按照代码第一次进入libuv引擎后的顺序来详细解说这些阶段： poll(轮询阶段) 当个v8引擎将js代码解析后传入libuv引擎后，循环首先进入poll阶段。poll阶段的执行逻辑如下： 先查看poll queue中是否有事件，有任务就按先进先出的顺序依次执行回调。 当queue为空时，会检查是否有setImmediate()的callback，如果有就进入check阶段执行这些callback。但同时也会检查是否有到期的timer，如果有，就把这些到期的timer的callback按照调用顺序放到timer queue中，之后循环会进入timer阶段执行queue中的 callback。 这两者的顺序是不固定的，收到代码运行的环境的影响。如果两者的queue都是空的，那么loop会在poll阶段停留，直到有一个i/o事件返回，循环会进入i/o callback阶段并立即执行这个事件的callback。 值得注意的是，poll阶段在执行poll queue中的回调时实际上不会无限的执行下去。有两种情况poll阶段会终止执行poll queue中的下一个回调：1.所有回调执行完毕。2.执行数超过了node的限制。 check(检查阶段) check阶段专门用来执行setImmediate()方法的回调，当poll阶段进入空闲状态，并且setImmediate queue中有callback时，事件循环进入这个阶段。 close callbacks(关闭事件回调阶段) 当一个socket连接或者一个handle被突然关闭时（例如调用了socket.destroy()方法），close事件会被发送到这个阶段执行回调。否则事件会用process.nextTick（）方法发送出去。 timers(定时器检测阶段) 这个阶段以先进先出的方式执行所有到期的timer加入timer队列里的callback，一个timer callback指得是一个通过setTimeout或者setInterval函数设置的回调函数。 I/O callbacks(I/O事件回调阶段) 如上文所言，这个阶段主要执行大部分I/O事件的回调，包括一些为操作系统执行的回调。例如一个TCP连接生错误时，系统需要执行回调来获得这个错误的报告。 ④ process.nextTick,setTimeout与setImmediate的区别与使用场景 在node中有三个常用的用来推迟任务执行的方法：process.nextTick,setTimeout（setInterval与之相同）与setImmediate 这三者间存在着一些非常不同的区别： process.nextTick() 尽管没有提及，但是实际上node中存在着一个特殊的队列，即nextTick queue。这个队列中的回调执行虽然没有被表示为一个阶段，当时这些事件却会在每一个阶段执行完毕准备进入下一个阶段时优先执行。当事件循环准备进入下一个阶段之前，会先检查nextTick queue中是否有任务，如果有，那么会先清空这个队列。与执行poll queue中的任务不同的是，这个操作在队列清空前是不会停止的。这也就意味着，错误的使用process.nextTick()方法会导致node进入一个死循环。。直到内存泄漏。 使用这个方法比较合适呢？下面有一个例子： const server = net.createServer(() = {}).listen(8080); server.on('listening', () = {}); 这个例子中当，当listen方法被调用时，除非端口被占用，否则会立刻绑定在对应的端口上。这意味着此时这个端口可以立刻触发listening事件并执行其回调。然而，这时候on('listening)还没有将callback设置好，自然没有callback可以执行。为了避免出现这种情况，node会在listen事件中使用process.nextTick()方法，确保事件在回调函数绑定后被触发。 setTimeout()和setImmediate() 在三个方法中，这两个方法最容易被弄混。实际上，某些情况下这两个方法的表现也非常相似。然而实际上，这两个方法的意义却大为不同。 setTimeout()方法是定义一个回调，并且希望这个回调在我们所指定的时间间隔后第一时间去执行。注意这个“第一时间执行”，这意味着，受到操作系统和当前执行任务的诸多影响，该回调并不会在我们预期的时间间隔后精准的执行。执行的时间存在一定的延迟和误差，这是不可避免的。node会在可以执行timer回调的第一时间去执行你所设定的任务。 setImmediate()方法从意义上将是立刻执行的意思，但是实际上它却是在一个固定的阶段才会执行回调，即poll阶段之后。有趣的是，这个名字的意义和之前提到过的process.nextTick()方法才是最匹配的。node的开发者们也清楚这两个方法的命名上存在一定的混淆，他们表示不会把这两个方法的名字调换过来—因为有大量的node程序使用着这两个方法，调换命名所带来的好处与它的影响相比不值一提。 setTimeout()和不设置时间间隔的setImmediate()表现上及其相似。猜猜下面这段代码的结果是什么？ setTimeout(() = { console.log('timeout'); }, 0); setImmediate(() = { console.log('immediate'); }); 实际上，答案是不一定。没错，就连node的开发者都无法准确的判断这两者的顺序谁前谁后。这取决于这段代码的运行环境。运行环境中的各种复杂的情况会导致在同步队列里两个方法的顺序随机决定。但是，在一种情况下可以准确判断两个方法回调的执行顺序，那就是在一个I/O事件的回调中。下面这段代码的顺序永远是固定的： const fs = require('fs'); fs.readFile(__filename, () = { setTimeout(() = { console.l","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:5:4","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#settimeout和setimmediate"},{"categories":["前端"],"content":"5、Web Workers 想了解更多可以点击链接查看更多,此处只是大致了解学习 –\u003eWeb Workers H5规范提供了js分线程的实现, 取名为: Web Workers 相关API Worker: 构造函数, 加载分线程执行的js文件 Worker.prototype.onmessage: 用于接收另一个线程的回调函数 Worker.prototype.postMessage: 向另一个线程发送消息 不足 worker内代码不能操作DOM(更新UI) 不能跨域加载JS 不是每个浏览器都支持这个新特性 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:6:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#5web-workers"},{"categories":["前端"],"content":"Ⅰ-抛砖引玉,引出用处 还是拿斐波那契（Fibonacci）数列来做例子,这东西效率低,可以拿来模拟 \u003cbody\u003e \u003cinput type=\"text\" placeholder=\"数值\" id=\"number\"\u003e \u003cbutton id=\"btn\"\u003e计算\u003c/button\u003e \u003cscript type=\"text/javascript\"\u003e // 1 1 2 3 5 8 f(n) = f(n-1) + f(n-2) function fibonacci(n) { return n\u003c=2 ? 1 : fibonacci(n-1) + fibonacci(n-2) //递归调用 } // console.log(fibonacci(7)) var input = document.getElementById('number') document.getElementById('btn').onclick = function () { var number = input.value var result = fibonacci(number) alert(result) } \u003c/script\u003e 当我运行此行代码,传入计算数值为50左右(有的甚至更低),整个页面就会卡住好久的时间不能操作(计算结束后才会弹窗,但是未弹窗的这段时间用户并不能进行操作),这时候就会发现单线程的弊端了 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:6:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-抛砖引玉引出用处"},{"categories":["前端"],"content":"Ⅱ-尝试使用 H5规范提供了js分线程的实现, 取名为: Web Workers 相关API Worker: 构造函数, 加载分线程执行的js文件 Worker.prototype.onmessage: 用于接收另一个线程的回调函数 Worker.prototype.postMessage: 向另一个线程发送消息 不足 worker内代码不能操作DOM(更新UI) 不能跨域加载JS 不是每个浏览器都支持这个新特性 ① 主线程 创建一个Worker对象 绑定[主线程接收分线程返回的数据]方法 主线程向分线程发送数据,然后等待接受数据 接收到分线程回馈的数据,将数据进行处理(如弹窗) \u003cbody\u003e \u003cinput type=\"text\" placeholder=\"数值\" id=\"number\"\u003e \u003cbutton id=\"btn\"\u003e计算\u003c/button\u003e \u003cscript type=\"text/javascript\"\u003e var input = document.getElementById('number') document.getElementById('btn').onclick = function () { var number = input.value //创建一个Worker对象 var worker = new Worker('worker.js') // 绑定接收消息的监听 worker.onmessage = function (event) { //此处变成回调代码,会在初始化工作完成后才会进行 console.log('主线程接收分线程返回的数据: '+event.data) alert(event.data) } // 向分线程发送消息 worker.postMessage(number) console.log('主线程向分线程发送数据: '+number) } // console.log(this) // window \u003c/script\u003e \u003c/body\u003e ② 分线程 将计算放置分线程中 注意:alert(result) alert是window的方法, 在分线程不能调用,分线程中的全局对象不再是window, 所以在分线程中不可能更新界面 //worker.js function fibonacci(n) { return n\u003c=2 ? 1 : fibonacci(n-1) + fibonacci(n-2) //递归调用 } console.log(this) this.onmessage = function (event) { var number = event.data console.log('分线程接收到主线程发送的数据: '+number) //计算 var result = fibonacci(number) postMessage(result) console.log('分线程向主线程返回数据: '+result) // alert(result) alert是window的方法, 在分线程不能调用 // 分线程中的全局对象不再是window, 所以在分线程中不可能更新界面 } ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:6:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-尝试使用"},{"categories":["前端"],"content":"Ⅱ-尝试使用 H5规范提供了js分线程的实现, 取名为: Web Workers 相关API Worker: 构造函数, 加载分线程执行的js文件 Worker.prototype.onmessage: 用于接收另一个线程的回调函数 Worker.prototype.postMessage: 向另一个线程发送消息 不足 worker内代码不能操作DOM(更新UI) 不能跨域加载JS 不是每个浏览器都支持这个新特性 ① 主线程 创建一个Worker对象 绑定[主线程接收分线程返回的数据]方法 主线程向分线程发送数据,然后等待接受数据 接收到分线程回馈的数据,将数据进行处理(如弹窗) 计算 var input = document.getElementById('number') document.getElementById('btn').onclick = function () { var number = input.value //创建一个Worker对象 var worker = new Worker('worker.js') // 绑定接收消息的监听 worker.onmessage = function (event) { //此处变成回调代码,会在初始化工作完成后才会进行 console.log('主线程接收分线程返回的数据: '+event.data) alert(event.data) } // 向分线程发送消息 worker.postMessage(number) console.log('主线程向分线程发送数据: '+number) } // console.log(this) // window ② 分线程 将计算放置分线程中 注意:alert(result) alert是window的方法, 在分线程不能调用,分线程中的全局对象不再是window, 所以在分线程中不可能更新界面 //worker.js function fibonacci(n) { return n","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:6:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-主线程"},{"categories":["前端"],"content":"Ⅱ-尝试使用 H5规范提供了js分线程的实现, 取名为: Web Workers 相关API Worker: 构造函数, 加载分线程执行的js文件 Worker.prototype.onmessage: 用于接收另一个线程的回调函数 Worker.prototype.postMessage: 向另一个线程发送消息 不足 worker内代码不能操作DOM(更新UI) 不能跨域加载JS 不是每个浏览器都支持这个新特性 ① 主线程 创建一个Worker对象 绑定[主线程接收分线程返回的数据]方法 主线程向分线程发送数据,然后等待接受数据 接收到分线程回馈的数据,将数据进行处理(如弹窗) 计算 var input = document.getElementById('number') document.getElementById('btn').onclick = function () { var number = input.value //创建一个Worker对象 var worker = new Worker('worker.js') // 绑定接收消息的监听 worker.onmessage = function (event) { //此处变成回调代码,会在初始化工作完成后才会进行 console.log('主线程接收分线程返回的数据: '+event.data) alert(event.data) } // 向分线程发送消息 worker.postMessage(number) console.log('主线程向分线程发送数据: '+number) } // console.log(this) // window ② 分线程 将计算放置分线程中 注意:alert(result) alert是window的方法, 在分线程不能调用,分线程中的全局对象不再是window, 所以在分线程中不可能更新界面 //worker.js function fibonacci(n) { return n","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:6:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-分线程"},{"categories":["前端"],"content":"Ⅲ-流程原理图 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/:6:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JS高级","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E7%AB%A0js%E9%AB%98%E7%BA%A7/#-流程原理图"},{"categories":["前端"],"content":"JS的组成JavaScript负责页面中的的行为。 它是一门运行在浏览器端的脚本语言。 JavaScript由三部分组成： ECMAScript：定义JS的编程语法语法和基础核心知识，JavaScript负责实现（还有JSScript语言实现）。 DOM：文档对象模型。是一种标准编程接口，通过DOM提供的接口，可对页面上的各种元素进行操作（大小、颜色、位置等）。 BOM：浏览器对象模型。提供对浏览器窗口进行操作的接口（弹窗、控制浏览器跳转、获取分辨率等）。 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:1:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#js的组成"},{"categories":["前端"],"content":"JS的编写的位置1.可以编写到标签的指定属性中 ，虽然可以写在标签属性中，但是他们属于结构与行为耦合不推荐 \u003cbutton onclick=\"alert('hello');\"\u003e我是按钮\u003c/button\u003e \u003ca href=\"javascript:alert('aaa');\"\u003e超链接\u003c/a\u003e \u003ca href=\"javascript:;\"\u003e超链接\u003c/a\u003e 2.可以编写到script标签中 \u003cscript type=\"text/javascript\"\u003e //编写js代码 \u003c/script\u003e 3.可以将代码编写到外部的js文件中，然后通过标签将其引入 script标签一旦用于引入外部文件了，就不能在编写代码了，即使编写了浏览器也会忽略 ,如果需要则可以在创建一个新的script标签用于编写内部代码 \u003cscript type=\"text/javascript\" src=\"文件路径\"\u003e\u003c/script\u003e ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:2:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#js的编写的位置"},{"categories":["前端"],"content":"输出语句 alert(\"要输出的内容\"); 该语句会在浏览器窗口中弹出一个警告框 document.write(\"要输出的内容\"); 该内容将会被写到body标签中，并在页面中显示 console.log(\"要输出的内容\"); 该内容会被写到开发者工具的控制台中 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:3:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#输出语句"},{"categories":["前端"],"content":"基本的语法js函数声明不需要；分号，但是赋值语句要加；分号 function functionName(arg0,arg1,arg2){ //函数声明 } var functionName=function(arg0,arg1,arg2){ //函数表达式 };(注意分号) 注释 单行注释 //注释内容 多行注释 /* 注释内容 */ JS严格区分大小写 JS中每条语句以分号 ” ; “ 结尾如果不写分号，浏览器会自动添加，但是会消耗一些系统资源， 而且有些时候，浏览器会加错分号，所以在开发中分号必须写 JS中会自动忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化。 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:4:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#基本的语法"},{"categories":["前端"],"content":"字面量和变量","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:5:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#字面量和变量"},{"categories":["前端"],"content":"字面量字面量实际上就是一些固定的值，比如 1 2 3 4 true false null NaN “hello” 字面量都是不可以改变的。 由于字面量不是很方便使用，所以在JS中很少直接使用字面量 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:5:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#字面量"},{"categories":["前端"],"content":"变量变量可以用来保存字面量，并且可以保存任意的字面量 一般都是通过变量来使用字面量，而不直接使用字面量，而且也可以通过变量来对字面量进行一个描述 声明变量 使用var关键字来声明一个变量 var a; 为变量赋值 a = 1; 声明和赋值同时进行 var a = 456; ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:5:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#变量"},{"categories":["前端"],"content":"标识符在JS中所有的可以自主命名的内容，都可以认为是一个标识符， 是标识符就应该遵守标识符的规范。 比如：变量名、函数名、属性名 规范： 标识符中可以含有字母、数字、_、$ 标识符不能以数字开头 标识符不能是JS中的关键字和保留字 标识符一般采用驼峰命名法 xxxYyyZzz JS底层保存标识符时实际上采用的是Unicode编码，所以理论上所有的utf-8中含有的字符都可以作为标识符。 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:5:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#标识符"},{"categories":["前端"],"content":"数据类型","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:0:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#数据类型"},{"categories":["前端"],"content":"六种数据类型JS中一共分成六种数据类型 5个基本数据类型+object String 字符串 Number 数值 Boolean 布尔值 Null 空值 Undefined 未定义 Object 对象 其中前5个是基本数据类型 typeof运算符检查数据类型 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:1:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#六种数据类型"},{"categories":["前端"],"content":"1.String 字符串JS中的字符串需要使用引号引起来双引号或单引号都行 在字符串中使用\\作为转义字符 \\' ==\u003e ' \\\" ==\u003e \" \\n ==\u003e 换行 \\t ==\u003e 制表符 \\\\ ==\u003e \\ typeof 变量名 使用typeof运算符检查字符串时，会返回\"string\" ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:1:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#1string-字符串"},{"categories":["前端"],"content":"2.Number 数值JS中所有的整数和浮点数都是Number类型 最大能表示的值：Number.MAX_VALUE= 1.7976931348623157e+308 特殊的数字：能赋值给变量 Infinity 正无穷 a = Infinity ,能赋值 -Infinity 负无穷 NaN 非法数字（Not A Number） 其他进制的数字的表示： 0b 开头表示二进制，但是不是所有的浏览器都支持 0 开头表示八进制 0x 开头表示十六进制 使用typeof检查一个Number类型的数据时，会返回\"number\"（包括NaN 和 Infinity） 如果使用js进行浮点运算，可能得到一个不精确的结果。 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:1:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#2number-数值"},{"categories":["前端"],"content":"3.Boolean 布尔值布尔值主要用来进行逻辑判断，布尔值只有两个 true 逻辑的真 false 逻辑的假 使用typeof检查一个布尔值时，会返回\"boolean\" ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:1:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#3boolean-布尔值"},{"categories":["前端"],"content":"4.Null 空值空值专门用来表示为空的对象，Null类型的值只有一个 null 使用typeof检查一个Null类型的值时会返回\"object\" ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:1:4","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#4null-空值"},{"categories":["前端"],"content":"5.Undefined 未定义如果声明一个变量但是没有为变量赋值此时变量的值就是undefined 该类型的值只有一个 undefined 使用typeof检查一个Undefined类型的值时，会返回\"undefined\" ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:1:5","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#5undefined-未定义"},{"categories":["前端"],"content":"引用数据类型Object 对象 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:1:6","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#引用数据类型"},{"categories":["前端"],"content":"类型转换类型转换就是指将其他的数据类型，转换为String Number 或 Boolean ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:2:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#类型转换"},{"categories":["前端"],"content":"转换为String方式一（强制类型转换）：调用被转换数据的toString()方法 例子： var a = 123; a = a.toString(); 注意：这个方法不适用于null和undefined 由于这两个类型的数据中没有方法，所以调用toString()时会报错 方式二（强制类型转换）：调用String()函数 例子： var a = 123; a = String(a); 原理：对于Number Boolean String都会调用他们的toString()方法来将其转换为字符串，对于null值，直接转换为字符串\"null\"。对于undefined直接转换为字符串\"undefined\" 方式三（隐式的类型转换）:为任意的数据类型 +\"\" 例子： var a = true; a = a + \"\"; 原理：和String()函数一样 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:2:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#转换为string"},{"categories":["前端"],"content":"转换为String方式一（强制类型转换）：调用被转换数据的toString()方法 例子： var a = 123; a = a.toString(); 注意：这个方法不适用于null和undefined 由于这两个类型的数据中没有方法，所以调用toString()时会报错 方式二（强制类型转换）：调用String()函数 例子： var a = 123; a = String(a); 原理：对于Number Boolean String都会调用他们的toString()方法来将其转换为字符串，对于null值，直接转换为字符串\"null\"。对于undefined直接转换为字符串\"undefined\" 方式三（隐式的类型转换）:为任意的数据类型 +\"\" 例子： var a = true; a = a + \"\"; 原理：和String()函数一样 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:2:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#方式一强制类型转换"},{"categories":["前端"],"content":"转换为String方式一（强制类型转换）：调用被转换数据的toString()方法 例子： var a = 123; a = a.toString(); 注意：这个方法不适用于null和undefined 由于这两个类型的数据中没有方法，所以调用toString()时会报错 方式二（强制类型转换）：调用String()函数 例子： var a = 123; a = String(a); 原理：对于Number Boolean String都会调用他们的toString()方法来将其转换为字符串，对于null值，直接转换为字符串\"null\"。对于undefined直接转换为字符串\"undefined\" 方式三（隐式的类型转换）:为任意的数据类型 +\"\" 例子： var a = true; a = a + \"\"; 原理：和String()函数一样 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:2:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#方式二强制类型转换"},{"categories":["前端"],"content":"转换为String方式一（强制类型转换）：调用被转换数据的toString()方法 例子： var a = 123; a = a.toString(); 注意：这个方法不适用于null和undefined 由于这两个类型的数据中没有方法，所以调用toString()时会报错 方式二（强制类型转换）：调用String()函数 例子： var a = 123; a = String(a); 原理：对于Number Boolean String都会调用他们的toString()方法来将其转换为字符串，对于null值，直接转换为字符串\"null\"。对于undefined直接转换为字符串\"undefined\" 方式三（隐式的类型转换）:为任意的数据类型 +\"\" 例子： var a = true; a = a + \"\"; 原理：和String()函数一样 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:2:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#方式三隐式的类型转换"},{"categories":["前端"],"content":"转换为Number方式一（强制类型转换）：调用Number()函数 例子： var s = \"123\"; s = Number(s); 转换的情况： 字符串 \u003e 数字 如果字符串是一个合法的数字，则直接转换为对应的数字 如果字符串是一个非法的数字，则转换为NaN 如果是一个空串或纯空格的字符串，则转换为0 布尔值 \u003e 数字 true转换为1 false转换为0 空值 \u003e 数字 null转换为0 未定义 \u003e 数字 undefined 转换为NaN 方式二（强制类型转换）：调用parseInt()或parseFloat() 这两个函数专门用来将一个字符串转换为数字的 如果对非String使用parseInt()或parseFloat()，它会先将其转换为String然后在操作 parseInt() 可以将一个字符串中的有效的整数位提取出来，并转换为Number 例子： var a = \"123.456px\"; a = parseInt(a); //123 parseFloat()可以将一个字符串中的有效的小数位提取出来，并转换为Number 例子： var a = \"123.456px\"; a = parseFloat(a); //123.456 其它进制数字转换及注意事项十六进制：0x开头，例如 var a = 0xff 八进制：0开头，例如 var a = “070”，parseInt(a)在部分浏览器中会返回70也可能返回56。 可以在parseInt()中增加一个参数，来指定进制 var a = “070” a = parseInt(a, 10) 方式三（隐式的类型转换）：使用一元的+来进行隐式的类型转换 例子： var a = \"123\"; a = +a; 原理：和Number()函数一样 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:2:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#转换为number"},{"categories":["前端"],"content":"转换为Number方式一（强制类型转换）：调用Number()函数 例子： var s = \"123\"; s = Number(s); 转换的情况： 字符串 数字 如果字符串是一个合法的数字，则直接转换为对应的数字 如果字符串是一个非法的数字，则转换为NaN 如果是一个空串或纯空格的字符串，则转换为0 布尔值 数字 true转换为1 false转换为0 空值 数字 null转换为0 未定义 数字 undefined 转换为NaN 方式二（强制类型转换）：调用parseInt()或parseFloat() 这两个函数专门用来将一个字符串转换为数字的 如果对非String使用parseInt()或parseFloat()，它会先将其转换为String然后在操作 parseInt() 可以将一个字符串中的有效的整数位提取出来，并转换为Number 例子： var a = \"123.456px\"; a = parseInt(a); //123 parseFloat()可以将一个字符串中的有效的小数位提取出来，并转换为Number 例子： var a = \"123.456px\"; a = parseFloat(a); //123.456 其它进制数字转换及注意事项十六进制：0x开头，例如 var a = 0xff 八进制：0开头，例如 var a = “070”，parseInt(a)在部分浏览器中会返回70也可能返回56。 可以在parseInt()中增加一个参数，来指定进制 var a = “070” a = parseInt(a, 10) 方式三（隐式的类型转换）：使用一元的+来进行隐式的类型转换 例子： var a = \"123\"; a = +a; 原理：和Number()函数一样 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:2:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#方式一强制类型转换-1"},{"categories":["前端"],"content":"转换为Number方式一（强制类型转换）：调用Number()函数 例子： var s = \"123\"; s = Number(s); 转换的情况： 字符串 数字 如果字符串是一个合法的数字，则直接转换为对应的数字 如果字符串是一个非法的数字，则转换为NaN 如果是一个空串或纯空格的字符串，则转换为0 布尔值 数字 true转换为1 false转换为0 空值 数字 null转换为0 未定义 数字 undefined 转换为NaN 方式二（强制类型转换）：调用parseInt()或parseFloat() 这两个函数专门用来将一个字符串转换为数字的 如果对非String使用parseInt()或parseFloat()，它会先将其转换为String然后在操作 parseInt() 可以将一个字符串中的有效的整数位提取出来，并转换为Number 例子： var a = \"123.456px\"; a = parseInt(a); //123 parseFloat()可以将一个字符串中的有效的小数位提取出来，并转换为Number 例子： var a = \"123.456px\"; a = parseFloat(a); //123.456 其它进制数字转换及注意事项十六进制：0x开头，例如 var a = 0xff 八进制：0开头，例如 var a = “070”，parseInt(a)在部分浏览器中会返回70也可能返回56。 可以在parseInt()中增加一个参数，来指定进制 var a = “070” a = parseInt(a, 10) 方式三（隐式的类型转换）：使用一元的+来进行隐式的类型转换 例子： var a = \"123\"; a = +a; 原理：和Number()函数一样 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:2:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#方式二强制类型转换-1"},{"categories":["前端"],"content":"转换为Number方式一（强制类型转换）：调用Number()函数 例子： var s = \"123\"; s = Number(s); 转换的情况： 字符串 数字 如果字符串是一个合法的数字，则直接转换为对应的数字 如果字符串是一个非法的数字，则转换为NaN 如果是一个空串或纯空格的字符串，则转换为0 布尔值 数字 true转换为1 false转换为0 空值 数字 null转换为0 未定义 数字 undefined 转换为NaN 方式二（强制类型转换）：调用parseInt()或parseFloat() 这两个函数专门用来将一个字符串转换为数字的 如果对非String使用parseInt()或parseFloat()，它会先将其转换为String然后在操作 parseInt() 可以将一个字符串中的有效的整数位提取出来，并转换为Number 例子： var a = \"123.456px\"; a = parseInt(a); //123 parseFloat()可以将一个字符串中的有效的小数位提取出来，并转换为Number 例子： var a = \"123.456px\"; a = parseFloat(a); //123.456 其它进制数字转换及注意事项十六进制：0x开头，例如 var a = 0xff 八进制：0开头，例如 var a = “070”，parseInt(a)在部分浏览器中会返回70也可能返回56。 可以在parseInt()中增加一个参数，来指定进制 var a = “070” a = parseInt(a, 10) 方式三（隐式的类型转换）：使用一元的+来进行隐式的类型转换 例子： var a = \"123\"; a = +a; 原理：和Number()函数一样 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:2:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#其它进制数字转换及注意事项"},{"categories":["前端"],"content":"转换为Number方式一（强制类型转换）：调用Number()函数 例子： var s = \"123\"; s = Number(s); 转换的情况： 字符串 数字 如果字符串是一个合法的数字，则直接转换为对应的数字 如果字符串是一个非法的数字，则转换为NaN 如果是一个空串或纯空格的字符串，则转换为0 布尔值 数字 true转换为1 false转换为0 空值 数字 null转换为0 未定义 数字 undefined 转换为NaN 方式二（强制类型转换）：调用parseInt()或parseFloat() 这两个函数专门用来将一个字符串转换为数字的 如果对非String使用parseInt()或parseFloat()，它会先将其转换为String然后在操作 parseInt() 可以将一个字符串中的有效的整数位提取出来，并转换为Number 例子： var a = \"123.456px\"; a = parseInt(a); //123 parseFloat()可以将一个字符串中的有效的小数位提取出来，并转换为Number 例子： var a = \"123.456px\"; a = parseFloat(a); //123.456 其它进制数字转换及注意事项十六进制：0x开头，例如 var a = 0xff 八进制：0开头，例如 var a = “070”，parseInt(a)在部分浏览器中会返回70也可能返回56。 可以在parseInt()中增加一个参数，来指定进制 var a = “070” a = parseInt(a, 10) 方式三（隐式的类型转换）：使用一元的+来进行隐式的类型转换 例子： var a = \"123\"; a = +a; 原理：和Number()函数一样 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:2:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#方式三隐式的类型转换-1"},{"categories":["前端"],"content":"转换为布尔值方式一（强制类型转换）：使用Boolean()函数 例子： var s = \"false\"; s = Boolean(s); //true 转换的情况 字符串 \u003e 布尔 除了空串其余全是true 数值 \u003e 布尔 除了0和NaN其余的全是true null、undefined \u003e 布尔 都是false 对象 \u003e 布尔 都是true 方式二（隐式类型转换）：为任意的数据类型做两次非运算，即可将其转换为布尔值 例子： var a = \"hello\"; a = !!a; //true ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:2:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#转换为布尔值"},{"categories":["前端"],"content":"转换为布尔值方式一（强制类型转换）：使用Boolean()函数 例子： var s = \"false\"; s = Boolean(s); //true 转换的情况 字符串 布尔 除了空串其余全是true 数值 布尔 除了0和NaN其余的全是true null、undefined 布尔 都是false 对象 布尔 都是true 方式二（隐式类型转换）：为任意的数据类型做两次非运算，即可将其转换为布尔值 例子： var a = \"hello\"; a = !!a; //true ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:2:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#方式一强制类型转换-2"},{"categories":["前端"],"content":"转换为布尔值方式一（强制类型转换）：使用Boolean()函数 例子： var s = \"false\"; s = Boolean(s); //true 转换的情况 字符串 布尔 除了空串其余全是true 数值 布尔 除了0和NaN其余的全是true null、undefined 布尔 都是false 对象 布尔 都是true 方式二（隐式类型转换）：为任意的数据类型做两次非运算，即可将其转换为布尔值 例子： var a = \"hello\"; a = !!a; //true ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:2:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#方式二隐式类型转换"},{"categories":["前端"],"content":"基础语法","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:0:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#基础语法"},{"categories":["前端"],"content":"运算符运算符也称为操作符 通过运算符可以对一个或多个值进行运算或操作 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:1:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#运算符"},{"categories":["前端"],"content":"typeof运算符用来检查一个变量的数据类型 语法：typeof 变量 它会返回一个用于描述类型的字符串作为结果 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:1:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#typeof运算符"},{"categories":["前端"],"content":"算数运算符+ 对两个值进行加法运算并返回结果 - 对两个值进行减法运算并返回结果 * 对两个值进行乘法运算并返回结果 / 对两个值进行除法运算并返回结果 % 对两个值进行取余运算并返回结果 除了加法以外，对非Number类型的值进行运算时，都会先转换为Number然后在做运算。 而做加法运算时，如果是两个字符串进行相加，则会做拼串操作，将两个字符连接为一个字符串。 任何值和字符串做加法，都会先转换为字符串，然后再拼串 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:1:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#算数运算符"},{"categories":["前端"],"content":"一元运算符一元运算符只需要一个操作数 一元的+就是正号，不会对值产生任何影响，但是可以将一个非数字转换为数字 例子： var a = true; a = +a; 一元的-就是负号，可以对一个数字进行符号位取反 例子： var a = 10; a = -a; 自增自增可以使变量在原值的基础上自增1 自增使用 ++ 自增可以使用 前++（++a）后++(a++) 无论是++a 还是 a++都会立即使原变量自增1 不同的是++a和a++的值是不同的， ++a的值是变量的新值（自增后的值） a++的值是变量的原值（自增前的值） 自减自减可以使变量在原值的基础上自减1 自减使用 – 自减可以使用 前–（–a）后–(a–) 无论是–a 还是 a–都会立即使原变量自减1 不同的是–a和a–的值是不同的， –a的值是变量的新值（自减后的值） a–的值是变量的原值（自减前的值） ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:1:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#一元运算符"},{"categories":["前端"],"content":"一元运算符一元运算符只需要一个操作数 一元的+就是正号，不会对值产生任何影响，但是可以将一个非数字转换为数字 例子： var a = true; a = +a; 一元的-就是负号，可以对一个数字进行符号位取反 例子： var a = 10; a = -a; 自增自增可以使变量在原值的基础上自增1 自增使用 ++ 自增可以使用 前++（++a）后++(a++) 无论是++a 还是 a++都会立即使原变量自增1 不同的是++a和a++的值是不同的， ++a的值是变量的新值（自增后的值） a++的值是变量的原值（自增前的值） 自减自减可以使变量在原值的基础上自减1 自减使用 – 自减可以使用 前–（–a）后–(a–) 无论是–a 还是 a–都会立即使原变量自减1 不同的是–a和a–的值是不同的， –a的值是变量的新值（自减后的值） a–的值是变量的原值（自减前的值） ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:1:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#一元的"},{"categories":["前端"],"content":"一元运算符一元运算符只需要一个操作数 一元的+就是正号，不会对值产生任何影响，但是可以将一个非数字转换为数字 例子： var a = true; a = +a; 一元的-就是负号，可以对一个数字进行符号位取反 例子： var a = 10; a = -a; 自增自增可以使变量在原值的基础上自增1 自增使用 ++ 自增可以使用 前++（++a）后++(a++) 无论是++a 还是 a++都会立即使原变量自增1 不同的是++a和a++的值是不同的， ++a的值是变量的新值（自增后的值） a++的值是变量的原值（自增前的值） 自减自减可以使变量在原值的基础上自减1 自减使用 – 自减可以使用 前–（–a）后–(a–) 无论是–a 还是 a–都会立即使原变量自减1 不同的是–a和a–的值是不同的， –a的值是变量的新值（自减后的值） a–的值是变量的原值（自减前的值） ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:1:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#一元的-"},{"categories":["前端"],"content":"一元运算符一元运算符只需要一个操作数 一元的+就是正号，不会对值产生任何影响，但是可以将一个非数字转换为数字 例子： var a = true; a = +a; 一元的-就是负号，可以对一个数字进行符号位取反 例子： var a = 10; a = -a; 自增自增可以使变量在原值的基础上自增1 自增使用 ++ 自增可以使用 前++（++a）后++(a++) 无论是++a 还是 a++都会立即使原变量自增1 不同的是++a和a++的值是不同的， ++a的值是变量的新值（自增后的值） a++的值是变量的原值（自增前的值） 自减自减可以使变量在原值的基础上自减1 自减使用 – 自减可以使用 前–（–a）后–(a–) 无论是–a 还是 a–都会立即使原变量自减1 不同的是–a和a–的值是不同的， –a的值是变量的新值（自减后的值） a–的值是变量的原值（自减前的值） ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:1:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#自增"},{"categories":["前端"],"content":"一元运算符一元运算符只需要一个操作数 一元的+就是正号，不会对值产生任何影响，但是可以将一个非数字转换为数字 例子： var a = true; a = +a; 一元的-就是负号，可以对一个数字进行符号位取反 例子： var a = 10; a = -a; 自增自增可以使变量在原值的基础上自增1 自增使用 ++ 自增可以使用 前++（++a）后++(a++) 无论是++a 还是 a++都会立即使原变量自增1 不同的是++a和a++的值是不同的， ++a的值是变量的新值（自增后的值） a++的值是变量的原值（自增前的值） 自减自减可以使变量在原值的基础上自减1 自减使用 – 自减可以使用 前–（–a）后–(a–) 无论是–a 还是 a–都会立即使原变量自减1 不同的是–a和a–的值是不同的， –a的值是变量的新值（自减后的值） a–的值是变量的原值（自减前的值） ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:1:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#自减"},{"categories":["前端"],"content":"逻辑运算符! 非运算可以对一个布尔值进行取反，true变false false边true 当对非布尔值使用!时，会先将其转换为布尔值然后再取反 我们可以利用!来将其他的数据类型转换为布尔值 \u0026\u0026 \u0026\u0026可以对符号两侧的值进行与运算 只有两端的值都为true时，才会返回true。只要有一个false就会返回false。 与是一个短路的与，如果第一个值是false，则不再检查第二个值 对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值 规则： 1.如果第一个值为false，则返回第一个值 2.如果第一个值为true，则返回第二个值 || ||可以对符号两侧的值进行或运算 只有两端都是false时，才会返回false。只要有一个true，就会返回true。 或是一个短路的或，如果第一个值是true，则不再检查第二个值 对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值 规则： 1.如果第一个值为true，则返回第一个值 2.如果第一个值为false，则返回第二个值 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:1:4","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#逻辑运算符"},{"categories":["前端"],"content":"赋值运算符= 可以将符号右侧的值赋值给左侧变量 += a += 5 相当于 a = a+5 var str = \"hello\"; str += \"world\"; -= a -= 5 相当于 a = a-5 *= a *= 5 相当于 a = a*5 /= a /= 5 相当于 a = a/5 %= a %= 5 相当于 a = a%5 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:1:5","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#赋值运算符"},{"categories":["前端"],"content":"关系运算符关系运算符用来比较两个值之间的大小关系的 \u003e \u003e= \u003c \u003c= 关系运算符的规则和数学中一致，用来比较两个值之间的关系， 如果关系成立则返回true，关系不成立则返回false。 如果比较的两个值是非数值，会将其转换为Number然后再比较。 如果比较的两个值都是字符串，此时会比较字符串的Unicode编码，而不会转换为Number。 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:1:6","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#关系运算符"},{"categories":["前端"],"content":"相等运算符相等，判断左右两个值是否相等，如果相等返回true，如果不等返回false 相等会自动对两个值进行类型转换，如果对不同的类型进行比较，会将其转换为相同的类型然后再比较，转换后相等它也会返回true，null == undifined != 不等，判断左右两个值是否不等，如果不等则返回true，如果相等则返回false 不等也会做自动的类型转换。 === 全等，判断左右两个值是否全等，它和相等类似，只不过它不会进行自动的类型转换， 如果两个值的类型不同，则直接返回false !== 不全等，和不等类似，但是它不会进行自动的类型转换，如果两个值的类型不同，它会直接返回true 特殊的值： null和undefined 由于undefined衍生自null，所以null == undefined 会返回true。 但是 null === undefined 会返回false。 NaN NaN不与任何值相等，报告它自身 NaN == NaN //false 判断一个值是否是NaN 使用isNaN()函数 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:1:7","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#相等运算符"},{"categories":["前端"],"content":"三元运算符：?: 语法：条件表达式?语句1:语句2; 执行流程： 先对条件表达式求值判断， 如果判断结果为true，则执行语句1，并返回执行结果 如果判断结果为false，则执行语句2，并返回执行结果 优先级： 和数学中一样，JS中的运算符也是具有优先级的， 比如 先乘除 后加减 先与 后或 具体的优先级可以参考优先级的表格，在表格中越靠上的优先级越高， 优先级越高的越优先计算，优先级相同的，从左往右计算。 优先级不需要记忆，如果越到拿不准的，使用()来改变优先级。 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:1:8","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#三元运算符"},{"categories":["前端"],"content":"流程控制语句程序都是自上向下的顺序执行的， 通过流程控制语句可以改变程序执行的顺序，或者反复的执行某一段的程序。 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:2:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#流程控制语句"},{"categories":["前端"],"content":"条件分支语句if 条件判断语法一： if(条件表达式){ 语句... } 执行流程： if语句执行时，会先对条件表达式进行求值判断， 如果值为true，则执行if后的语句 如果值为false，则不执行 语法二： if(条件表达式){ 语句... }else{ 语句... } 执行流程： if...else语句执行时，会对条件表达式进行求值判断， 如果值为true，则执行if后的语句 如果值为false，则执行else后的语句 语法三： if(条件表达式){ 语句... }else if(条件表达式){ 语句... }else if(条件表达式){ 语句... }else if(条件表达式){ 语句... }else{ 语句... } 执行流程 if...else if...else语句执行时，会自上至下依次对条件表达式进行求值判断， 如果判断结果为true，则执行当前if后的语句，执行完成后语句结束。 如果判断结果为false，则继续向下判断，直到找到为true的为止。 如果所有的条件表达式都是false，则执行else后的语句 switch 条件分支语句语法: switch(条件表达式){ case 表达式: 语句... break; case 表达式: 语句... break; case 表达式: 语句... break; default: 语句... break; } 执行流程： switch…case…语句在执行时，会依次将case后的表达式的值和switch后的表达式的值进行全等比较， 如果比较结果为false，则继续向下比较。如果比较结果为true，则从当前case处开始向下执行代码。 如果所有的case判断结果都为false，则从default处开始执行代码。 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:2:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#条件分支语句"},{"categories":["前端"],"content":"条件分支语句if 条件判断语法一： if(条件表达式){ 语句... } 执行流程： if语句执行时，会先对条件表达式进行求值判断， 如果值为true，则执行if后的语句 如果值为false，则不执行 语法二： if(条件表达式){ 语句... }else{ 语句... } 执行流程： if...else语句执行时，会对条件表达式进行求值判断， 如果值为true，则执行if后的语句 如果值为false，则执行else后的语句 语法三： if(条件表达式){ 语句... }else if(条件表达式){ 语句... }else if(条件表达式){ 语句... }else if(条件表达式){ 语句... }else{ 语句... } 执行流程 if...else if...else语句执行时，会自上至下依次对条件表达式进行求值判断， 如果判断结果为true，则执行当前if后的语句，执行完成后语句结束。 如果判断结果为false，则继续向下判断，直到找到为true的为止。 如果所有的条件表达式都是false，则执行else后的语句 switch 条件分支语句语法: switch(条件表达式){ case 表达式: 语句... break; case 表达式: 语句... break; case 表达式: 语句... break; default: 语句... break; } 执行流程： switch…case…语句在执行时，会依次将case后的表达式的值和switch后的表达式的值进行全等比较， 如果比较结果为false，则继续向下比较。如果比较结果为true，则从当前case处开始向下执行代码。 如果所有的case判断结果都为false，则从default处开始执行代码。 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:2:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#if-条件判断"},{"categories":["前端"],"content":"条件分支语句if 条件判断语法一： if(条件表达式){ 语句... } 执行流程： if语句执行时，会先对条件表达式进行求值判断， 如果值为true，则执行if后的语句 如果值为false，则不执行 语法二： if(条件表达式){ 语句... }else{ 语句... } 执行流程： if...else语句执行时，会对条件表达式进行求值判断， 如果值为true，则执行if后的语句 如果值为false，则执行else后的语句 语法三： if(条件表达式){ 语句... }else if(条件表达式){ 语句... }else if(条件表达式){ 语句... }else if(条件表达式){ 语句... }else{ 语句... } 执行流程 if...else if...else语句执行时，会自上至下依次对条件表达式进行求值判断， 如果判断结果为true，则执行当前if后的语句，执行完成后语句结束。 如果判断结果为false，则继续向下判断，直到找到为true的为止。 如果所有的条件表达式都是false，则执行else后的语句 switch 条件分支语句语法: switch(条件表达式){ case 表达式: 语句... break; case 表达式: 语句... break; case 表达式: 语句... break; default: 语句... break; } 执行流程： switch…case…语句在执行时，会依次将case后的表达式的值和switch后的表达式的值进行全等比较， 如果比较结果为false，则继续向下比较。如果比较结果为true，则从当前case处开始向下执行代码。 如果所有的case判断结果都为false，则从default处开始执行代码。 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:2:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#switch-条件分支语句"},{"categories":["前端"],"content":"循环语句通过循环语句可以反复执行某些语句多次 while循环语法： while(条件表达式){ 语句... } 执行流程： while语句在执行时，会先对条件表达式进行求值判断， 如果判断结果为false，则终止循环 如果判断结果为true，则执行循环体 循环体执行完毕，继续对条件表达式进行求值判断，依此类推 do…while循环语法: do{ 语句... }while(条件表达式) 执行流程 do…while在执行时，会先执行do后的循环体，然后在对条件表达式进行判断， 如果判断判断结果为false，则终止循环。 如果判断结果为true，则继续执行循环体，依此类推 和while的区别： while：先判断后执行 do…while: 先执行后判断 do…while可以确保循环体至少执行一次。 for循环语法： for(①初始化表达式 ; ②条件表达式 ; ④更新表达式){ ③语句... } 执行流程： 首先执行①初始化表达式，初始化一个变量， 然后对②条件表达式进行求值判断，如果为false则终止循环 如果判断结果为true，则执行③循环体 循环体执行完毕，执行④更新表达式，对变量进行更新。 更新表达式执行完毕重复② 死循环 while(true){ } for(;;){ } break、continue // break指定标签跳出循环 outer: for(var i=0;i\u003c10;i++){ console.log(i) inside: for(var k=0;k\u003c3;k++){ console.log(k) break outer; } } // continue跳过当次循环 for(var i=0;i\u003c4;i++){ if(i==2){ continue; } console.log(i); } ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:2:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#循环语句"},{"categories":["前端"],"content":"循环语句通过循环语句可以反复执行某些语句多次 while循环语法： while(条件表达式){ 语句... } 执行流程： while语句在执行时，会先对条件表达式进行求值判断， 如果判断结果为false，则终止循环 如果判断结果为true，则执行循环体 循环体执行完毕，继续对条件表达式进行求值判断，依此类推 do…while循环语法: do{ 语句... }while(条件表达式) 执行流程 do…while在执行时，会先执行do后的循环体，然后在对条件表达式进行判断， 如果判断判断结果为false，则终止循环。 如果判断结果为true，则继续执行循环体，依此类推 和while的区别： while：先判断后执行 do…while: 先执行后判断 do…while可以确保循环体至少执行一次。 for循环语法： for(①初始化表达式 ; ②条件表达式 ; ④更新表达式){ ③语句... } 执行流程： 首先执行①初始化表达式，初始化一个变量， 然后对②条件表达式进行求值判断，如果为false则终止循环 如果判断结果为true，则执行③循环体 循环体执行完毕，执行④更新表达式，对变量进行更新。 更新表达式执行完毕重复② 死循环 while(true){ } for(;;){ } break、continue // break指定标签跳出循环 outer: for(var i=0;i","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:2:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#while循环"},{"categories":["前端"],"content":"循环语句通过循环语句可以反复执行某些语句多次 while循环语法： while(条件表达式){ 语句... } 执行流程： while语句在执行时，会先对条件表达式进行求值判断， 如果判断结果为false，则终止循环 如果判断结果为true，则执行循环体 循环体执行完毕，继续对条件表达式进行求值判断，依此类推 do…while循环语法: do{ 语句... }while(条件表达式) 执行流程 do…while在执行时，会先执行do后的循环体，然后在对条件表达式进行判断， 如果判断判断结果为false，则终止循环。 如果判断结果为true，则继续执行循环体，依此类推 和while的区别： while：先判断后执行 do…while: 先执行后判断 do…while可以确保循环体至少执行一次。 for循环语法： for(①初始化表达式 ; ②条件表达式 ; ④更新表达式){ ③语句... } 执行流程： 首先执行①初始化表达式，初始化一个变量， 然后对②条件表达式进行求值判断，如果为false则终止循环 如果判断结果为true，则执行③循环体 循环体执行完毕，执行④更新表达式，对变量进行更新。 更新表达式执行完毕重复② 死循环 while(true){ } for(;;){ } break、continue // break指定标签跳出循环 outer: for(var i=0;i","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:2:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#dowhile循环"},{"categories":["前端"],"content":"循环语句通过循环语句可以反复执行某些语句多次 while循环语法： while(条件表达式){ 语句... } 执行流程： while语句在执行时，会先对条件表达式进行求值判断， 如果判断结果为false，则终止循环 如果判断结果为true，则执行循环体 循环体执行完毕，继续对条件表达式进行求值判断，依此类推 do…while循环语法: do{ 语句... }while(条件表达式) 执行流程 do…while在执行时，会先执行do后的循环体，然后在对条件表达式进行判断， 如果判断判断结果为false，则终止循环。 如果判断结果为true，则继续执行循环体，依此类推 和while的区别： while：先判断后执行 do…while: 先执行后判断 do…while可以确保循环体至少执行一次。 for循环语法： for(①初始化表达式 ; ②条件表达式 ; ④更新表达式){ ③语句... } 执行流程： 首先执行①初始化表达式，初始化一个变量， 然后对②条件表达式进行求值判断，如果为false则终止循环 如果判断结果为true，则执行③循环体 循环体执行完毕，执行④更新表达式，对变量进行更新。 更新表达式执行完毕重复② 死循环 while(true){ } for(;;){ } break、continue // break指定标签跳出循环 outer: for(var i=0;i","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:2:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#for循环"},{"categories":["前端"],"content":"循环语句通过循环语句可以反复执行某些语句多次 while循环语法： while(条件表达式){ 语句... } 执行流程： while语句在执行时，会先对条件表达式进行求值判断， 如果判断结果为false，则终止循环 如果判断结果为true，则执行循环体 循环体执行完毕，继续对条件表达式进行求值判断，依此类推 do…while循环语法: do{ 语句... }while(条件表达式) 执行流程 do…while在执行时，会先执行do后的循环体，然后在对条件表达式进行判断， 如果判断判断结果为false，则终止循环。 如果判断结果为true，则继续执行循环体，依此类推 和while的区别： while：先判断后执行 do…while: 先执行后判断 do…while可以确保循环体至少执行一次。 for循环语法： for(①初始化表达式 ; ②条件表达式 ; ④更新表达式){ ③语句... } 执行流程： 首先执行①初始化表达式，初始化一个变量， 然后对②条件表达式进行求值判断，如果为false则终止循环 如果判断结果为true，则执行③循环体 循环体执行完毕，执行④更新表达式，对变量进行更新。 更新表达式执行完毕重复② 死循环 while(true){ } for(;;){ } break、continue // break指定标签跳出循环 outer: for(var i=0;i","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:2:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#breakcontinue"},{"categories":["前端"],"content":"对象（Object）对象是JS中的引用数据类型 对象是一种复合数据类型，在对象中可以保存多个不同数据类型的属性 使用typeof检查一个对象时，会返回object ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:0:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#对象object"},{"categories":["前端"],"content":"对象的分类：1.内建对象 - 由ES标准中定义的对象，在任何的ES的实现中都可以使用 - 比如：Math String Number Boolean Function Object.... 2.宿主对象 - 由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象 - 比如 BOM DOM 3.自定义对象 - 由开发人员自己创建的对象 创建对象 方式一： //使用new关键字调用的函数，是构造函数 var obj = new Object(); 方式二： var obj = {}; //对象字面量属性名可以加引号也可以不加，若使用特殊名字必须加引号 var obj2 = {name:\"wxz\",age=18,\"@@#!#!@\":\"瞎几把写\"}; 向对象中添加属性 语法： 对象.属性名 = 属性值; 对象[“属性名”] = 属性值; //这种方式能够使用特殊的属性名 对象的属性名没有任何要求，不需要遵守标识符的规范，但是在开发中，尽量按照标识符的要求去写。 属性值也可以任意的数据类型。 读取对象中的属性 语法： 对象.属性名 对象[“属性名”] //“属性名\"可以使字符串常量，也可以是字符串变量 如果读取一个对象中没有的属性，它不会报错，而是返回一个undefined 删除对象中的属性 语法： delete 对象.属性名 delete 对象[\"属性名\"] 对象的引用首先，JS的变量都保存在内存中，内存又分为栈内存和堆内存，基本数据类型的变量可直接保存在栈内存中，对象类型的变量保存在堆内存中，栈内存中只保留其引用。 所以当使用 “a = b” 为变量赋值时： 若 b 为基本数据类型，相当于在栈内存中为 a 复制栈内存中 b 的数据，赋完值后 b 再变化也不会影响到 a 的值。 若 b 为Object类型，b 在栈内存中的值是其堆内存中的引用地址，所以 a 复制的也是 b 的引用地址，此时 b 的值发生变化，a 通过引用地址指向的是 b 的值，也会一样变化。 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:1:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#对象的分类"},{"categories":["前端"],"content":"对象的分类：1.内建对象 - 由ES标准中定义的对象，在任何的ES的实现中都可以使用 - 比如：Math String Number Boolean Function Object.... 2.宿主对象 - 由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象 - 比如 BOM DOM 3.自定义对象 - 由开发人员自己创建的对象 创建对象 方式一： //使用new关键字调用的函数，是构造函数 var obj = new Object(); 方式二： var obj = {}; //对象字面量属性名可以加引号也可以不加，若使用特殊名字必须加引号 var obj2 = {name:\"wxz\",age=18,\"@@#!#!@\":\"瞎几把写\"}; 向对象中添加属性 语法： 对象.属性名 = 属性值; 对象[“属性名”] = 属性值; //这种方式能够使用特殊的属性名 对象的属性名没有任何要求，不需要遵守标识符的规范，但是在开发中，尽量按照标识符的要求去写。 属性值也可以任意的数据类型。 读取对象中的属性 语法： 对象.属性名 对象[“属性名”] //“属性名\"可以使字符串常量，也可以是字符串变量 如果读取一个对象中没有的属性，它不会报错，而是返回一个undefined 删除对象中的属性 语法： delete 对象.属性名 delete 对象[\"属性名\"] 对象的引用首先，JS的变量都保存在内存中，内存又分为栈内存和堆内存，基本数据类型的变量可直接保存在栈内存中，对象类型的变量保存在堆内存中，栈内存中只保留其引用。 所以当使用 “a = b” 为变量赋值时： 若 b 为基本数据类型，相当于在栈内存中为 a 复制栈内存中 b 的数据，赋完值后 b 再变化也不会影响到 a 的值。 若 b 为Object类型，b 在栈内存中的值是其堆内存中的引用地址，所以 a 复制的也是 b 的引用地址，此时 b 的值发生变化，a 通过引用地址指向的是 b 的值，也会一样变化。 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:1:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#对象的引用"},{"categories":["前端"],"content":"遍历使用in检查对象中是否含有指定属性 语法：“属性名” in 对象 如果在对象中含有该属性，则返回true 如果没有则返回false 循环遍历对象自身的和继承的可枚举属性(不含Symbol属性). var obj = {'0':'a','1':'b','2':'c'}; for(var i in obj) { console.log(i,\":\",obj[i]); } ​ 使用对象字面量，在创建对象时直接向对象中添加属性 语法： var obj = { 属性名:属性值, 属性名:属性值, 属性名:属性值, 属性名:属性值 } 基本数据类型和引用数据类型 基本数据类型 String Number Boolean Null Undefined 引用数据类型 Object 基本数据类型的数据，变量是直接保存的它的值。 变量与变量之间是互相独立的，修改一个变量不会影响其他的变量。 引用数据类型的数据，变量是保存的对象的引用（内存地址）。 如果多个变量指向的是同一个对象，此时修改一个变量的属性，会影响其他的变量。 比较两个变量时，对于基本数据类型，比较的就是值， 对于引用数据类型比较的是地址，地址相同才相同 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:2:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#遍历"},{"categories":["前端"],"content":"函数（Function）函数也是一个对象，也具有普通对象的功能（能有属性） 函数中可以封装一些代码，在需要的时候可以去调用函数来执行这些代码 使用typeof检查一个函数时会返回function 创建函数 函数声明 function 函数名([形参1,形参2...形参N]){ 语句... } 函数表达式 var 函数名 = function([形参1,形参2...形参N]){ 语句... }; //例子 var fun1 = new Function(\"console.log('这是我第一个函数');\"); fun1(); var fun2 = function(){ console.log(\"第二个函数\"); } fun2() function fun3(){ console.log(\"第三个函数\"); } fun3(); 调用函数 语法：函数对象([实参1,实参2…实参N]); fun() sum() alert() Number() parseInt() 当我们调用函数时，函数中封装的代码会按照编写的顺序执行 立即执行函数 函数定义完，立即被调用，这种函数叫做立即执行函数 立即执行函数往往只会执行一次 (function(a,b){ console.log(\"a = \"+a); console.log(\"b = \"+b); })(123,456); 遍历对象 for(var v in obj){ document.write(\"property：name =\"+v+\"value=\"+obj[v]+\"\u003cbr/\u003e\" ); } 形参和实参 形参：形式参数 定义函数时，可以在()中定义一个或多个形参，形参之间使用,隔开 定义形参就相当于在函数内声明了对应的变量但是并不赋值， 形参会在调用时才赋值。 实参：实际参数 调用函数时，可以在()传递实参，传递的实参会赋值给对应的形参, 调用函数时JS解析器不会检查实参的类型和个数，可以传递任意数据类型的值。 如果实参的数量大于形参，多余实参将不会赋值， 如果实参的数量小于形参，则没有对应实参的形参将会赋值undefined 返回值，就是函数执行的结果。 使用return 来设置函数的返回值。 语法：return 值; 该值就会成为函数的返回值，可以通过一个变量来接收返回值 return后边的代码都不会执行，一旦执行到return语句时，函数将会立刻退出。 return后可以跟任意类型的值，可以是基本数据类型，也可以是一个对象。 如果return后不跟值，或者是不写return则函数默认返回undefined。 break、continue和return break 退出循环 continue 跳过当次循环 return 退出函数 参数，函数的实参也可以是任意的数据类型。 方法（method） 可以将一个函数设置为一个对象的属性， 当一个对象的属性是一个函数时， 我们称这个函数是该对象的方法。 对象.方法名(); 函数名() ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:3:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#函数function"},{"categories":["前端"],"content":"函数的属性和方法call()、apply()、bind()这两个方法都是函数对象的方法需要通过函数对象来调用 通过两个方法可以直接调用函数，并且可以通过第一个实参来指定函数中this 不同的是call是直接传递函数的实参而apply需要将实参封装到一个数组中传递 argumentsarguments和this类似，都是函数中的隐含的参数 arguments是一个类数组元素，它用来封装函数执行过程中的实参 所以即使不定义形参，也可以通过arguments来使用实参 arguments中有一个属性callee表示当前执行的函数对象 this（调用函数的那个对象）this是函数的上下文对象，根据函数的调用方式不同会执向不同的对象 1.以函数的形式调用时，this是window 2.以方法的形式调用时，this是调用方法的对象 3.以构造函数的形式调用时，this是新建的那个对象 4.使用call和apply调用时，this是指定的那个对象 5.在全局作用域中this代表window ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:3:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#函数的属性和方法"},{"categories":["前端"],"content":"函数的属性和方法call()、apply()、bind()这两个方法都是函数对象的方法需要通过函数对象来调用 通过两个方法可以直接调用函数，并且可以通过第一个实参来指定函数中this 不同的是call是直接传递函数的实参而apply需要将实参封装到一个数组中传递 argumentsarguments和this类似，都是函数中的隐含的参数 arguments是一个类数组元素，它用来封装函数执行过程中的实参 所以即使不定义形参，也可以通过arguments来使用实参 arguments中有一个属性callee表示当前执行的函数对象 this（调用函数的那个对象）this是函数的上下文对象，根据函数的调用方式不同会执向不同的对象 1.以函数的形式调用时，this是window 2.以方法的形式调用时，this是调用方法的对象 3.以构造函数的形式调用时，this是新建的那个对象 4.使用call和apply调用时，this是指定的那个对象 5.在全局作用域中this代表window ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:3:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#callapplybind"},{"categories":["前端"],"content":"函数的属性和方法call()、apply()、bind()这两个方法都是函数对象的方法需要通过函数对象来调用 通过两个方法可以直接调用函数，并且可以通过第一个实参来指定函数中this 不同的是call是直接传递函数的实参而apply需要将实参封装到一个数组中传递 argumentsarguments和this类似，都是函数中的隐含的参数 arguments是一个类数组元素，它用来封装函数执行过程中的实参 所以即使不定义形参，也可以通过arguments来使用实参 arguments中有一个属性callee表示当前执行的函数对象 this（调用函数的那个对象）this是函数的上下文对象，根据函数的调用方式不同会执向不同的对象 1.以函数的形式调用时，this是window 2.以方法的形式调用时，this是调用方法的对象 3.以构造函数的形式调用时，this是新建的那个对象 4.使用call和apply调用时，this是指定的那个对象 5.在全局作用域中this代表window ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:3:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#arguments"},{"categories":["前端"],"content":"函数的属性和方法call()、apply()、bind()这两个方法都是函数对象的方法需要通过函数对象来调用 通过两个方法可以直接调用函数，并且可以通过第一个实参来指定函数中this 不同的是call是直接传递函数的实参而apply需要将实参封装到一个数组中传递 argumentsarguments和this类似，都是函数中的隐含的参数 arguments是一个类数组元素，它用来封装函数执行过程中的实参 所以即使不定义形参，也可以通过arguments来使用实参 arguments中有一个属性callee表示当前执行的函数对象 this（调用函数的那个对象）this是函数的上下文对象，根据函数的调用方式不同会执向不同的对象 1.以函数的形式调用时，this是window 2.以方法的形式调用时，this是调用方法的对象 3.以构造函数的形式调用时，this是新建的那个对象 4.使用call和apply调用时，this是指定的那个对象 5.在全局作用域中this代表window ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:3:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#this调用函数的那个对象"},{"categories":["前端"],"content":"变量作用域、变量的声明、函数的声明作用域简单来说就是一个变量的作用范围。 在JS中作用域分成两种： 1.全局作用域 直接在script标签中编写的代码都运行在全局作用域中 全局作用域在打开页面时创建，在页面关闭时销毁。 全局作用域中有一个全局对象window，window对象由浏览器提供， 可以在页面中直接使用，它代表的是整个的浏览器的窗口。 在全局作用域中创建的变量都会作为window对象的属性保存 在全局作用域中创建的函数都会作为window对象的方法保存 在全局作用域中创建的变量和函数可以在页面的任意位置访问。 在函数作用域中也可以访问到全局作用域的变量。 尽量不要在全局中创建变量 2.函数作用域 函数作用域是函数执行时创建的作用域，每次调用函数都会创建一个新的函数作用域。 函数作用域在函数执行时创建，在函数执行结束时销毁。 在函数作用域中创建的变量，不能在全局中访问。 当在函数作用域中使用一个变量时，它会先在自身作用域中寻找， 如果找到了则直接使用，如果没有找到则到上一级作用域中寻找， 如果找到了则使用，找不到则继续向上找，一直会 变量的声明提前 在全局作用域中，使用var关键字声明的变量会在所有的代码执行之前被声明，但是不会赋值。 所以我们可以在变量声明前使用变量。但是不使用var关键字声明的变量不会被声明提前。 在函数作用域中，也具有该特性，使用var关键字声明的变量会在函数所有的代码执行前被声明， 如果没有使用var关键字声明变量，则变量会变成全局变量 函数的声明提前 在全局作用域中，使用函数声明创建的函数（function fun(){}）,会在所有的代码执行之前被创建， 也就是我们可以在函数声明前去调用函数，但是使用函数表达式(var fun = function(){})创建的函数没有该特性 在函数作用域中，使用函数声明创建的函数，会在所有的函数中的代码执行之前就被创建好了。 在函数中不使用var声明的变量会变为全局变量 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:4:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#变量作用域变量的声明函数的声明"},{"categories":["前端"],"content":"this（上下文对象）我们每次调用函数时，解析器都会将一个上下文对象作为隐含的参数传递进函数。 使用this来引用上下文对象，根据函数的调用形式不同，this的值也不同。 指向当前对象 this的不同的情况： 1.以函数的形式调用时，this是window 2.以方法的形式调用时，this就是调用方法的对象 3.以构造函数的形式调用时，this就是新创建的对象 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:5:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#this上下文对象"},{"categories":["前端"],"content":"工厂模式创建对象使用工厂模式创建的对象，构造函数使用的都是new Object，所以创建的对象都是Object类型，导致无法区分不同对象类型。 function createPerson(name,age,gender){ var obj = new Object(); obj.name = name; obj.age = age; obj.gender = gender; obj.sayname = function(){ console.log(obj.name); } return obj } function createDog(name,age,gender){ var obj = new Object(); obj.name = name; obj.age = age; obj.gender = gender; obj.sayname = function(){ console.log(obj.name); } return obj } var p1 = createPerson(\"wxz\",18,\"male\"); var p2 = createPerson(\"lmx\",1,\"female\"); var dog = createDog(\"汪汪\",2,\"公\") p1.sayname(); p2.sayname(); dog.sayname(); ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:6:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#工厂模式创建对象"},{"categories":["前端"],"content":"构造函数构造函数是专门用来创建对象的函数 一个构造函数我们也可以称为一个类 通过一个构造函数创建的对象，我们称该对象时这个构造函数的实例 通过同一个构造函数创建的对象，我们称为一类对象 构造函数就是一个普通的函数，只是他的调用方式不同， 如果直接调用，它就是一个普通函数 如果使用new来调用，则它就是一个构造函数 例子： function Person(name , age , gender){ this.name = name; this.age = age; this.gender = gender; this.sayName = function(){ alert(this.name); }; } 构造函数的执行流程： 1.创建一个新的对象 2.将新的对象作为函数的上下文对象（this） 3.执行函数中的代码 4.将新建的对象返回 instanceof 用来检查一个对象是否是一个类的实例 语法：对象 instanceof 构造函数 如果该对象时构造函数的实例，则返回true，否则返回false Object是所有对象的祖先，所以任何对象和Object做instanceof都会返回true 枚举对象中的属性 for…in 语法： for(var 属性名 in 对象){ } for…in语句的循环体会执行多次，对象中有几个属性就会执行几次， 每次讲一个属性名赋值给我们定义的变量，我们可以通过它来获取对象中的属性 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:7:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#构造函数"},{"categories":["前端"],"content":"原型（prototype）JS创建对象模式和优缺点详解 创建一个函数以后，解析器都会默认在函数中添加一个数prototype prototype属性指向的是一个对象，这个对象我们称为原型对象。 当函数作为构造函数使用，它所创建的对象中都会有一个隐含的属性执行该原型对象。 这个隐含的属性可以通过对象.__proto__来访问。 原型对象就相当于一个公共的区域，凡是通过同一个构造函数创建的对象他们通常都可以访问到相同的原型对象。 我们可以将对象中共有的属性和方法统一添加到原型对象中， 这样我们只需要添加一次，就可以使所有的对象都可以使用。 当我们去访问对象的一个属性或调用对象的一个方法时，它会先自身中寻找， 如果在自身中找到了，则直接使用。 如果没有找到，则去原型对象中寻找，如果找到了则使用， 如果没有找到，则去原型的原型中寻找，依此类推。直到找到Object的原型为止，Object的原型的原型为null， 如果依然没有找到则返回undefined hasOwnProperty() 这个方法可以用来检查对象自身中是否含有某个属性 语法：对象.hasOwnProperty(“属性名”) ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:8:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#原型prototype"},{"categories":["前端"],"content":"toString()方法当我们直接在页面中打印一个对象时，事件上是输出的对象的toString()方法的返回值 如果我们希望在输出对象时不输出[object Object]，可以为对象添加一个toString()方法 //修改Person原型的toString Person.prototype.toString = function(){ return \"Person[name=\"+this.name+\",age=\"+this.age+\",gender=\"+this.gender+\"]\"; }; ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:9:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#tostring方法"},{"categories":["前端"],"content":"垃圾回收（GC）就像人生活的时间长了会产生垃圾一样，程序运行过程中也会产生垃圾 这些垃圾积攒过多以后，会导致程序运行的速度过慢， 所以我们需要一个垃圾回收的机制，来处理程序运行过程中产生垃圾 当一个对象没有任何的变量或属性对它进行引用，此时我们将永远无法操作该对象， 此时这种对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序运行变慢， 所以这种垃圾必须进行清理。 在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁， 我们不需要也不能进行垃圾回收的操作 我们需要做的只是要将不再使用的对象设置null即可 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:10:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#垃圾回收gc"},{"categories":["前端"],"content":"数组（Array）数组也是一个对象，是一个用来存储数据的对象和Object类似，但是它的存储效率比普通对象要高 数组中保存的内容我们称为元素 数组使用索引（index）来操作元素 索引指由0开始的整数 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:0:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#数组array"},{"categories":["前端"],"content":"数组的操作：创建数组 var arr = new Array(); var arr = []; 向数组中添加元素 语法； 数组对象[索引] = 值; arr[0] = 123; arr[1] = \"hello\"; 创建数组时直接添加元素 语法： var arr = [元素1,元素2....元素N]; 例子： var arr = [123,\"hello\",true,null]; 获取和修改数组的长度 使用length属性来操作数组的长度 获取长度： 数组.length length获取到的是数组的最大索引+1 对于连续的数组，length获取到的就是数组中元素的个数 修改数组的长度 数组.length = 新长度 如果修改后的length大于原长度，则多出的部分会空出来 如果修改后的length小于原长度，则原数组中多出的元素会被删除 向数组的最后添加元素 数组[数组.length] = 值; ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:1:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#数组的操作"},{"categories":["前端"],"content":"数组的方法 functionName function usage push() 用来向数组的末尾添加一个或多个元素，并返回数组新的长度 语法：数组.push(元素1,元素2,元素N)pop() pop() 用来删除数组的最后一个元素，并返回被删除的元素 unshift() 向数组的开头添加一个或多个元素，并返回数组的新的长度 shift() 删除数组的开头的一个元素，并返回被删除的元素 reverse() 可以用来反转一个数组，它会对原数组产生影响 concat() 可以连接两个或多个数组，它不会影响原数组，而是新数组作为返回值返回 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:2:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#数组的方法"},{"categories":["前端"],"content":"slice(sart,[end]) 可以从一个数组中截取指定的元素 该方法不会影响原数组，而是将截取到的内容封装为一个新的数组并返回 参数： 1.截取开始位置的索引（包括开始位置） 2.截取结束位置的索引（不包括结束位置） 第二个参数可以省略不写，如果不写则一直截取到最后 参数可以传递一个负值，如果是负值，则从后往前数 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:2:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#slicesartend"},{"categories":["前端"],"content":"splice() 可以用来删除数组中指定元素，并使用新的元素替换 该方法会将删除的元素封装到新数组中返回 参数： 1.删除开始位置的索引 2.删除的个数 3.三个以后，都是替换的元素，这些元素将会插入到开始位置索引的前边 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:2:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#splice"},{"categories":["前端"],"content":"join([splitor])可以将一个数组转换为一个字符串 参数： 需要一个字符串作为参数，这个字符串将会作为连接符来连接数组中的元素 如果不指定连接符则默认使用, ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:2:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#joinsplitor"},{"categories":["前端"],"content":"sort()可以对一个数组中的内容进行排序，默认是按照Unicode编码进行排序 调用以后，会直接修改原数组。 可以自己指定排序的规则，需要一个回调函数作为参数： 我们可以自己来指定排序的规则 我们可以在sort()添加一个回调函数，来指定排序规则， 回调函数中需要定义两个形参, 浏览器将会分别使用数组中的元素作为实参去调用回调函数 使用哪个元素调用不确定，但是肯定的是在数组中a一定在b前边 浏览器会根据回调函数的返回值来决定元素的顺序， 如果返回一个大于0的值，则元素会交换位置 如果返回一个小于0的值，则元素位置不变 如果返回一个0，则认为两个元素相等，也不交换位置 如果需要升序排列，则返回 a-b 如果需要降序排列，则返回b-a function(a,b){ //升序排列 //return a-b; //降序排列 return b-a; } ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:2:4","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#sort"},{"categories":["前端"],"content":"遍历数组遍历数组就是将数组中元素都获取到 一般情况我们都是使用for循环来遍历数组 for(var i=0 ; i\u003c数组.length ; i++){ //数组[i] } 使用forEach()方法来遍历数组（不兼容IE8） //foreach(fun)函数需要传一个函数fun作为参数，该函数fun会被浏览器当作回调函数调用，数组长度多长就会调用几次。 //浏览器在调用fun函数时，会向fun传最多3个最少0个参数，依次为“值、索引、数组对象”。 array.forEach(function(element , index , obj){ console.log(element + \" \" + index); }); array.foreach((element,index,obj) =\u003e { console.log(element + \" \" + index); }) forEach()方法需要一个回调函数作为参数， 数组中有几个元素，回调函数就会被调用几次， 每次调用时，都会将遍历到的信息以实参的形式传递进来， 我们可以定义形参来获取这些信息。 element:正在遍历的元素 index:正在遍历元素的索引 obj:被遍历对象 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:3:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#遍历数组"},{"categories":["前端"],"content":"常用类和方法","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:0:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#常用类和方法"},{"categories":["前端"],"content":"包装类 String、Boolean、Number在JS中为我们提供了三个包装类： String() Boolean() Number() 通过这三个包装类可以创建基本数据类型的对象 例子： var num = new Number(2); var str = new String(\"hello\"); var bool = new Boolean(true); 但是在实际应用中千万不要这么干。 当我们去操作一个基本数据类型的属性和方法时， 解析器会临时将其转换为临时的包装类，然后再去操作属性和方法， 操作完成以后再将这个临时对象进行销毁。 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:1:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#包装类-stringbooleannumber"},{"categories":["前端"],"content":"Date日期的对象，在JS中通过Date对象来表示一个时间 创建对象 创建一个当前的时间对象 var d = new Date(); 创建一个指定的时间对象 var d = new Date(\"月/日/年 时:分:秒\"); ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:2:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#date"},{"categories":["前端"],"content":"方法： name getDate() 当前日期对象是几日（1-31） getDay() 返回当前日期对象时周几（0-6） 0 周日 1 周一 。。。 getMonth() 返回当前日期对象的月份（0-11） 0 一月 1 二月 。。。 getFullYear() 从 Date 对象以四位数字返回年份。 getHours() 返回 Date 对象的小时 (0 ~ 23)。 getMinutes() 返回 Date 对象的分钟 (0 ~ 59)。 getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。 getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999)。 getTime() 返回当前日期对象的时间戳 时间戳，指的是从1970年月1日 0时0分0秒，到现在时间的毫秒数 计算机底层保存时间都是以时间戳的形式保存的。 Date.now() 可以获取当前代码执行时的时间戳 setHours() 设置 Date 对象中的小时 (0 ~ 23) ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:2:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#方法"},{"categories":["前端"],"content":"MathMath属于一个工具类，它不需要我们创建对象，它里边封装了属性运算相关的常量和方法 我们可以直接使用它来进行数学运算相关的操作 方法： Math.PI 常量，圆周率 Math.abs() 绝对值运算 Math.ceil() 向上取整 Math.floor() 向下取整 Math.round() 四舍五入取整 Math.random() 生成一个[0,1)之间的随机数 生成一个xy之间的随机数 Math.round(Math.random()*(y-x)+x); //[0,100]的随机数 var a = Number.parseInt(Math.random()*91+10) console.log(a); Math.pow(x,y) 求x的y次幂 Math.sqrt() 对一个数进行开方 Math.max() 求多个数中最大值 Math.min() 求多个数中的最小值 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:3:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#math"},{"categories":["前端"],"content":"字符串的相关的方法使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString='') 或 **String.prototype.padEnd(maxLength, fillString='')**来填充字符串； length 获取字符串的长度 charAt() 根据索引获取指定的字符 charCodeAt() 根据索引获取指定的字符编码 String.fromCharCode() 根据字符编码获取字符 indexOf() lastIndexOf() 从一个字符串中检索指定内容 需要一个字符串作为参数，这个字符串就是要检索的内容， 如果找到该内容，则会返回其第一次出现的索引，如果没有找到则返回-1。 可以指定一个第二个参数，来表示开始查找的位置 indexOf()是从前向后找 lastIndexOf()是从后向前找 slice(start,[end]) 可以从一个字符串中截取指定的内容，并将截取到内容返回，不会影响原变量 参数： 第一个：截取开始的位置（包括开始） 第二个：截取结束的位置**（不包括结束）** 可以省略第二个参数，如果省略则一直截取到最后 可以传负数，如果是负数则从后往前数 substr() 和slice()基本一致，不同的是它第二个参数不是索引，而是截取的数量 substring() 和slice()基本一致，不同的是它不能接受负值作为参数，如果设置一个负值，则会自动修正为0， substring()中如果第二个参数小于第一个，自动调整位置 toLowerCase() 将字符串转换为小写并返回 toUpperCase() 将字符串转换为大写并返回 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:4:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#字符串的相关的方法"},{"categories":["前端"],"content":"正则表达相关方法split() 可以根据指定内容将一个字符串拆分为一个数组 参数： 需要一个字符串作为参数，将会根据字符串去拆分数组 可以接收一个正则表达式，此时会根据正则表达式去拆分数组 match() 可以根据正则表达式，从一个字符串中将符合条件的内容提取出来 默认情况下我们的match只会找到第一个符合要求的内容，找到以后就停止检索 我们可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容 可以为一个正则表达式设置多个匹配模式，且顺序无所谓 match()会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果 replace() 可以将字符串中指定内容替换为新的内容 参数： 1.被替换的内容，可以接受一个正则表达式作为参数 2.新的内容 空串则为删除”\" 默认只会替换第一个 search() 可以搜索字符串中是否含有指定内容 如果搜索到指定内容，则会返回第一次出现的索引，如果没有搜索到返回1 它可以接受一个正则表达式作为参数，然后会根据正则表达式去检索字符串 serach()只会查找第一个，即使设置全局匹配也没用 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:4:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#正则表达相关方法"},{"categories":["前端"],"content":"正则表达式正则用来定义一些字符串的规则，程序可以根据这些规则来判断一个字符串是否符合规则， 也可以将一个字符串中符合规则的内容提取出来。 创建正则表达式 var reg = new RegExp(“正则”,“匹配模式”); 注意：使用构造函数时，由于它的参数是一个字符串，而\\是字符串中转义字符，如果要使用\\则需要使用\\来代替 var reg = /正则表达式/匹配模式 （匹配模式可以多个一起写：/gi） ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:0:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#正则表达式"},{"categories":["前端"],"content":"语法：匹配模式： i:忽略大小写（ignore） g:全局匹配模式（默认为1次） 设置匹配模式时，可以都不设置，也可以设置1个，也可以全设置，设置时没有顺序要求 正则语法 | 或 [] 或 [^ ] 除了 **[x-y] x的ascii到y的ascii码之间的值** [a-z] 小写字母 （也可以[e-i]) [A-Z] 大写字母 [A-z] 任意字母,但是还包括了其他ASCII在此之中的 [0-9] 任意数字 [abc12] a或b或c或1或2 元符号 检查一个字符串中是否含有 . . 表示任意字符 在正则表达式中使用\\作为转义字符 . 来表示. \\ 表示\\ \\w 任意字母、数字、_ [A-z0-9_] \\W 除了字母、数字、_ [ ^A-z0-9_] \\d 任意的数字 [0-9] \\D 除了数字 [ ^0-9] \\s 空格 \\S 除了空格 \\b 单词边界 \\B 除了单词边界 量词 通过量词可以设置一个内容出现的次数 量词只对它前边的一个内容起作用 {n} 正好出现n次 {m,n} 出现mn次 {m,} m次以上 +至少一个，相当于{1,} *个或多个，相当于{0,} ? 0个或1个，相当于{0,1} 边界表达式（不要在java中用，javaScript中用） ^:正则开始 $:正则结束 ：注意结束前一个才是结束匹配 reg = /^a/; reg = /b$/; ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:1:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#语法"},{"categories":["前端"],"content":"方法：test() 可以用来检查一个字符串是否符合正则表达式 如果符合返回true，否则返回false 例子 去掉两端的空格: var s = \" f afa \"; s = s.replace(/^\\s*|\\s*$/g,\"\"); ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:2:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#方法-1"},{"categories":["前端"],"content":"DOMHTML DOM树（文档对象模型） Document Object Model 文档对象模型，通过DOM可以来任意来修改网页中各个内容 文档 文档指的是网页，一个网页就是一个文档 对象 对象指将网页中的每一个节点都转换为对象 转换完对象以后，就可以以一种纯面向对象的形式来操作网页了 模型 模型用来表示节点和节点之间的关系，方便操作页面 节点（Node） 节点是构成网页的最基本的单元，网页中的每一个部分都可以称为是一个节点 虽然都是节点，但是节点的类型却是不同的 常用的节点 文档节点 （Document），代表整个网页 元素节点（Element），代表网页中的标签 属性节点（Attribute），代表标签中的属性 文本节点（Text），代表网页中的文本内容 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:0:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#dom"},{"categories":["前端"],"content":"DOM操作DOM查询 在网页中浏览器已经为我们提供了document对象， 它代表的是整个网页，它是window对象的属性，可以在页面中直接使用。 document查询方法： 根据元素的id属性查询一个元素节点对象： document.getElementById(“id属性值”); 根据元素的name属性值查询一组元素节点对象: document.getElementsByName(“name属性值”); 根据标签名来查询一组元素节点对象： document.getElementsByTagName(“标签名”); 元素的属性： 读取元素的属性： 语法：元素.属性名 例子：ele.name ele.id ele.value ele.className 注意：class属性不能采用这种方式， 读取class属性时需要使用 元素.className 修改元素的属性： 语法：元素.属性名 = 属性值 innerHTML 使用该属性可以获取或设置元素内部的HTML代码 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:1:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#dom操作"},{"categories":["前端"],"content":"事件（Event）事件指的是用户和浏览器之间的交互行为。比如：点击按钮、关闭窗口、鼠标移动。。。 我们可以为事件来绑定回调函数来响应事件。 绑定事件的方式： 1.可以在标签的事件属性中设置相应的JS代码 例子： \u003cbutton onclick=\"js代码。。。\"\u003e按钮\u003c/button\u003e 2.可以通过为对象的指定事件属性设置回调函数的形式来处理事件 例子： \u003cbutton id=\"btn\"\u003e按钮\u003c/button\u003e \u003cscript\u003e var btn = document.getElementById(\"btn\"); btn.onclick = function(){ }; \u003c/script\u003e 文档的加载 浏览器在加载一个页面时，是按照自上向下的顺序加载的，加载一行执行一行。 如果将js代码编写到页面的上边，当代码执行时，页面中的DOM对象还没有加载， 此时将会无法正常获取到DOM对象，导致DOM操作失败。 解决方式一： 可以将js代码编写到body的下边 \u003cbody\u003e \u003cbutton id=\"btn\"\u003e按钮\u003c/button\u003e \u003cscript\u003e var btn = document.getElementById(\"btn\"); btn.onclick = function(){ }; \u003c/script\u003e \u003c/body\u003e 解决方式二： 将js代码编写到window.onload = function(){}中 window.onload 对应的回调函数会在整个页面加载完毕以后才执行， 所以可以确保代码执行时，DOM对象已经加载完毕了 \u003cscript\u003e window.onload = function(){ var btn = document.getElementById(\"btn\"); btn.onclick = function(){ }; }; \u003c/script\u003e ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:2:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#事件event"},{"categories":["前端"],"content":"DOM查询通过具体的元素节点来查询 元素.getElementsByTagName() 通过标签名查询当前元素的指定后代元素 子节点包括便签元素中的文本，子元素自包含标签元素 元素.childNodes 获取当前元素的所有子节点 会获取到空白的文本子节点 childNodes属性会获取包括文本节点在呢的所有节点 根据DOM标签标签间空白也会当成文本节点 注意：在IE8及以下的浏览器中，不会将空白文本当成子节点， 所以该属性在IE8中会返回4个子元素而其他浏览器是9个 元素.children 获取当前元素的所有子元素 元素.firstChild 获取当前元素的第一个子节点，会获取到空白的文本子节点 元素.lastChild 获取当前元素的最后一个子节点 元素.parentNode 获取当前元素的父元素 元素.previousSibling 获取当前元素的前一个兄弟节点 previousElementSibling获取前一个兄弟元素，IE8及以下不支持 元素.nextSibling 获取当前元素的后一个兄弟节点 firstElementChild获取当前元素的第一个子元素 firstElementChild不支持IE8及以下的浏览器， 如果需要兼容他们尽量不要使用 innerHTML和innerText 这两个属性并没有在DOM标准定义，但是大部分浏览器都支持这两个属性 两个属性作用类似，都可以获取到标签内部的内容， 不同是innerHTML会获取到html标签，而innerText会自动去除标签 如果使用这两个属性来设置标签内部的内容时，没有任何区别的 读取标签内部的文本内容 h1中的文本内容 元素.firstChild.nodeValue ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:3:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#dom查询"},{"categories":["前端"],"content":"document对象的其他的属性和方法document.all 获取页面中的所有元素，相当于document.getElementsByTagName(\"*\"); document.documentElement 获取页面中html根元素 document.body 获取页面中的body元素 document.getElementsByClassName() 根据元素的class属性值查询一组元素节点对象 这个方法不支持IE8及以下的浏览器 document.querySelector() 根据CSS选择器去页面中查询一个元素 如果匹配到的元素有多个，则它会返回查询到的第一个元素 document.querySelectorAll() 根据CSS选择器去页面中查询一组元素 会将匹配到所有元素封装到一个数组中返回，即使只匹配到一个 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:4:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#document对象的其他的属性和方法"},{"categories":["前端"],"content":"DOM修改document.createElement(“TagName”) 可以用于创建一个元素节点对象， 它需要一个标签名作为参数，将会根据该标签名创建元素节点对象， 并将创建好的对象作为返回值返回 document.createTextNode(“textContent”) 可以根据文本内容创建一个文本节点对象 父节点.appendChild(子节点) 向父节点中添加指定的子节点 父节点.insertBefore(新节点,旧节点) 将一个新的节点插入到旧节点的前边 父节点.replaceChild(新节点,旧节点) 使用一个新的节点去替换旧节点 父节点.removeChild(子节点) 删除指定的子节点 推荐方式：子节点.parentNode.removeChild(子节点) 以上方法，实际就是改变了相应元素（标签）的innerHTML的值。 myClick(\"btn07\",function(){ //向city中添加广州 var city = document.getElementById(\"city\"); /* * 使用innerHTML也可以完成DOM的增删改的相关操作 * 一般我们会两种方式结合使用 */ //city.innerHTML += \"\u003cli\u003e广州\u003c/li\u003e\"; //创建一个li var li = document.createElement(\"li\"); //向li中设置文本 li.innerHTML = \"广州\"; //将li添加到city中 city.appendChild(li); }); ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:5:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#dom修改"},{"categories":["前端"],"content":"DOM对CSS的操作","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:6:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#dom对css的操作"},{"categories":["前端"],"content":"读取和修改内联样式使用style属性来操作元素的内联样式 读取内联样式： 语法：元素.style.样式名 例子： 元素.style.width 元素.style.height 注意：如果样式名中带有-，则需要将样式名修改为驼峰命名法将-去掉，然后后的字母改大写 比如：backgroundcolor \u003e backgroundColor borderwidth \u003e borderWidth 修改内联样式： 语法：元素.style.样式名 = 样式值 通过style修改和读取的样式都是内联样式，由于内联样式的优先级比较高， 所以我们通过JS来修改的样式，往往会立即生效， 但是如果样式中设置了!important，则内联样式将不会生效。 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:6:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#读取和修改内联样式"},{"categories":["前端"],"content":"读取元素的当前样式正常浏览器 使用getComputedStyle() 这个方法是window对象的方法，可以返回一个对象，这个对象中保存着当前元素生效样式 参数： 1.要获取样式的元素 2.可以传递一个伪元素，一般传null 例子： 获取元素的宽度 getComputedStyle(box , null)[“width”]; 通过该方法读取到样式都是只读的不能修改 IE8 使用currentStyle 语法： 元素.currentStyle.样式名 例子： box.currentStyle[“width”] 通过这个属性读取到的样式是只读的不能修改 实现兼容性 //对象.属性不存在，不会报错，如果直接寻找对象，（当前作用域到全局作用域）找不到会报错 /* * 定义一个函数，用来获取指定元素的当前的样式 * 参数： * obj 要获取样式的元素 * name 要获取的样式名 */ function getStyle(obj , name){ //对象.属性不存在，不会报错，如果直接寻找对象，（当前作用域到全局作用域）找不到会报错 if(window.getComputedStyle){ //正常浏览器的方式，具有getComputedStyle()方法 return getComputedStyle(obj , null)[name]; }else{ //IE8的方式，没有getComputedStyle()方法 return obj.currentStyle[name]; } //return window.getComputedStyle?getComputedStyle(obj , null)[name]:obj.currentStyle[name]; } ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:6:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#读取元素的当前样式"},{"categories":["前端"],"content":"其他的样式相关的属性注意：以下样式都是只读的,未指明偏移量都是相对于当前窗口左上角 clientHeight 元素的可见高度，包括元素的内容区和内边距的高度 clientWidth 元素的可见宽度，包括元素的内容区和内边距的宽度 offsetHeight 整个元素的高度，包括内容区、内边距、边框 offfsetWidth 整个元素的宽度，包括内容区、内边距、边框 offsetParent 当前元素的定位父元素 离他最近的开启了定位的祖先元素，如果所有的元素都没有开启定位，则返回body offsetLeft offsetTop 当前元素和定位父元素之间的偏移量 offsetLeft水平偏移量 offsetTop垂直偏移量 scrollHeight scrollWidth 获取元素滚动区域的高度和宽度 scrollTop scrollLeft 获取元素垂直和水平滚动条滚动的距离 判断滚动条是否滚动到底 垂直滚动条 scrollHeight -scrollTop = clientHeight 水平滚动 scrollWidth -scrollLeft = clientWidth ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:6:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#其他的样式相关的属性"},{"categories":["前端"],"content":"事件（Event）","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:0:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#事件event-1"},{"categories":["前端"],"content":"事件对象当响应函数被调用时，浏览器每次都会将一个事件对象作为实参传递进响应函数中，这个事件对象中封装了当前事件的相关信息，比如：鼠标的坐标，键盘的按键，鼠标的按键，滚轮的方向。。 可以在响应函数中定义一个形参，来使用事件对象，但是在IE8以下浏览器中事件对象没有做完实参传递，而是作为window对象的属性保存 例子： 元素.事件 = function(event){ event = event || window.event; }; 元素.事件 = function(e){ e = e || event; }; 获取到鼠标的坐标 clientX和clientY 用于获取鼠标在当前的可见窗口的坐标 div的偏移量，是相对于整个页面的 pageX和pageY 可以获取鼠标相对于当前页面的坐标 但是这个两个属性在IE8中不支持，所以如果需要兼容IE8，则不要使用 var left = event.clientX; var　top = event.clientY; ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:1:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#事件对象"},{"categories":["前端"],"content":"事件的冒泡（Bubble）事件的冒泡指的是事件向上传导，当后代元素上的事件被触发时，将会导致其祖先元素上的同类事件也会触发。 事件的冒泡大部分情况下都是有益的，如果需要取消冒泡，则需要使用事件对象来取消 可以将事件对象的cancelBubble设置为true，即可取消冒泡 例子： 元素.事件 = function(event){ event = event || window.event; event.cancelBubble = true; }; ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:2:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#事件的冒泡bubble"},{"categories":["前端"],"content":"事件的委派指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件。 事件委派是利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能 我们希望，只绑定一次事件，即可应用到多个的元素上，即使元素是后添加的 我们可以尝试将其绑定给元素的共同的祖先元素 target : event中的target表示的触发事件的对象 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:3:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#事件的委派"},{"categories":["前端"],"content":"事件的绑定addEventListener() 通过这个方法也可以为元素绑定响应函数 参数： 1.事件的字符串，不要on 2.回调函数，当事件触发时该函数会被调用 3.是否在捕获阶段触发事件，需要一个布尔值，一般都传false 使用addEventListener()可以同时为一个元素的相同事件同时绑定多个响应函数， 这样当事件被触发时，响应函数将会按照函数的绑定顺序执行 这个方法不支持IE8及以下的浏览器 btn01.addEventListener(\"click\",function(){ alert(1); },false); btn01.addEventListener(\"click\",function(){ alert(2); },false); attachEvent() 在IE8中可以使用attachEvent()来绑定事件 参数： 1.事件的字符串，要on 2.回调函数 这个方法也可以同时为一个事件绑定多个处理函数， 不同的是它是后绑定先执行，执行顺序和addEventListener()相反 btn01.attachEvent(\"onclick\",function(){ alert(1); }); btn01.attachEvent(\"onclick\",function(){ alert(2); }); //定义一个函数，用来为指定元素绑定响应函数 /* * addEventListener()中的this，是绑定事件的对象 * attachEvent()中的this，是window * 需要统一两个方法this */ /* * 参数： * obj 要绑定事件的对象 * eventStr 事件的字符串(不要on) * callback 回调函数 */ function bind(obj , eventStr , callback){ if(obj.addEventListener){ //大部分浏览器兼容的方式 obj.addEventListener(eventStr , callback , false); }else{ /* * this是谁由调用方式决定 * callback.call(obj) */ //IE8及以下 obj.attachEvent(\"on\"+eventStr , function(){ //在匿名函数中调用回调函数 callback.call(obj); }); } } ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:4:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#事件的绑定"},{"categories":["前端"],"content":"事件的传播关于事件的传播网景公司和微软公司有不同的理解 微软公司认为事件应该是由内向外传播，也就是当事件触发时，应该先触发当前元素上的事件， 然后再向当前元素的祖先元素上传播，也就说事件应该在冒泡阶段执行。 网景公司认为事件应该是由外向内传播的，也就是当前事件触发时，应该先触发当前元素的最外层的祖先元素的事件， 然后在向内传播给后代元素 W3C综合了两个公司的方案，将事件传播分成了三个阶段 1.捕获阶段 在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触发事件 2.目标阶段 事件捕获到目标元素，捕获结束开始在目标元素上触发事件 3.冒泡阶段 事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件 如果希望在捕获阶段就触发事件，可以将addEventListener()的第三个参数设置为true 一般情况下我们不会希望在捕获阶段触发事件，所以这个参数一般都是false IE8及以下的浏览器中没有捕获阶段 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:5:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#事件的传播"},{"categories":["前端"],"content":"常用事件","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:6:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#常用事件"},{"categories":["前端"],"content":"鼠标事件拖拽事件 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e\u003c/title\u003e \u003cstyle type=\"text/css\"\u003e #box1{ width: 100px; height: 100px; background-color: red; position: absolute; } #box2{ width: 100px; height: 100px; background-color: yellow; position: absolute; left: 200px; top: 200px; } \u003c/style\u003e \u003cscript type=\"text/javascript\"\u003e window.onload = function(){ /* * 拖拽box1元素 * - 拖拽的流程 * 1.当鼠标在被拖拽元素上按下时，开始拖拽 onmousedown * 2.当鼠标移动时被拖拽元素跟随鼠标移动 onmousemove * 3.当鼠标松开时，被拖拽元素固定在当前位置 onmouseup */ //获取box1 var box1 = document.getElementById(\"box1\"); var box2 = document.getElementById(\"box2\"); var img1 = document.getElementById(\"img1\"); //开启box1的拖拽 drag(box1); //开启box2的 drag(box2); drag(img1); }; /* * 提取一个专门用来设置拖拽的函数 * 参数：开启拖拽的元素 */ function drag(obj){ //当鼠标在被拖拽元素上按下时，开始拖拽 onmousedown obj.onmousedown = function(event){ //设置box1捕获所有鼠标按下的事件 /* * setCapture() * - 只有IE支持，但是在火狐中调用时不会报错， * 而如果使用chrome调用，会报错 */ /*if(box1.setCapture){ box1.setCapture(); }*/ obj.setCapture \u0026\u0026 obj.setCapture(); event = event || window.event; //div的偏移量 鼠标.clentX - 元素.offsetLeft //div的偏移量 鼠标.clentY - 元素.offsetTop var ol = event.clientX - obj.offsetLeft; var ot = event.clientY - obj.offsetTop; //为document绑定一个onmousemove事件 document.onmousemove = function(event){ event = event || window.event; //当鼠标移动时被拖拽元素跟随鼠标移动 onmousemove //获取鼠标的坐标 var left = event.clientX - ol; var top = event.clientY - ot; //修改box1的位置 obj.style.left = left+\"px\"; obj.style.top = top+\"px\"; }; //为document绑定一个鼠标松开事件 document.onmouseup = function(){ //当鼠标松开时，被拖拽元素固定在当前位置 onmouseup //取消document的onmousemove事件 document.onmousemove = null; //取消document的onmouseup事件 document.onmouseup = null; //当鼠标松开时，取消对事件的捕获 obj.releaseCapture \u0026\u0026 obj.releaseCapture(); }; /* * 当我们拖拽一个网页中的内容时，浏览器会默认去搜索引擎中搜索内容， * 此时会导致拖拽功能的异常，这个是浏览器提供的默认行为， * 如果不希望发生这个行为，则可以通过return false来取消默认行为 * * 但是这招对IE8不起作用 */ return false; }; } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e 我是一段文字 \u003cdiv id=\"box1\"\u003e\u003c/div\u003e \u003cdiv id=\"box2\"\u003e\u003c/div\u003e \u003cimg src=\"img/an.jpg\" id=\"img1\" style=\"position: absolute;\"/\u003e \u003c/body\u003e \u003c/html\u003e 滚轮事件： onwheel都支持 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e\u003c/title\u003e \u003cstyle type=\"text/css\"\u003e #box1{ width: 100px; height: 100px; background-color: red; } \u003c/style\u003e \u003cscript type=\"text/javascript\"\u003e window.onload = function(){ //获取id为box1的div var box1 = document.getElementById(\"box1\"); //为box1绑定一个鼠标滚轮滚动的事件 /* * onmousewheel鼠标滚轮滚动的事件，会在滚轮滚动时触发， * 但是火狐不支持该属性 * * 在火狐中需要使用 DOMMouseScroll 来绑定滚动事件 * 注意该事件需要通过addEventListener()函数来绑定 */ box1.onmousewheel = function(event){ event = event || window.event; //event.wheelDelta 可以获取鼠标滚轮滚动的方向 //向上滚 120 向下滚 -120 //wheelDelta这个值我们不看大小，只看正负 //alert(event.wheelDelta); //wheelDelta这个属性火狐中不支持 //在火狐中使用event.detail来获取滚动的方向 //向上滚 -3 向下滚 3 //alert(event.detail); /* * 当鼠标滚轮向下滚动时，box1变长 * 当滚轮向上滚动时，box1变短 */ //判断鼠标滚轮滚动的方向 if(event.wheelDelta \u003e 0 || event.detail \u003c 0){ //向上滚，box1变短 box1.style.height = box1.clientHeight - 10 + \"px\"; }else{ //向下滚，box1变长 box1.style.height = box1.clientHeight + 10 + \"px\"; } /* * 使用addEventListener()方法绑定响应函数，取消默认行为时不能使用return false * 需要使用event来取消默认行为event.preventDefault(); * 但是IE8不支持event.preventDefault();这个玩意，如果直接调用会报错 */ event.preventDefault \u0026\u0026 event.preventDefault(); /* * 当滚轮滚动时，如果浏览器有滚动条，滚动条会随之滚动， * 这是浏览器的默认行为，如果不希望发生，则可以取消默认行为 */ return false; }; //为火狐绑定滚轮事件 bind(box1,\"DOMMouseScroll\",box1.onmousewheel); }; function bind(obj , eventStr , callback){ if(obj.addEventListener){ //大部分浏览器兼容的方式 obj.addEventListener(eventStr , callback , false); }else{ /* * this是谁由调用方式决定 * callback.call(obj) */ //IE8及以下 obj.attachEvent(\"on\"+eventStr , function(){ //在匿名函数中调用回调函数 callback.call(obj); }); } } \u003c/script\u003e \u003c/head\u003e \u003cbody style=\"height: 2000px;\"\u003e \u003cdiv id=\"box1\"\u003e\u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:6:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#鼠标事件"},{"categories":["前端"],"content":"键盘事件键盘事件： onkeydown 按键被按下 对于onkeydown来说如果一直按着某个按键不松手，则事件会一直触发 当onkeydown连续触发时，第一次和第二次之间会间隔稍微长一点，其他的会非常的快，这种设计是为了防止误操作的发生。 onkeyup 按键被松开 键盘事件一般都会绑定给一些可以获取到焦点的对象或者是document keyCode 可以通过keyCode来获取按键的编码 通过它可以判断哪个按键被按下 除了keyCode，事件对象中还提供了几个属性 altKey ctrlKey shiftKey 这个三个用来判断alt ctrl 和 shift是否被按下 如果按下则返回true，否则返回false //console.log(event.keyCode); //判断一个y是否被按下 //判断y和ctrl是否同时被按下 if(event.keyCode === 89 \u0026\u0026 event.ctrlKey){ console.log(\"ctrl和y都被按下了\"); } input.onkeydown = function(event) { event = event || window.event; //数字 48 - 57 //使文本框中不能输入数字 if(event.keyCode \u003e= 48 \u0026\u0026 event.keyCode \u003c= 57) { //在文本框中输入内容，属于onkeydown的默认行为 //如果在onkeydown中取消了默认行为，则输入的内容，不会出现在文本框中 return false; } }; ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:6:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#键盘事件"},{"categories":["前端"],"content":"BOM浏览器对象模型(browser object model) BOM可以使我们通过JS来操作浏览器 在BOM中为我们提供了一组对象，用来完成对浏览器的操作 BOM对象 Window 代表的是整个浏览器的窗口，同时window也是网页中的全局对象 Navigator 代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器 Location 代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面 History 代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录 由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页 而且该操作只在当次访问时有效 Screen 代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息 这些BOM对象在浏览器中都是作为window对象的属性保存的，全局对象。 可以通过window对象来使用，也可以直接使用 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:0:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#bom"},{"categories":["前端"],"content":"Navigator代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器 由于历史原因，Navigator对象中的大部分属性都已经不能帮助我们识别浏览器了 一般我们只会使用userAgent来判断浏览器的信息， userAgent是一个字符串，这个字符串中包含有用来描述浏览器信息的内容， 不同的浏览器会有不同的userAgent 火狐的userAgent Mozilla5.0 (Windows NT 6.1; WOW64; rv:50.0) Gecko20100101 Firefox50.0 Chrome的userAgent Mozilla5.0 (Windows NT 6.1; Win64; x64) AppleWebKit537.36 (KHTML, like Gecko) Chrome52.0.2743.82 Safari537.36 IE8 Mozilla4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E) IE9 Mozilla5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E) IE10 Mozilla5.0 (compatible; MSIE 10.0; Windows NT 6.1; WOW64; Trident7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E) IE11 Mozilla5.0 (Windows NT 6.1; WOW64; Trident7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; rv:11.0) like Gecko 在IE11中已经将微软和IE相关的标识都已经去除了，所以我们基本已经不能通过UserAgent来识别一个浏览器是否是IE了 alert(navigator.appName); var ua = navigator.userAgent; console.log(ua); if(firefoxi.test(ua)){ alert(\"你是火狐！！！\"); }else if(chromei.test(ua)){ alert(\"你是Chrome\"); }else if(msiei.test(ua)){ alert(\"你是IE浏览器~~~\"); }else if(\"ActiveXObject\" in window){ alert(\"你是IE11，枪毙了你~~~\"); } ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:1:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#navigator"},{"categories":["前端"],"content":"History对象可以用来操作浏览器向前或向后翻页 length 属性，可以获取到当成访问的链接数量 back() 可以用来回退到上一个页面，作用和浏览器的回退按钮一样 forward() 可以跳转下一个页面，作用和浏览器的前进按钮一样 go() 可以用来跳转到指定的页面 它需要一个整数作为参数 1:表示向前跳转一个页面 相当于forward() 2:表示向前跳转两个页面 -1:表示向后跳转一个页面 -2:表示向后跳转两个页面 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:2:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#history"},{"categories":["前端"],"content":"Location该对象中封装了浏览器的地址栏的信息 如果直接打印location，则可以获取到地址栏的信息（当前页面的完整路径） alert(location); 如果直接将location属性修改为一个完整的路径，或相对路径 则我们页面会自动跳转到该路径，并且会生成相应的历史记录 location = “http:www.baidu.com”; location = “01.BOM.html”; assign() 用来跳转到其他的页面，作用和直接修改location一样 reload() 用于重新加载当前页面，作用和刷新按钮一样 如果在方法中传递一个true，作为参数，则会强制清空缓存刷新页面 location.reload(true); replace() 可以使用一个新的页面替换当前页面，调用完毕也会跳转页面 不会生成历史记录，不能使用回退按钮回退 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:3:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#location"},{"categories":["前端"],"content":"window","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:4:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#window"},{"categories":["前端"],"content":"定时器setInterval() 定时调用 可以将一个函数，每隔一段时间执行一次 参数： 1.回调函数，该函数会每隔一段时间被调用一次 2.每次调用间隔的时间，单位是毫秒 返回值： 返回一个Number类型的数据 这个数字用来作为定时器的唯一标识 clearInterval()可以用来关闭一个定时器 方法中需要一个定时器的标识作为参数，这样将关闭标识对应的定时器 clearInterval()可以接收任意参数， 如果参数是一个有效的定时器的标识，则停止对应的定时器 如果参数不是一个有效的标识，则什么也不做 var num = 1; var timer = setInterval(function() { count.innerHTML = num++; if(num == 11) { //关闭定时器 clearInterval(timer); } }, 1000); **setInterval()**绑定给某个元素时，可以通过先调用clearInterval()方法清理掉已生成的定时器方式来避免同时生成多个不必要的定时器。 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:4:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#定时器"},{"categories":["前端"],"content":"延时调用setTimeout 延时调用一个函数不马上执行，而是隔一段时间以后在执行，而且只会执行一次 延时调用和定时调用的区别，定时调用会执行多次，而延时调用只会执行一次 延时调用和定时调用实际上是可以互相代替的，在开发中可以根据自己需要去选择 var timer = setTimeout(function(){ console.log(num++); },3000); 使用clearTimeout()来关闭一个延时调用 clearTimeout(timer); #类的操作 直接修改元素的类css： 通过style属性来修改元素的样式，每修改一个样式，浏览器就需要重新渲染一次页面。 这样的执行的性能是比较差的，而且这种形式当我们要修改多个样式时，也不太方便 我希望一行代码，可以同时修改多个样式 我们可以通过修改元素的class属性来间接的修改样式.这样一来，我们只需要修改一次，即可同时修改多个样式，浏览器只需要重新渲染页面一次，性能比较好， 并且这种方式，可以使表现和行为进一步的分离 box.className += \" b2\"; //注意有空格，添加class属性 //定义一个函数，用来向一个元素中添加指定的class属性值 /* * 参数: * obj 要添加class属性的元素 * cn 要添加的class值 * */ function addClass(obj, cn) { if (!hasClass(obj, cn)) { obj.className += \" \" + cn; } } /* * 判断一个元素中是否含有指定的class属性值 * 如果有该class，则返回true，没有则返回false * */ function hasClass(obj, cn) { var reg = new RegExp(\"\\\\b\" + cn + \"\\\\b\"); return reg.test(obj.className); } /* * 删除一个元素中的指定的class属性 */ function removeClass(obj, cn) { //创建一个正则表达式 var reg = new RegExp(\"\\\\b\" + cn + \"\\\\b\"); //删除class obj.className = obj.className.replace(reg, \"\"); } /* * toggleClass可以用来切换一个类 * 如果元素中具有该类，则删除 * 如果元素中没有该类，则添加 */ function toggleClass(obj , cn){ //判断obj中是否含有cn if(hasClass(obj , cn)){ //有，则删除 removeClass(obj , cn); }else{ //没有，则添加 addClass(obj , cn); } } ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:4:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#延时调用"},{"categories":["前端"],"content":"JSONJavaScript Object Notation JS对象表示法 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:0:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#json"},{"categories":["前端"],"content":"JSON 格式 复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。 原始类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和null（不能使用NaN, Infinity, -Infinity和undefined）。 字符串必须使用双引号表示，不能使用单引号。 对象的键名必须放在双引号里面。 数组或对象最后一个成员的后面，不能加逗号。 JS中的对象只有JS自己认识，其他的语言都不认识 JSON就是一个特殊格式的字符串，这个字符串可以被任意的语言所识别， 并且可以转换为任意语言中的对象，JSON在开发中主要用来数据的交互 JSON和JS对象的格式一样，只不过JSON字符串中的属性名必须加双引号 其他的和JS语法一致 JSON分类： 1.对象 {} 2.数组 [] JSON中允许的值： 1.字符串 2.数值 3.布尔值 4.null 5.对象 6.数组 举例： var arr = '[1,2,3,\"hello\",true]'; var obj2 = '{\"arr\":[1,2,3]}'; var arr2 ='[{\"name\":\"孙悟空\",\"age\":18,\"gender\":\"男\"},{\"name\":\"孙悟空\",\"age\":18,\"gender\":\"男\"}]'; JSON工具类 json \u003e js对象 JSON.parse() 可以将以JSON字符串转换为js对象 它需要一个JSON字符串作为参数，会将该字符串转换为JS对象并返回 var o = JSON.parse(json); var o2 = JSON.parse(arr); var obj3 = {name:“猪八戒” , age:28 , gender:“男”}; JS对象 \u003e JSON JSON.stringify() -ify/fy，表示\"使……化。 可以将一个JS对象转换为JSON字符串 需要一个js对象作为参数，会返回一个JSON字符串 var str = JSON.stringify(obj3); console.log(str); JSON这个对象在IE7及以下的浏览器中不支持，所以在这些浏览器中调用时会报错 ​ ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:1:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#json-格式"},{"categories":["前端"],"content":"other","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:0:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#other"},{"categories":["前端"],"content":"localStorage只读的localStorage 属性允许你访问一个Document 源（origin）的对象 Storage；其存储的数据能在跨浏览器会话保留。localStorage 类似 sessionStorage，但其区别在于：存储在 localStorage 的数据可以长期保留；而当页面会话结束——也就是说，当页面被关闭时，存储在 sessionStorage 的数据会被清除 。 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:1:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#localstorage"},{"categories":["前端"],"content":"eval()eval() 这个函数可以用来执行一段字符串形式的JS代码，并将执行结果返回 如果使用eval()执行的字符串中含有{},它会将{}当成是代码块 如果不希望将其当成代码块解析，则需要在字符串前后各加一个() eval()这个函数的功能很强大，可以直接执行一个字符串中的js代码， 但是在开发中尽量不要使用，首先它的执行性能比较差，然后它还具有安全隐患 var str = '{\"name\":\"孙悟空\",\"age\":18,\"gender\":\"男\"}'; var obj = eval(\"(\"+str+\")\"); 编码 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e /* * 在字符串中使用转义字符输入Unicode编码 * \\u四位编码 */ console.log(\"\\u2620\"); \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003c!--在网页中使用Unicode编码 \u0026#编码; 这里的编码需要的是10进制 --\u003e \u003ch1 style=\"font-size: 200px;\"\u003e\u0026#9760;\u003c/h1\u003e \u003ch1 style=\"font-size: 200px;\"\u003e\u0026#9856;\u003c/h1\u003e \u003c/body\u003e \u003c/html\u003e confirm()用于弹出一个带有确认和取消按钮的提示框 需要一个字符串作为参数，该字符串将会作为提示文字显示出来 如果用户点击确认则会返回true，如果点击取消则返回false var flag = confirm(“确认删除”+name+“吗?\"); ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:2:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#eval"},{"categories":["前端"],"content":"# 原生js","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:3:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#-原生js"},{"categories":["前端"],"content":"原生js实现复制内容到剪切板 copy() { const input = document.createElement(\"input\"); document.body.appendChild(input); input.setAttribute(\"value\",this.solution.code); input.select(); if (document.execCommand(\"copy\")) { document.execCommand(\"copy\"); // console.log(\"复制成功\"); } document.body.removeChild(input); } ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:4:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#原生js实现复制内容到剪切板"},{"categories":["前端"],"content":"常用","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:0:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#常用"},{"categories":["前端"],"content":"ElementtagName：返回元素名 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/:1:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】JavaScript","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E7%AB%A0javascript/#element"},{"categories":["前端"],"content":"CSSCSS控制页面的表现。 层叠样式表。网页实际上是多层结构，通过CSS可以分别为网页的每层设置样式，最终我们只看到最上面一层。 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC2%E7%AB%A0CSS3/:0:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】CSS3","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC2%E7%AB%A0CSS3/#css"},{"categories":["前端"],"content":"使用方式 第一种 内联样式、行内样式： 在标签内部通过style属性来设置。 \u003cp style=\"color: red; font-size: 30px;\"\u003e红色\u003c/p\u003e 第二种 内部样式表： 在head元素的style标签中编写 \u003chead\u003e \u003cstyle\u003e p{ color: green; font-size: 60px; } \u003c/style\u003e \u003c/head\u003e 第三种 外部样式表： 将css样式编写到一个外部css文件中，然后通过link标签来引入外部css文件 \u003clink rel=\"stylesheet\" href=\"./style.css\"\u003e ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC2%E7%AB%A0CSS3/:1:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】CSS3","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC2%E7%AB%A0CSS3/#使用方式"},{"categories":["前端"],"content":"CSS语法 注释： /* CSS的注释 */ 快捷键：ctrl + / ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC2%E7%AB%A0CSS3/:2:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】CSS3","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC2%E7%AB%A0CSS3/#css语法"},{"categories":["前端"],"content":"选择器、声明块（w3school）： 元素选择器： 通过选择器可以选中页面中指定元素 通过声明块来指定选择元素的样式 \u003cstyle\u003e /* 用法：选择器{ 声明块 } 例子：p{} h1{} div{} */ /* p元素样式 */ p{color: red; font-size: 30px;} /* h1元素样式 */ h1{color: blue;} \u003c/style\u003e 分组选择器： 符合多个条件并集的选择器 语法：选择器1,选择器2,选择器n{} /* p元素或者h1元素字体颜色为绿色 */ p,h1{color: green;} /* p元素或者h1元素字体颜色为绿色 */ p.class1,h1.class2{color: green;} id选择器： 根据元素的id属性值选中一个元素，id不能重复 在一个 HTML 文档中，ID 选择器会使用一次，而且仅一次 ID 选择器不能结合使用，因为 ID 属性不允许有以空格分隔的词列表。 ID 选择器可能是区分大小写的。这取决于文档的语言。 #id{color: red;} class 类选择器： 根据元素的class属性值选中一个元素，class可重复 一个元素可以指定多个class .class{color: red;} p.class{color: red;} p.class1.class2{color: red;} 通配选择器： 选中页面所有元素 *{color: red;} 复合选择器： 选中同时符合多个条件的元素 语法：选择器1选择器2选择器n{} /* div元素class=class1的字体颜色为红色 */ div.class1{color: red;} /* p元素class=class1 class2的字体颜色为蓝色 */ p.class1.class2{color: blue;} 关系选择器： 父元素 子元素：选择子元素 语法：父元素 \u003e 子元素 \u003e 子元素n {} /* p中的span元素颜色为红色 */ p \u003e span{color: red;} /* div中的p元素（包括p中的其他元素）颜色为橙色 */ div \u003e p{color: orange;} /* div中的p元素中的span元素颜色为橙色 */ div \u003e p \u003e span{color: orange;} 祖先元素 后代元素：选择后代元素 语法：祖先元素 后代元素 {} /* div中及后代的span元素颜色为橙色 */ div span{color: orange;} 兄弟元素： 选择下一个兄弟元素 语法：兄弟元素1 + 兄弟元素2 {} 选择下边所有元素 语法：兄弟元素1 ~ 兄弟元素2 {} 属性选择器： [属性名] 选择有指定属性名的元素 [属性名=属性值] 选择有指定属性名和属性值的元素 [属性名~=属性值] 根据部分属性值选择 [属性名^=属性值] 选择属性值以指定值开头的元素 [属性名$=属性值] 选择属性值以指定值结尾的元素 [属性名*=属性值] 选择属性值包含指定值的元素 p[title]{color: orange;} div[class=class1]{color: orange;} div[class=class1][title]{color: orange;} 伪类选择器： 用来描述一个元素的特殊状态，如第一个子元素、被点击的元素、鼠标移入的元素 一般情况下使用 : 开头 /* 如果li是ul的第一个子元素则字体红色 */ ul \u003e li:first-child{ color: red; } /* 如果li是ul的最后一个子元素则字体红色 */ ul \u003e li:last-child{ color: red; } /* 如果li是ul的第n个子元素 */ ul \u003e li:nth-child(){ color: red; } /* 每种类型的第一个元素颜色为红色 */ ul \u003e :first-of-type{color: red;} /* 除了每种类型的第一个元素，其他元素颜色为红色 ul \u003e not(:first-of-type){color: red;} ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC2%E7%AB%A0CSS3/:3:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】CSS3","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC2%E7%AB%A0CSS3/#选择器声明块w3schoolhttpswwww3schoolcomcncssrefcss_selectorsasp"},{"categories":["前端"],"content":"选择器例子 选择器 例子 例子描述 .class .intro 选择 class=“intro” 的所有元素。 .class1.class2 .name1.name2 选择 class 属性中同时有 name1 和 name2 的所有元素。 .class1 .class2 .name1 .name2 选择作为类名 name1 元素后代的所有类名 name2 元素。 #id #firstname 选择 id=“firstname” 的元素。 * * 选择所有元素。 element p 选择所有 元素。 element.class p.intro 选择 class=“intro” 的所有 元素。 element,element div, p 选择所有 元素和所有 元素。 element element div p 选择 元素内的所有 元素。 element\u003eelement div \u003e p 选择父元素是 的所有 元素。 element+element div + p 选择紧跟 元素的首个 元素。 element1~element2 p ~ ul 选择前面有 元素的每个 元素。 [attribute] [target] 选择带有 target 属性的所有元素。 [attribute=value] [target=_blank] 选择带有 target=\"_blank\" 属性的所有元素。 [attribute~=value] [title~=flower] 选择 title 属性包含单词 “flower” 的所有元素。 [attribute|=value] [lang|=en] 选择 lang 属性值以 “en” 开头的所有元素。 [attribute^=value] a[href^=“https”] 选择其 src 属性值以 “https” 开头的每个 元素。 [attribute$=value] a[href$=\".pdf\"] 选择其 src 属性以 “.pdf” 结尾的所有 元素。 [attribute*=value] a[href*=“w3schools”] 选择其 href 属性值中包含 “abc” 子串的每个 元素。 :active a:active 选择活动链接。 ::after p::after 在每个 的内容之后插入内容。 ::before p::before 在每个 的内容之前插入内容。 :checked input:checked 选择每个被选中的 元素。 :default input:default 选择默认的 元素。 :disabled input:disabled 选择每个被禁用的 元素。 :empty p:empty 选择没有子元素的每个 元素（包括文本节点）。 :enabled input:enabled 选择每个启用的 元素。 :first-child p:first-child 选择属于父元素的第一个子元素的每个 元素。 ::first-letter p::first-letter 选择每个 元素的首字母。 ::first-line p::first-line 选择每个 元素的首行。 :first-of-type p:first-of-type 选择属于其父元素的首个 元素的每个 元素。 :focus input:focus 选择获得焦点的 input 元素。 :fullscreen :fullscreen 选择处于全屏模式的元素。 :hover a:hover 选择鼠标指针位于其上的链接。 :in-range input:in-range 选择其值在指定范围内的 input 元素。 :indeterminate input:indeterminate 选择处于不确定状态的 input 元素。 :invalid input:invalid 选择具有无效值的所有 input 元素。 :lang(language) p:lang(it) 选择 lang 属性等于 “it”（意大利）的每个 元素。 :last-child p:last-child 选择属于其父元素最后一个子元素每个 元素。 :last-of-type p:last-of-type 选择属于其父元素的最后 元素的每个 元素。 :link a:link 选择所有未访问过的链接。 :not(selector) :not(p) 选择非 元素的每个元素。 :nth-child(n) p:nth-child(2) 选择属于其父元素的第二个子元素的每个 元素。 :nth-last-child(n) p:nth-last-child(2) 同上，从最后一个子元素开始计数。 :nth-of-type(n) p:nth-of-type(2) 选择属于其父元素第二个 元素的每个 元素。 :nth-last-of-type(n) p:nth-last-of-type(2) 同上，但是从最后一个子元素开始计数。 :only-of-type p:only-of-type 选择属于其父元素唯一的 元素的每个 元素。 :only-child p:only-child 选择属于其父元素的唯一子元素的每个 元素。 :optional input:optional 选择不带 “required” 属性的 input 元素。 :out-of-range input:out-of-range 选择值超出指定范围的 input 元素。 ::placeholder input::placeholder 选择已规定 “placeholder” 属性的 input 元素。 :read-only input:read-only 选择已规定 “readonly” 属性的 input 元素。 :read-write input:read-write 选择未规定 “readonly” 属性的 input 元素。 :required input:required 选择已规定 “required” 属性的 input 元素。 :root :root 选择文档的根元素。 ::selection ::selection 选择用户已选取的元素部分。 :target #news:target 选择当前活动的 #news 元素。 :valid input:valid 选择带有有效值的所有 input 元素。 :visited a:visited 选择所有已访问的链接。 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC2%E7%AB%A0CSS3/:3:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】CSS3","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC2%E7%AB%A0CSS3/#选择器例子"},{"categories":["前端"],"content":"样式的继承 我们为一个元素设置的样式同时也会应用到它的后代元素上。 并不是所有样式都会被继承，比如背景、布局相关不会被继承。 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC2%E7%AB%A0CSS3/:3:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】CSS3","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC2%E7%AB%A0CSS3/#样式的继承"},{"categories":["前端"],"content":"选择器的权重 样式冲突：当通过不同的元素选中相同的元素，并为其属性设置不同的值，此时发生样式冲突，样式展示由选择器权重决定。 权重（优先级）： 内联样式 1,0,0,0 id选择器 0,1,0,0 类和伪类选择器 0,0,1,0 元素选择器 0,0,0,1 通配选择器 0,0,0,0 继承的样式 无权重 !important 获取最高权重 比较权重： 需要将所有的选择器的权重相加计算，最后优先级越高则越优先显示（分组选择器是单独计算的） 选择器权重累加不会超过前一档，比如类选择器再怎么加也不会超过id选择器 如果权重计算相等，则代码从上往下使用下面的样式。 若在某个样式后面添加\"!important\"，则此时样式会获取到最高优先级，超过内联样式。（不要用） ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC2%E7%AB%A0CSS3/:3:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】CSS3","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC2%E7%AB%A0CSS3/#选择器的权重"},{"categories":["前端"],"content":"番外：像素、百分比、em、rem、RGB、RGBA像素：显示器由一个个像素构成，不同屏幕像素大小不同。 分辨率 = 水平方向像素 * 垂直方向像素 百分比：也可以将属性值设置为相对于其父元素属性的百分比，可以使子元素跟随父元素（暂且先理解成父元素，后面会详细说）的改变而改变。 em：相对于元素的字体大小来计算的，1em = \u003cself\u003e.font-size * 10，也就说em值会根据元素本身的字体大小的改变而改变。 rem：相对于根元素的字体大小来计算，1em = \u003croot\u003e.font-size * 10，rem值根据html的字体大小改变。 \u003cstyle\u003e * { font-size: 24px; } .box1{ width: 200px; height: 200px; background-color: orange; } .box2{ width: 50%; height: 50%; background-color: aqua; } .box3{ font-size: 20px; width: 10em; height: 10em; background-color: greenyellow; } .box4 { font-size: 20px; width: 10rem; /*当时用rem时，不管怎么改本元素的font-size都是不会变的。需要定义root元素的font-size才可以 */ height: 10rem; background-color: red; } \u003c/style\u003e \u003cdiv class=\"box1\"\u003e \u003cdiv class=\"box2\"\u003e\u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"box3\"\u003e\u003c/div\u003e \u003cdiv class=\"box4\"\u003e\u003c/div\u003e RGB值：通过三种颜色不同浓度来调配不同的颜色。 R-red，G-green，B-blue 每种颜色范围在“0~255”之间或“0%~100%”。 语法：rgb(255,0,0) RGBA：A表示不透明度 1表示完全不透明 0表示完全透明 .5半透明 十六进制RGB值： 语法：#红色绿色蓝色 颜色浓度通过 00-ff 表示 如果颜色两位两位重复可以进行简写，如#aabbcc =\u003e #abc ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC2%E7%AB%A0CSS3/:4:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】CSS3","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC2%E7%AB%A0CSS3/#番外像素百分比emremrgbrgba"},{"categories":["前端"],"content":"盒模型","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC2%E7%AB%A0CSS3/:5:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】CSS3","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC2%E7%AB%A0CSS3/#盒模型"},{"categories":["前端"],"content":"文档流 normal flow 网页是一个多层的结构，通过CSS可以分别为每一层来设置样式，作为用户来讲只能看到最顶上一层，这些层中最底下的一层称为文档流。 文档流是网页的基础，我们所创建的元素默认都是在文档流中进行排列。元素主要有两个状态： 在文档流中 不在文档流中（脱离文档流） 元素在文档流中的特点： 块元素： 块元素会在页面中独占一行 默认宽度是父元素全部（把父元素撑满） 默认高度被子元素撑开 行内元素： 行内元素不会独占一行，只占自身大小 自左向右水平排列，如果一行中不能容纳下所有行内元素泽远溯洄换到第二行继续自左向右排列 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC2%E7%AB%A0CSS3/:5:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】CSS3","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC2%E7%AB%A0CSS3/#文档流-normal-flow"},{"categories":["前端"],"content":"盒子模型（box model） 网页设计中常听的属性名：内容(content)、内边距(padding)、边框(border)、外边距(margin)， CSS盒子模型都具备这些属性。 这些属性我们可以用日常生活中的常见事物——盒子作一个比喻来理解，所以叫它盒子模型。 CSS盒子模型就是在网页设计中经常用到的CSS技术所使用的一种思维模型。 CSS将页面中的所有元素都设置为了一个矩形的盒子。 盒子可见框的大小，由内容区、内边距和边框共同决定，所以在计算盒子大小时，需要将这三个区域加到一起计算 每一个盒子都由一下几个部分组成： 内容区（content） width、height、background-color color:前景色 内边距（padding）内边距，也叫填充，是内容区和边框之间的空间 padding-top 上内边距 padding-right 右内边距 padding-bottom下内边距 padding-left 左内边距 padding内边距的简写属性，可以同时指定四个方向的内边距，规则和边框中属性值设置一样 边框（border）边框属于盒子边缘，边框里边属于盒子内部，出了边框都是盒子的外部 border-width 边框的宽度：默认3px border-top-width 上边框的宽度 border-right-width 右边框的宽度 border-bottom-width 下边框的宽度 border-left-width 左边框的宽度 border-color 边框的颜色：默认使用color的颜色值 border-top-color 上边框的颜色 border-right-color 右边框的颜色 border-bottom-color 下边框的颜色 border-left-color 左边框的颜色 border-style 边框的样式：没有默认值，必须指定 border-top-style 上边框的样式 border-right-style 右边框的样式 border-bottom-style 下边框的样式 border-left-style 左边框的样式 设定几个值就决定了对应方向的宽度、颜色或样式 四个值：上 右 下 左 三个值：上 左右 下 两个值：上下 左右 一个值：上下左右 其实不管设置几个值，只要记住：其顺序是按顺时针方向设置的，剩下的可以由矩形的对称性推导出来 效果（solid） 效果（dotted） 效果（dashed） 效果（double） 外边距（margin）外边距，也叫空白边，位于盒子的最外围，是添加在边框外周围的空间。空白边使盒子之间不会紧凑地连接在一起，是CSS 布局的一个重要手段 注意：外边距不会影响盒子可见框的大小，但是外边距会影响盒子的位置和占用空间 一共有四个方向的外边距： margin-top 上外边距 设置正值，元素自身向下移动 设置负值，元素自身向上移动 margin-right 右外边距 设置正值，其右边的元素向右移动 设置负值，其右边的元素向左移动 上述说法并不准确，对于块元素，设置margin-right不会产生任何效果 margin-bottom 下外边距 设置正值，其下边的元素向下移动 设置负值，其下边的元素向上移动 上述说法并不准确，对于块元素，会有垂直方向上的边距重叠问题（后面会细说） margin-left 左外边距 设置正值，元素自身向右移动 设置负值，元素自身向左移动 元素在页面中是按照自左向右的顺序排列的，所以默认情况下 如果我们设置的左和上外边距则会移动元素自身 而设置下和右外边距会移动其他元素 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC2%E7%AB%A0CSS3/:5:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】CSS3","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC2%E7%AB%A0CSS3/#盒子模型box-model"},{"categories":["前端"],"content":"盒子模型（box model） 网页设计中常听的属性名：内容(content)、内边距(padding)、边框(border)、外边距(margin)， CSS盒子模型都具备这些属性。 这些属性我们可以用日常生活中的常见事物——盒子作一个比喻来理解，所以叫它盒子模型。 CSS盒子模型就是在网页设计中经常用到的CSS技术所使用的一种思维模型。 CSS将页面中的所有元素都设置为了一个矩形的盒子。 盒子可见框的大小，由内容区、内边距和边框共同决定，所以在计算盒子大小时，需要将这三个区域加到一起计算 每一个盒子都由一下几个部分组成： 内容区（content） width、height、background-color color:前景色 内边距（padding）内边距，也叫填充，是内容区和边框之间的空间 padding-top 上内边距 padding-right 右内边距 padding-bottom下内边距 padding-left 左内边距 padding内边距的简写属性，可以同时指定四个方向的内边距，规则和边框中属性值设置一样 边框（border）边框属于盒子边缘，边框里边属于盒子内部，出了边框都是盒子的外部 border-width 边框的宽度：默认3px border-top-width 上边框的宽度 border-right-width 右边框的宽度 border-bottom-width 下边框的宽度 border-left-width 左边框的宽度 border-color 边框的颜色：默认使用color的颜色值 border-top-color 上边框的颜色 border-right-color 右边框的颜色 border-bottom-color 下边框的颜色 border-left-color 左边框的颜色 border-style 边框的样式：没有默认值，必须指定 border-top-style 上边框的样式 border-right-style 右边框的样式 border-bottom-style 下边框的样式 border-left-style 左边框的样式 设定几个值就决定了对应方向的宽度、颜色或样式 四个值：上 右 下 左 三个值：上 左右 下 两个值：上下 左右 一个值：上下左右 其实不管设置几个值，只要记住：其顺序是按顺时针方向设置的，剩下的可以由矩形的对称性推导出来 效果（solid） 效果（dotted） 效果（dashed） 效果（double） 外边距（margin）外边距，也叫空白边，位于盒子的最外围，是添加在边框外周围的空间。空白边使盒子之间不会紧凑地连接在一起，是CSS 布局的一个重要手段 注意：外边距不会影响盒子可见框的大小，但是外边距会影响盒子的位置和占用空间 一共有四个方向的外边距： margin-top 上外边距 设置正值，元素自身向下移动 设置负值，元素自身向上移动 margin-right 右外边距 设置正值，其右边的元素向右移动 设置负值，其右边的元素向左移动 上述说法并不准确，对于块元素，设置margin-right不会产生任何效果 margin-bottom 下外边距 设置正值，其下边的元素向下移动 设置负值，其下边的元素向上移动 上述说法并不准确，对于块元素，会有垂直方向上的边距重叠问题（后面会细说） margin-left 左外边距 设置正值，元素自身向右移动 设置负值，元素自身向左移动 元素在页面中是按照自左向右的顺序排列的，所以默认情况下 如果我们设置的左和上外边距则会移动元素自身 而设置下和右外边距会移动其他元素 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC2%E7%AB%A0CSS3/:5:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】CSS3","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC2%E7%AB%A0CSS3/#内容区content"},{"categories":["前端"],"content":"盒子模型（box model） 网页设计中常听的属性名：内容(content)、内边距(padding)、边框(border)、外边距(margin)， CSS盒子模型都具备这些属性。 这些属性我们可以用日常生活中的常见事物——盒子作一个比喻来理解，所以叫它盒子模型。 CSS盒子模型就是在网页设计中经常用到的CSS技术所使用的一种思维模型。 CSS将页面中的所有元素都设置为了一个矩形的盒子。 盒子可见框的大小，由内容区、内边距和边框共同决定，所以在计算盒子大小时，需要将这三个区域加到一起计算 每一个盒子都由一下几个部分组成： 内容区（content） width、height、background-color color:前景色 内边距（padding）内边距，也叫填充，是内容区和边框之间的空间 padding-top 上内边距 padding-right 右内边距 padding-bottom下内边距 padding-left 左内边距 padding内边距的简写属性，可以同时指定四个方向的内边距，规则和边框中属性值设置一样 边框（border）边框属于盒子边缘，边框里边属于盒子内部，出了边框都是盒子的外部 border-width 边框的宽度：默认3px border-top-width 上边框的宽度 border-right-width 右边框的宽度 border-bottom-width 下边框的宽度 border-left-width 左边框的宽度 border-color 边框的颜色：默认使用color的颜色值 border-top-color 上边框的颜色 border-right-color 右边框的颜色 border-bottom-color 下边框的颜色 border-left-color 左边框的颜色 border-style 边框的样式：没有默认值，必须指定 border-top-style 上边框的样式 border-right-style 右边框的样式 border-bottom-style 下边框的样式 border-left-style 左边框的样式 设定几个值就决定了对应方向的宽度、颜色或样式 四个值：上 右 下 左 三个值：上 左右 下 两个值：上下 左右 一个值：上下左右 其实不管设置几个值，只要记住：其顺序是按顺时针方向设置的，剩下的可以由矩形的对称性推导出来 效果（solid） 效果（dotted） 效果（dashed） 效果（double） 外边距（margin）外边距，也叫空白边，位于盒子的最外围，是添加在边框外周围的空间。空白边使盒子之间不会紧凑地连接在一起，是CSS 布局的一个重要手段 注意：外边距不会影响盒子可见框的大小，但是外边距会影响盒子的位置和占用空间 一共有四个方向的外边距： margin-top 上外边距 设置正值，元素自身向下移动 设置负值，元素自身向上移动 margin-right 右外边距 设置正值，其右边的元素向右移动 设置负值，其右边的元素向左移动 上述说法并不准确，对于块元素，设置margin-right不会产生任何效果 margin-bottom 下外边距 设置正值，其下边的元素向下移动 设置负值，其下边的元素向上移动 上述说法并不准确，对于块元素，会有垂直方向上的边距重叠问题（后面会细说） margin-left 左外边距 设置正值，元素自身向右移动 设置负值，元素自身向左移动 元素在页面中是按照自左向右的顺序排列的，所以默认情况下 如果我们设置的左和上外边距则会移动元素自身 而设置下和右外边距会移动其他元素 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC2%E7%AB%A0CSS3/:5:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】CSS3","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC2%E7%AB%A0CSS3/#内边距padding"},{"categories":["前端"],"content":"盒子模型（box model） 网页设计中常听的属性名：内容(content)、内边距(padding)、边框(border)、外边距(margin)， CSS盒子模型都具备这些属性。 这些属性我们可以用日常生活中的常见事物——盒子作一个比喻来理解，所以叫它盒子模型。 CSS盒子模型就是在网页设计中经常用到的CSS技术所使用的一种思维模型。 CSS将页面中的所有元素都设置为了一个矩形的盒子。 盒子可见框的大小，由内容区、内边距和边框共同决定，所以在计算盒子大小时，需要将这三个区域加到一起计算 每一个盒子都由一下几个部分组成： 内容区（content） width、height、background-color color:前景色 内边距（padding）内边距，也叫填充，是内容区和边框之间的空间 padding-top 上内边距 padding-right 右内边距 padding-bottom下内边距 padding-left 左内边距 padding内边距的简写属性，可以同时指定四个方向的内边距，规则和边框中属性值设置一样 边框（border）边框属于盒子边缘，边框里边属于盒子内部，出了边框都是盒子的外部 border-width 边框的宽度：默认3px border-top-width 上边框的宽度 border-right-width 右边框的宽度 border-bottom-width 下边框的宽度 border-left-width 左边框的宽度 border-color 边框的颜色：默认使用color的颜色值 border-top-color 上边框的颜色 border-right-color 右边框的颜色 border-bottom-color 下边框的颜色 border-left-color 左边框的颜色 border-style 边框的样式：没有默认值，必须指定 border-top-style 上边框的样式 border-right-style 右边框的样式 border-bottom-style 下边框的样式 border-left-style 左边框的样式 设定几个值就决定了对应方向的宽度、颜色或样式 四个值：上 右 下 左 三个值：上 左右 下 两个值：上下 左右 一个值：上下左右 其实不管设置几个值，只要记住：其顺序是按顺时针方向设置的，剩下的可以由矩形的对称性推导出来 效果（solid） 效果（dotted） 效果（dashed） 效果（double） 外边距（margin）外边距，也叫空白边，位于盒子的最外围，是添加在边框外周围的空间。空白边使盒子之间不会紧凑地连接在一起，是CSS 布局的一个重要手段 注意：外边距不会影响盒子可见框的大小，但是外边距会影响盒子的位置和占用空间 一共有四个方向的外边距： margin-top 上外边距 设置正值，元素自身向下移动 设置负值，元素自身向上移动 margin-right 右外边距 设置正值，其右边的元素向右移动 设置负值，其右边的元素向左移动 上述说法并不准确，对于块元素，设置margin-right不会产生任何效果 margin-bottom 下外边距 设置正值，其下边的元素向下移动 设置负值，其下边的元素向上移动 上述说法并不准确，对于块元素，会有垂直方向上的边距重叠问题（后面会细说） margin-left 左外边距 设置正值，元素自身向右移动 设置负值，元素自身向左移动 元素在页面中是按照自左向右的顺序排列的，所以默认情况下 如果我们设置的左和上外边距则会移动元素自身 而设置下和右外边距会移动其他元素 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC2%E7%AB%A0CSS3/:5:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】CSS3","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC2%E7%AB%A0CSS3/#边框border"},{"categories":["前端"],"content":"盒子模型（box model） 网页设计中常听的属性名：内容(content)、内边距(padding)、边框(border)、外边距(margin)， CSS盒子模型都具备这些属性。 这些属性我们可以用日常生活中的常见事物——盒子作一个比喻来理解，所以叫它盒子模型。 CSS盒子模型就是在网页设计中经常用到的CSS技术所使用的一种思维模型。 CSS将页面中的所有元素都设置为了一个矩形的盒子。 盒子可见框的大小，由内容区、内边距和边框共同决定，所以在计算盒子大小时，需要将这三个区域加到一起计算 每一个盒子都由一下几个部分组成： 内容区（content） width、height、background-color color:前景色 内边距（padding）内边距，也叫填充，是内容区和边框之间的空间 padding-top 上内边距 padding-right 右内边距 padding-bottom下内边距 padding-left 左内边距 padding内边距的简写属性，可以同时指定四个方向的内边距，规则和边框中属性值设置一样 边框（border）边框属于盒子边缘，边框里边属于盒子内部，出了边框都是盒子的外部 border-width 边框的宽度：默认3px border-top-width 上边框的宽度 border-right-width 右边框的宽度 border-bottom-width 下边框的宽度 border-left-width 左边框的宽度 border-color 边框的颜色：默认使用color的颜色值 border-top-color 上边框的颜色 border-right-color 右边框的颜色 border-bottom-color 下边框的颜色 border-left-color 左边框的颜色 border-style 边框的样式：没有默认值，必须指定 border-top-style 上边框的样式 border-right-style 右边框的样式 border-bottom-style 下边框的样式 border-left-style 左边框的样式 设定几个值就决定了对应方向的宽度、颜色或样式 四个值：上 右 下 左 三个值：上 左右 下 两个值：上下 左右 一个值：上下左右 其实不管设置几个值，只要记住：其顺序是按顺时针方向设置的，剩下的可以由矩形的对称性推导出来 效果（solid） 效果（dotted） 效果（dashed） 效果（double） 外边距（margin）外边距，也叫空白边，位于盒子的最外围，是添加在边框外周围的空间。空白边使盒子之间不会紧凑地连接在一起，是CSS 布局的一个重要手段 注意：外边距不会影响盒子可见框的大小，但是外边距会影响盒子的位置和占用空间 一共有四个方向的外边距： margin-top 上外边距 设置正值，元素自身向下移动 设置负值，元素自身向上移动 margin-right 右外边距 设置正值，其右边的元素向右移动 设置负值，其右边的元素向左移动 上述说法并不准确，对于块元素，设置margin-right不会产生任何效果 margin-bottom 下外边距 设置正值，其下边的元素向下移动 设置负值，其下边的元素向上移动 上述说法并不准确，对于块元素，会有垂直方向上的边距重叠问题（后面会细说） margin-left 左外边距 设置正值，元素自身向右移动 设置负值，元素自身向左移动 元素在页面中是按照自左向右的顺序排列的，所以默认情况下 如果我们设置的左和上外边距则会移动元素自身 而设置下和右外边距会移动其他元素 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC2%E7%AB%A0CSS3/:5:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】CSS3","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC2%E7%AB%A0CSS3/#外边距margin"},{"categories":["前端"],"content":"水平方向布局元素在其父元素中水平方向的位置由以下几个属性共同决定 margin-left border-left padding-left width padding-right border-right margin-right 一个元素在其父元素中，水平布局必须要满足以下的等式 margin-left + border-left + padding-left + width + padding-right + border-right + margin-right = 其父元素的宽度 以上等式必须满足，如果相加结果使等式不成立，则称为过渡约束. 则等式会自动调整调整的情况： 如果这七个值中没有auto的情况，则浏览器会自动调整margin-right值以使等式满足 100 + 0 + 0 + 200 + 0 + 0 + 0 = 800 ==\u003e 100 + 0 + 0 + 200 + 0 + 0 + 500 = 800 如果这七个值中有auto的情况，则会自动调整auto值以使等式成立 这七个值中有三个值可以设置为auto ：width、margin-left、maring-right 如果某个值为auto，则会自动调整auto的那个值以使等式成立 200 + 0 + 0 + auto + 0 + 0 + 200 = 600 ==\u003e 200 + 0 + 0 + 400 + 0 + 0 + 200 = 800 auto + 0 + 0 + 200 + 0 + 0 + 200 = 600 ==\u003e 400 + 0 + 0 + 200 + 0 + 0 + 200 = 800 200 + 0 + 0 + 200 + 0 + 0 + auto = 600 ==\u003e 200 + 0 + 0 + 200 + 0 + 0 + 400 = 800 如果宽度为auto，则宽度会调整到最大，其他auto的外边距会自动设置为0 auto + 0 + 0 + auto + 0 + 0 + 200 = 600 ==\u003e 0 + 0 + 0 + 600 + 0 + 0 + 200 = 800 200 + 0 + 0 + auto + 0 + 0 + auto = 600 ==\u003e 200 + 0 + 0 + 600 + 0 + 0 + 0 = 800 auto + 0 + 0 + auto + 0 + 0 + auto = 600 ==\u003e 0 + 0 + 0 + 800 + 0 + 0 + 0 = 800 如果外边距都为auto，则auto的外边距会自动均分以使等式成立 auto + 0 + 0 + 200 + 0 + 0 + auto = 600 ==\u003e 300 + 0 + 0 + 200 + 0 + 0 + 300 = 800 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC2%E7%AB%A0CSS3/:5:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】CSS3","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC2%E7%AB%A0CSS3/#水平方向布局"},{"categories":["前端"],"content":"垂直方向布局子元素是在父元素的内容区中排列的，如果子元素的大小超过了父元素，则子元素会从父元素中溢出 使用overflow/overflow-x/overflow-y属性来设置父元素如何处理溢出的子元素 可选值：visible/hidden/scroll/auto visible 溢出内容会在父元素外部位置显示，默认值 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC2%E7%AB%A0CSS3/:5:4","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】CSS3","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC2%E7%AB%A0CSS3/#垂直方向布局"},{"categories":["前端"],"content":"网页构成html的三个组成部分： 结构：HTML 表现：CSS 行为：JavaScript ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E7%AB%A0HTML5/:0:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】HTML5","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E7%AB%A0HTML5/#网页构成"},{"categories":["前端"],"content":"HTML超文本标记语言（超文本指的是超链接） 标记语言是一套标记标签 (markup tag) 负责网页三要素中的结构 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E7%AB%A0HTML5/:1:0","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】HTML5","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E7%AB%A0HTML5/#html"},{"categories":["前端"],"content":"HTML标签HTML 标记标签通常被称为 HTML 标签 (HTML tag)。 HTML 标签是由尖括号包围的关键词，比如 \u003chtml\u003e HTML 标签通常是成对出现的，比如 \u003cb\u003e 和 \u003c/b\u003e 标签对中的第一个标签是开始标签，第二个标签是结束标签 开始和结束标签也被称为开放标签和闭合标签 ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E7%AB%A0HTML5/:1:1","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】HTML5","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E7%AB%A0HTML5/#html标签"},{"categories":["前端"],"content":"HTML元素HTML 元素指的是从开始标签（start tag）到结束标签（end tag）的所有代码。 根元素、子元素： \u003c!--根元素：网页中所有内容都要写在根元素里面。--\u003e \u003chtml\u003e \u003c!--子元素：--\u003e \u003c!--head是网页的头部，head中的内容不会在网页中直接出现，主要用来帮助浏览器和搜索引擎解析网页--\u003e \u003chead\u003e \u003c!--meta元素用来设置网页的元数据，这里meta用来设置网页的字符集，避免乱码--\u003e \u003cmeta charset=\"utf-8\"\u003e \u003c!--网页标题，显示在浏览器标题栏上，搜索引擎会主要根据title内容来判断网页主要内容SEO--\u003e \u003ctitle\u003e标题\u003c/title\u003e \u003c/head\u003e \u003c!--body是html的子元素，表示网页的主体，网页中所有的可见内容都应写在body里--\u003e \u003cbody\u003e \u003ch1\u003e文章大标题\u003c/h1\u003e \u003c/body \u003c/html\u003e body的子元素： 非自结束元素 标题：h1、h2、h3、h4 段落：p 自结束元素：\u003cimg /\u003e、\u003cinput /\u003e 注释：\u003c!– –\u003e ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E7%AB%A0HTML5/:1:2","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】HTML5","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E7%AB%A0HTML5/#html元素"},{"categories":["前端"],"content":"元素的属性元素中可以设置属性。 属性是名值对结构（x=y）。 属性和元素名或其他属性应该使用空格符隔开。 属性不能随便写，应根据文档中的规定编写，有些有属性名有些没有，如果有属性值应使用引号引起来\"“或''。 例： \u003ch1\u003e这是我的名字：\u003cfount color=\"yellow\" size='3'\u003e哈哈\u003c/font\u003e！\u003c/h1\u003e ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E7%AB%A0HTML5/:1:3","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】HTML5","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E7%AB%A0HTML5/#元素的属性"},{"categories":["前端"],"content":"文档声明doctype，文档声明用来告诉浏览器当前网页版本 迭代版本：HTMLl4、XHTML2.0、HTML5 文档声明写在第一行 \u003c!doctype html\u003e \u003chtml\u003e \u003chead\u003e\u003c/head\u003e \u003cbody\u003e\u003c/body\u003e \u003c/html\u003e ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E7%AB%A0HTML5/:1:4","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】HTML5","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E7%AB%A0HTML5/#文档声明"},{"categories":["前端"],"content":"字符编码番外：二进制 8 bit = 1 byte(字节) 1024 byte = 1 kb（千字节） 1024 kb = 1 mb（兆字节） 1024 mb = 1gb（g字节） 1024 gb = 1 tb（特字节） 1024 tb = 1 pb 所有数据在计算机底层都以二进制形式保存，文字也不例外。 所以一段文字在存储到内存中时，都需要转换成二进制编码，当我们读取这段文字时，计算机会将编码转换为字符供我们读取。 编码 将字符转换为二进制的过程称为编码 解码 将二进制转换为字符的过程称为解码 字符集（charset） 编码和解码采用的规则称为字符集 乱码问题 加密和解密采用的字符集不同会出现乱码问题 常见字符集 ASCII ISO88591 GB2312（国标） GBK（国标扩展） UTF-8（万国码，包含世界上所有语言所有符号，推荐使用） meta元素 设置网页的字符集，避免乱码问题 放在head元素里 \u003c!doctype html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003e\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e\u003c/body\u003e \u003c/html\u003e 番外：使用VSCode 插件： 中文包、live serve（浏览器实时显示） 常用快捷键： 快速生成页面基本元素：! + tab 注释：ctrl + / 向下复制当前行：alt + shift +↓ 自动生成英文段落：lorem 生成中文段落（下插件）：jw 自动排版：alt + shift + f ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E7%AB%A0HTML5/:1:5","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】HTML5","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E7%AB%A0HTML5/#字符编码"},{"categories":["前端"],"content":"字符编码番外：二进制 8 bit = 1 byte(字节) 1024 byte = 1 kb（千字节） 1024 kb = 1 mb（兆字节） 1024 mb = 1gb（g字节） 1024 gb = 1 tb（特字节） 1024 tb = 1 pb 所有数据在计算机底层都以二进制形式保存，文字也不例外。 所以一段文字在存储到内存中时，都需要转换成二进制编码，当我们读取这段文字时，计算机会将编码转换为字符供我们读取。 编码 将字符转换为二进制的过程称为编码 解码 将二进制转换为字符的过程称为解码 字符集（charset） 编码和解码采用的规则称为字符集 乱码问题 加密和解密采用的字符集不同会出现乱码问题 常见字符集 ASCII ISO88591 GB2312（国标） GBK（国标扩展） UTF-8（万国码，包含世界上所有语言所有符号，推荐使用） meta元素 设置网页的字符集，避免乱码问题 放在head元素里 番外：使用VSCode 插件： 中文包、live serve（浏览器实时显示） 常用快捷键： 快速生成页面基本元素：! + tab 注释：ctrl + / 向下复制当前行：alt + shift +↓ 自动生成英文段落：lorem 生成中文段落（下插件）：jw 自动排版：alt + shift + f ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E7%AB%A0HTML5/:1:5","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】HTML5","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E7%AB%A0HTML5/#番外二进制"},{"categories":["前端"],"content":"字符编码番外：二进制 8 bit = 1 byte(字节) 1024 byte = 1 kb（千字节） 1024 kb = 1 mb（兆字节） 1024 mb = 1gb（g字节） 1024 gb = 1 tb（特字节） 1024 tb = 1 pb 所有数据在计算机底层都以二进制形式保存，文字也不例外。 所以一段文字在存储到内存中时，都需要转换成二进制编码，当我们读取这段文字时，计算机会将编码转换为字符供我们读取。 编码 将字符转换为二进制的过程称为编码 解码 将二进制转换为字符的过程称为解码 字符集（charset） 编码和解码采用的规则称为字符集 乱码问题 加密和解密采用的字符集不同会出现乱码问题 常见字符集 ASCII ISO88591 GB2312（国标） GBK（国标扩展） UTF-8（万国码，包含世界上所有语言所有符号，推荐使用） meta元素 设置网页的字符集，避免乱码问题 放在head元素里 番外：使用VSCode 插件： 中文包、live serve（浏览器实时显示） 常用快捷键： 快速生成页面基本元素：! + tab 注释：ctrl + / 向下复制当前行：alt + shift +↓ 自动生成英文段落：lorem 生成中文段落（下插件）：jw 自动排版：alt + shift + f ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E7%AB%A0HTML5/:1:5","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】HTML5","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E7%AB%A0HTML5/#番外使用vscode"},{"categories":["前端"],"content":"实体 entity在网页中编写的多个空格会被解析成一个空格。 在网页中有些时候，我们不能直接书写一些特殊符号，比如多个连续空格、大于号、小于号。 如果我们需要在网页中书写这些特殊符号，则需要使用html中的 实体（转义字符）。 实体语法：常用的实体 \u0026 + 实体的名字 + ; 空格 ：\u0026nbsp; 大于\u003e：\u0026gt; 小于\u003c：\u0026lt; 版权符号©：\u0026copy; ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E7%AB%A0HTML5/:1:6","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】HTML5","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E7%AB%A0HTML5/#实体-entity"},{"categories":["前端"],"content":"meta元素用于设置网页中的元数据，元数据是给浏览器和搜索引擎看的。 空元素，必须有开始标签，没有结束标签。 常用属性： charset 指定网页字符集 name 指定的数据名称 content 指定的数据内容 http-equiv 设置http协议，一般用来将页面重定向到另一个页面 \u003c!--指定关键字--\u003e \u003cmeta name=\"keywords\" content=\"HTML5,前端\"\u003e \u003c!--指定网站描述--\u003e \u003cmeta name=\"description\" content=\"这是一个网站\"\u003e \u003c!--3秒后将页面重定向到百度： \u003cmeta http-equiv=\"refresh\" content=\"3;url=https://www.baidu.com\"\u003e --\u003e ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E7%AB%A0HTML5/:1:7","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】HTML5","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E7%AB%A0HTML5/#meta元素"},{"categories":["前端"],"content":"语义化元素在网页中，html负责网页的结构，所以在使用html标签时，应关注的时标签的语义而非样式。 因为通过css可使标签样式千变万化。 在页面中独占一行的元素叫做块元素。 在网页中一般通过块元素来布局。 一般在块元素中放行内元素。 p元素中不能放任何块元素（但是因为浏览器在解析网页时会自动对网页中不符合规范的内容修正，所以看起来生效了，可在devtools中看到纠正后的代码）。 标题元素：h1、h2、h3、h4、h5、h6 段落元素：p 换行长引用：blockquote 区分页面块（非必须） header 网页头部 main 网页主体 footer 网页底部 nav 导航 aside 侧边栏 article 文章 section 区块 div 区块，使用最广，可替代上面的 在页面中不会独占一行的元素叫行内元素（内联元素）。 行内元素一般用于包裹文字。 斜：em 加粗：strong 引号引用：q 换行：br span 段落，使用最广 列表无序列表（使用较广）、有序列表、定义列表 无序列表 \u003cul\u003e \u003cli\u003e\u003c/li\u003e \u003cli\u003e\u003c/li\u003e \u003c/ul\u003e 有序列表 \u003col\u003e \u003cli\u003e\u003c/li\u003e \u003cli\u003e\u003c/li\u003e \u003c/ol\u003e 定义列表 使用dl创建定义列表，dt表示定义内容，dd对内容说明 \u003cdl\u003e \u003cdt\u003e选项\u003c/dt\u003e \u003cdd\u003e说明\u003c/dd\u003e \u003c/dl\u003e 超链接a超链接可以使我们从一个页面跳转到其他页面或当前页面其他位置。 a元素是行内元素，但是在a标签中可以嵌套除它自身外的任何元素。 属性： href 指定跳转目标路径，可以是外部网站地址也可以是内部网页地址 href=\"#” 回到顶部 href=\"#id\" 根据元素id跳转到对应位置 href=“javascript:;” 点击后什么都不会发生，占位用 target 指定连接打开位置 target=\"_self\" 默认在当前页面打开 target=\"_blank\" 在一个新的页面中打开 id 每一个元素都可以添加id属性，同一个页面不能出现重复id属性 \u003ca href=\"http://www.baidu.com\"\u003e超链接\u003c/a\u003e \u003c!--a标签可以放div元素--\u003e \u003ca href=\"\"\u003e 超链接\u003cdiv\u003e\u003c/div\u003e \u003c/a\u003e \u003c!--同级目录下跳转--\u003e \u003ca href=\"index.html\"\u003e超链接\u003c/a\u003e \u003c!--当在服务器内部跳转时，一般使用相对路径，写法： “./” 或“../” --\u003e \u003ca href=\"../index.html\"\u003e超链接\u003c/a\u003e 图片img图片元素用于向当前页面引入一个外部图片。 替换元素，介于块元素和行内元素之间 属性： src 指定外部图片路径 alt 描述（有些浏览器在图片无法显示时展示描述） width 图片宽度（单位 像素px） height 图片高度 宽度或高度只修改一个，另一个会等比例缩放 图片格式 jpeg（jpg）支持颜色丰富，不支持透明效果和动图。 gif 支持颜色较少，支持简单透明和动图 png 支持颜色丰富，支持复杂透明，不支持动图 webp 谷歌新推出的专门用来表示网页图片的一种格式，具备其他图片所有优点，不仅小功能也多 缺点：兼容性不行 base64 将图片进行base64编码，这样可以直接将图片转换为字符，通过字符形式引入图片，使用场景低 \u003cimg src=\"https://www.w3school.com.cn/i/eg_tulip.jpg\"\u003e \u003cimg src=\"./resources/1.jpg\"\u003e \u003c!--base64格式图片--\u003e \u003cimg src=\"data:image/jpeg;base64,/9j/4QAYRUDWADAWD...\"\u003e 内联框架iframe内联框架用于向当前页面引入一个其他页面。 属性： src 指定要引入的网页的路径 frameborder 指定内联框架的边框粗细 \u003ciframe src=\"https://www.baidu.com\"\u003e\u003c/iframe\u003e 音视频audio元素用来向页面中引入一个外部音频文件 属性： controls 是否允许用户控制播放 autoplay 自动播放，部分浏览器禁止此功能 loop 循环播放 \u003c!--controls允许用户自己控制，autoplay自动播放--\u003e \u003caudio src=\"./xx.mp3\" controls autoplay\u003e\u003c/audio\u003e \u003c!--可以多资源、提示不兼容浏览器写法--\u003e \u003caudiocontrols autoplay\u003e 对不起您的浏览器不支持此音频格式。 \u003csource src=\"./xx.mp3\"\u003e \u003csource src=\"./xx1.mp3\"\u003e \u003csource src=\"./xx2.mp3\"\u003e \u003c/audio\u003e video元素用来向网页引入一个视频文件 使用方式和audio基本一样 \u003cvideo controls\u003e \u003csource src=\"./xxx.mp4\"\u003e \u003c/video\u003e Input \u003cinput type=\"text\"\\\u003e 选择框selecte value=\"\" 默认会排在最上面 \u003cselect\u003e \u003coption disabled value=\"\"\u003e请选择\u003c/option\u003e \u003coption value=\"A\"\u003eA\u003c/option\u003e \u003coption value=\"B\"\u003eB\u003c/option\u003e \u003coption value=\"C\"\u003eC\u003c/option\u003e \u003c/select\u003e ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E7%AB%A0HTML5/:1:8","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】HTML5","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E7%AB%A0HTML5/#语义化元素"},{"categories":["前端"],"content":"语义化元素在网页中，html负责网页的结构，所以在使用html标签时，应关注的时标签的语义而非样式。 因为通过css可使标签样式千变万化。 在页面中独占一行的元素叫做块元素。 在网页中一般通过块元素来布局。 一般在块元素中放行内元素。 p元素中不能放任何块元素（但是因为浏览器在解析网页时会自动对网页中不符合规范的内容修正，所以看起来生效了，可在devtools中看到纠正后的代码）。 标题元素：h1、h2、h3、h4、h5、h6 段落元素：p 换行长引用：blockquote 区分页面块（非必须） header 网页头部 main 网页主体 footer 网页底部 nav 导航 aside 侧边栏 article 文章 section 区块 div 区块，使用最广，可替代上面的 在页面中不会独占一行的元素叫行内元素（内联元素）。 行内元素一般用于包裹文字。 斜：em 加粗：strong 引号引用：q 换行：br span 段落，使用最广 列表无序列表（使用较广）、有序列表、定义列表 无序列表 有序列表 定义列表 使用dl创建定义列表，dt表示定义内容，dd对内容说明 选项 说明 超链接a超链接可以使我们从一个页面跳转到其他页面或当前页面其他位置。 a元素是行内元素，但是在a标签中可以嵌套除它自身外的任何元素。 属性： href 指定跳转目标路径，可以是外部网站地址也可以是内部网页地址 href=\"#” 回到顶部 href=\"#id\" 根据元素id跳转到对应位置 href=“javascript:;” 点击后什么都不会发生，占位用 target 指定连接打开位置 target=\"_self\" 默认在当前页面打开 target=\"_blank\" 在一个新的页面中打开 id 每一个元素都可以添加id属性，同一个页面不能出现重复id属性 超链接 超链接 超链接 超链接 图片img图片元素用于向当前页面引入一个外部图片。 替换元素，介于块元素和行内元素之间 属性： src 指定外部图片路径 alt 描述（有些浏览器在图片无法显示时展示描述） width 图片宽度（单位 像素px） height 图片高度 宽度或高度只修改一个，另一个会等比例缩放 图片格式 jpeg（jpg）支持颜色丰富，不支持透明效果和动图。 gif 支持颜色较少，支持简单透明和动图 png 支持颜色丰富，支持复杂透明，不支持动图 webp 谷歌新推出的专门用来表示网页图片的一种格式，具备其他图片所有优点，不仅小功能也多 缺点：兼容性不行 base64 将图片进行base64编码，这样可以直接将图片转换为字符，通过字符形式引入图片，使用场景低 内联框架iframe内联框架用于向当前页面引入一个其他页面。 属性： src 指定要引入的网页的路径 frameborder 指定内联框架的边框粗细 音视频audio元素用来向页面中引入一个外部音频文件 属性： controls 是否允许用户控制播放 autoplay 自动播放，部分浏览器禁止此功能 loop 循环播放 对不起您的浏览器不支持此音频格式。 video元素用来向网页引入一个视频文件 使用方式和audio基本一样 Input 选择框selecte value=\"\" 默认会排在最上面 请选择 A B C ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E7%AB%A0HTML5/:1:8","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】HTML5","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E7%AB%A0HTML5/#列表"},{"categories":["前端"],"content":"语义化元素在网页中，html负责网页的结构，所以在使用html标签时，应关注的时标签的语义而非样式。 因为通过css可使标签样式千变万化。 在页面中独占一行的元素叫做块元素。 在网页中一般通过块元素来布局。 一般在块元素中放行内元素。 p元素中不能放任何块元素（但是因为浏览器在解析网页时会自动对网页中不符合规范的内容修正，所以看起来生效了，可在devtools中看到纠正后的代码）。 标题元素：h1、h2、h3、h4、h5、h6 段落元素：p 换行长引用：blockquote 区分页面块（非必须） header 网页头部 main 网页主体 footer 网页底部 nav 导航 aside 侧边栏 article 文章 section 区块 div 区块，使用最广，可替代上面的 在页面中不会独占一行的元素叫行内元素（内联元素）。 行内元素一般用于包裹文字。 斜：em 加粗：strong 引号引用：q 换行：br span 段落，使用最广 列表无序列表（使用较广）、有序列表、定义列表 无序列表 有序列表 定义列表 使用dl创建定义列表，dt表示定义内容，dd对内容说明 选项 说明 超链接a超链接可以使我们从一个页面跳转到其他页面或当前页面其他位置。 a元素是行内元素，但是在a标签中可以嵌套除它自身外的任何元素。 属性： href 指定跳转目标路径，可以是外部网站地址也可以是内部网页地址 href=\"#” 回到顶部 href=\"#id\" 根据元素id跳转到对应位置 href=“javascript:;” 点击后什么都不会发生，占位用 target 指定连接打开位置 target=\"_self\" 默认在当前页面打开 target=\"_blank\" 在一个新的页面中打开 id 每一个元素都可以添加id属性，同一个页面不能出现重复id属性 超链接 超链接 超链接 超链接 图片img图片元素用于向当前页面引入一个外部图片。 替换元素，介于块元素和行内元素之间 属性： src 指定外部图片路径 alt 描述（有些浏览器在图片无法显示时展示描述） width 图片宽度（单位 像素px） height 图片高度 宽度或高度只修改一个，另一个会等比例缩放 图片格式 jpeg（jpg）支持颜色丰富，不支持透明效果和动图。 gif 支持颜色较少，支持简单透明和动图 png 支持颜色丰富，支持复杂透明，不支持动图 webp 谷歌新推出的专门用来表示网页图片的一种格式，具备其他图片所有优点，不仅小功能也多 缺点：兼容性不行 base64 将图片进行base64编码，这样可以直接将图片转换为字符，通过字符形式引入图片，使用场景低 内联框架iframe内联框架用于向当前页面引入一个其他页面。 属性： src 指定要引入的网页的路径 frameborder 指定内联框架的边框粗细 音视频audio元素用来向页面中引入一个外部音频文件 属性： controls 是否允许用户控制播放 autoplay 自动播放，部分浏览器禁止此功能 loop 循环播放 对不起您的浏览器不支持此音频格式。 video元素用来向网页引入一个视频文件 使用方式和audio基本一样 Input 选择框selecte value=\"\" 默认会排在最上面 请选择 A B C ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E7%AB%A0HTML5/:1:8","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】HTML5","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E7%AB%A0HTML5/#超链接a"},{"categories":["前端"],"content":"语义化元素在网页中，html负责网页的结构，所以在使用html标签时，应关注的时标签的语义而非样式。 因为通过css可使标签样式千变万化。 在页面中独占一行的元素叫做块元素。 在网页中一般通过块元素来布局。 一般在块元素中放行内元素。 p元素中不能放任何块元素（但是因为浏览器在解析网页时会自动对网页中不符合规范的内容修正，所以看起来生效了，可在devtools中看到纠正后的代码）。 标题元素：h1、h2、h3、h4、h5、h6 段落元素：p 换行长引用：blockquote 区分页面块（非必须） header 网页头部 main 网页主体 footer 网页底部 nav 导航 aside 侧边栏 article 文章 section 区块 div 区块，使用最广，可替代上面的 在页面中不会独占一行的元素叫行内元素（内联元素）。 行内元素一般用于包裹文字。 斜：em 加粗：strong 引号引用：q 换行：br span 段落，使用最广 列表无序列表（使用较广）、有序列表、定义列表 无序列表 有序列表 定义列表 使用dl创建定义列表，dt表示定义内容，dd对内容说明 选项 说明 超链接a超链接可以使我们从一个页面跳转到其他页面或当前页面其他位置。 a元素是行内元素，但是在a标签中可以嵌套除它自身外的任何元素。 属性： href 指定跳转目标路径，可以是外部网站地址也可以是内部网页地址 href=\"#” 回到顶部 href=\"#id\" 根据元素id跳转到对应位置 href=“javascript:;” 点击后什么都不会发生，占位用 target 指定连接打开位置 target=\"_self\" 默认在当前页面打开 target=\"_blank\" 在一个新的页面中打开 id 每一个元素都可以添加id属性，同一个页面不能出现重复id属性 超链接 超链接 超链接 超链接 图片img图片元素用于向当前页面引入一个外部图片。 替换元素，介于块元素和行内元素之间 属性： src 指定外部图片路径 alt 描述（有些浏览器在图片无法显示时展示描述） width 图片宽度（单位 像素px） height 图片高度 宽度或高度只修改一个，另一个会等比例缩放 图片格式 jpeg（jpg）支持颜色丰富，不支持透明效果和动图。 gif 支持颜色较少，支持简单透明和动图 png 支持颜色丰富，支持复杂透明，不支持动图 webp 谷歌新推出的专门用来表示网页图片的一种格式，具备其他图片所有优点，不仅小功能也多 缺点：兼容性不行 base64 将图片进行base64编码，这样可以直接将图片转换为字符，通过字符形式引入图片，使用场景低 内联框架iframe内联框架用于向当前页面引入一个其他页面。 属性： src 指定要引入的网页的路径 frameborder 指定内联框架的边框粗细 音视频audio元素用来向页面中引入一个外部音频文件 属性： controls 是否允许用户控制播放 autoplay 自动播放，部分浏览器禁止此功能 loop 循环播放 对不起您的浏览器不支持此音频格式。 video元素用来向网页引入一个视频文件 使用方式和audio基本一样 Input 选择框selecte value=\"\" 默认会排在最上面 请选择 A B C ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E7%AB%A0HTML5/:1:8","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】HTML5","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E7%AB%A0HTML5/#图片img"},{"categories":["前端"],"content":"语义化元素在网页中，html负责网页的结构，所以在使用html标签时，应关注的时标签的语义而非样式。 因为通过css可使标签样式千变万化。 在页面中独占一行的元素叫做块元素。 在网页中一般通过块元素来布局。 一般在块元素中放行内元素。 p元素中不能放任何块元素（但是因为浏览器在解析网页时会自动对网页中不符合规范的内容修正，所以看起来生效了，可在devtools中看到纠正后的代码）。 标题元素：h1、h2、h3、h4、h5、h6 段落元素：p 换行长引用：blockquote 区分页面块（非必须） header 网页头部 main 网页主体 footer 网页底部 nav 导航 aside 侧边栏 article 文章 section 区块 div 区块，使用最广，可替代上面的 在页面中不会独占一行的元素叫行内元素（内联元素）。 行内元素一般用于包裹文字。 斜：em 加粗：strong 引号引用：q 换行：br span 段落，使用最广 列表无序列表（使用较广）、有序列表、定义列表 无序列表 有序列表 定义列表 使用dl创建定义列表，dt表示定义内容，dd对内容说明 选项 说明 超链接a超链接可以使我们从一个页面跳转到其他页面或当前页面其他位置。 a元素是行内元素，但是在a标签中可以嵌套除它自身外的任何元素。 属性： href 指定跳转目标路径，可以是外部网站地址也可以是内部网页地址 href=\"#” 回到顶部 href=\"#id\" 根据元素id跳转到对应位置 href=“javascript:;” 点击后什么都不会发生，占位用 target 指定连接打开位置 target=\"_self\" 默认在当前页面打开 target=\"_blank\" 在一个新的页面中打开 id 每一个元素都可以添加id属性，同一个页面不能出现重复id属性 超链接 超链接 超链接 超链接 图片img图片元素用于向当前页面引入一个外部图片。 替换元素，介于块元素和行内元素之间 属性： src 指定外部图片路径 alt 描述（有些浏览器在图片无法显示时展示描述） width 图片宽度（单位 像素px） height 图片高度 宽度或高度只修改一个，另一个会等比例缩放 图片格式 jpeg（jpg）支持颜色丰富，不支持透明效果和动图。 gif 支持颜色较少，支持简单透明和动图 png 支持颜色丰富，支持复杂透明，不支持动图 webp 谷歌新推出的专门用来表示网页图片的一种格式，具备其他图片所有优点，不仅小功能也多 缺点：兼容性不行 base64 将图片进行base64编码，这样可以直接将图片转换为字符，通过字符形式引入图片，使用场景低 内联框架iframe内联框架用于向当前页面引入一个其他页面。 属性： src 指定要引入的网页的路径 frameborder 指定内联框架的边框粗细 音视频audio元素用来向页面中引入一个外部音频文件 属性： controls 是否允许用户控制播放 autoplay 自动播放，部分浏览器禁止此功能 loop 循环播放 对不起您的浏览器不支持此音频格式。 video元素用来向网页引入一个视频文件 使用方式和audio基本一样 Input 选择框selecte value=\"\" 默认会排在最上面 请选择 A B C ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E7%AB%A0HTML5/:1:8","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】HTML5","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E7%AB%A0HTML5/#内联框架iframe"},{"categories":["前端"],"content":"语义化元素在网页中，html负责网页的结构，所以在使用html标签时，应关注的时标签的语义而非样式。 因为通过css可使标签样式千变万化。 在页面中独占一行的元素叫做块元素。 在网页中一般通过块元素来布局。 一般在块元素中放行内元素。 p元素中不能放任何块元素（但是因为浏览器在解析网页时会自动对网页中不符合规范的内容修正，所以看起来生效了，可在devtools中看到纠正后的代码）。 标题元素：h1、h2、h3、h4、h5、h6 段落元素：p 换行长引用：blockquote 区分页面块（非必须） header 网页头部 main 网页主体 footer 网页底部 nav 导航 aside 侧边栏 article 文章 section 区块 div 区块，使用最广，可替代上面的 在页面中不会独占一行的元素叫行内元素（内联元素）。 行内元素一般用于包裹文字。 斜：em 加粗：strong 引号引用：q 换行：br span 段落，使用最广 列表无序列表（使用较广）、有序列表、定义列表 无序列表 有序列表 定义列表 使用dl创建定义列表，dt表示定义内容，dd对内容说明 选项 说明 超链接a超链接可以使我们从一个页面跳转到其他页面或当前页面其他位置。 a元素是行内元素，但是在a标签中可以嵌套除它自身外的任何元素。 属性： href 指定跳转目标路径，可以是外部网站地址也可以是内部网页地址 href=\"#” 回到顶部 href=\"#id\" 根据元素id跳转到对应位置 href=“javascript:;” 点击后什么都不会发生，占位用 target 指定连接打开位置 target=\"_self\" 默认在当前页面打开 target=\"_blank\" 在一个新的页面中打开 id 每一个元素都可以添加id属性，同一个页面不能出现重复id属性 超链接 超链接 超链接 超链接 图片img图片元素用于向当前页面引入一个外部图片。 替换元素，介于块元素和行内元素之间 属性： src 指定外部图片路径 alt 描述（有些浏览器在图片无法显示时展示描述） width 图片宽度（单位 像素px） height 图片高度 宽度或高度只修改一个，另一个会等比例缩放 图片格式 jpeg（jpg）支持颜色丰富，不支持透明效果和动图。 gif 支持颜色较少，支持简单透明和动图 png 支持颜色丰富，支持复杂透明，不支持动图 webp 谷歌新推出的专门用来表示网页图片的一种格式，具备其他图片所有优点，不仅小功能也多 缺点：兼容性不行 base64 将图片进行base64编码，这样可以直接将图片转换为字符，通过字符形式引入图片，使用场景低 内联框架iframe内联框架用于向当前页面引入一个其他页面。 属性： src 指定要引入的网页的路径 frameborder 指定内联框架的边框粗细 音视频audio元素用来向页面中引入一个外部音频文件 属性： controls 是否允许用户控制播放 autoplay 自动播放，部分浏览器禁止此功能 loop 循环播放 对不起您的浏览器不支持此音频格式。 video元素用来向网页引入一个视频文件 使用方式和audio基本一样 Input 选择框selecte value=\"\" 默认会排在最上面 请选择 A B C ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E7%AB%A0HTML5/:1:8","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】HTML5","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E7%AB%A0HTML5/#音视频"},{"categories":["前端"],"content":"语义化元素在网页中，html负责网页的结构，所以在使用html标签时，应关注的时标签的语义而非样式。 因为通过css可使标签样式千变万化。 在页面中独占一行的元素叫做块元素。 在网页中一般通过块元素来布局。 一般在块元素中放行内元素。 p元素中不能放任何块元素（但是因为浏览器在解析网页时会自动对网页中不符合规范的内容修正，所以看起来生效了，可在devtools中看到纠正后的代码）。 标题元素：h1、h2、h3、h4、h5、h6 段落元素：p 换行长引用：blockquote 区分页面块（非必须） header 网页头部 main 网页主体 footer 网页底部 nav 导航 aside 侧边栏 article 文章 section 区块 div 区块，使用最广，可替代上面的 在页面中不会独占一行的元素叫行内元素（内联元素）。 行内元素一般用于包裹文字。 斜：em 加粗：strong 引号引用：q 换行：br span 段落，使用最广 列表无序列表（使用较广）、有序列表、定义列表 无序列表 有序列表 定义列表 使用dl创建定义列表，dt表示定义内容，dd对内容说明 选项 说明 超链接a超链接可以使我们从一个页面跳转到其他页面或当前页面其他位置。 a元素是行内元素，但是在a标签中可以嵌套除它自身外的任何元素。 属性： href 指定跳转目标路径，可以是外部网站地址也可以是内部网页地址 href=\"#” 回到顶部 href=\"#id\" 根据元素id跳转到对应位置 href=“javascript:;” 点击后什么都不会发生，占位用 target 指定连接打开位置 target=\"_self\" 默认在当前页面打开 target=\"_blank\" 在一个新的页面中打开 id 每一个元素都可以添加id属性，同一个页面不能出现重复id属性 超链接 超链接 超链接 超链接 图片img图片元素用于向当前页面引入一个外部图片。 替换元素，介于块元素和行内元素之间 属性： src 指定外部图片路径 alt 描述（有些浏览器在图片无法显示时展示描述） width 图片宽度（单位 像素px） height 图片高度 宽度或高度只修改一个，另一个会等比例缩放 图片格式 jpeg（jpg）支持颜色丰富，不支持透明效果和动图。 gif 支持颜色较少，支持简单透明和动图 png 支持颜色丰富，支持复杂透明，不支持动图 webp 谷歌新推出的专门用来表示网页图片的一种格式，具备其他图片所有优点，不仅小功能也多 缺点：兼容性不行 base64 将图片进行base64编码，这样可以直接将图片转换为字符，通过字符形式引入图片，使用场景低 内联框架iframe内联框架用于向当前页面引入一个其他页面。 属性： src 指定要引入的网页的路径 frameborder 指定内联框架的边框粗细 音视频audio元素用来向页面中引入一个外部音频文件 属性： controls 是否允许用户控制播放 autoplay 自动播放，部分浏览器禁止此功能 loop 循环播放 对不起您的浏览器不支持此音频格式。 video元素用来向网页引入一个视频文件 使用方式和audio基本一样 Input 选择框selecte value=\"\" 默认会排在最上面 请选择 A B C ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E7%AB%A0HTML5/:1:8","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】HTML5","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E7%AB%A0HTML5/#input"},{"categories":["前端"],"content":"语义化元素在网页中，html负责网页的结构，所以在使用html标签时，应关注的时标签的语义而非样式。 因为通过css可使标签样式千变万化。 在页面中独占一行的元素叫做块元素。 在网页中一般通过块元素来布局。 一般在块元素中放行内元素。 p元素中不能放任何块元素（但是因为浏览器在解析网页时会自动对网页中不符合规范的内容修正，所以看起来生效了，可在devtools中看到纠正后的代码）。 标题元素：h1、h2、h3、h4、h5、h6 段落元素：p 换行长引用：blockquote 区分页面块（非必须） header 网页头部 main 网页主体 footer 网页底部 nav 导航 aside 侧边栏 article 文章 section 区块 div 区块，使用最广，可替代上面的 在页面中不会独占一行的元素叫行内元素（内联元素）。 行内元素一般用于包裹文字。 斜：em 加粗：strong 引号引用：q 换行：br span 段落，使用最广 列表无序列表（使用较广）、有序列表、定义列表 无序列表 有序列表 定义列表 使用dl创建定义列表，dt表示定义内容，dd对内容说明 选项 说明 超链接a超链接可以使我们从一个页面跳转到其他页面或当前页面其他位置。 a元素是行内元素，但是在a标签中可以嵌套除它自身外的任何元素。 属性： href 指定跳转目标路径，可以是外部网站地址也可以是内部网页地址 href=\"#” 回到顶部 href=\"#id\" 根据元素id跳转到对应位置 href=“javascript:;” 点击后什么都不会发生，占位用 target 指定连接打开位置 target=\"_self\" 默认在当前页面打开 target=\"_blank\" 在一个新的页面中打开 id 每一个元素都可以添加id属性，同一个页面不能出现重复id属性 超链接 超链接 超链接 超链接 图片img图片元素用于向当前页面引入一个外部图片。 替换元素，介于块元素和行内元素之间 属性： src 指定外部图片路径 alt 描述（有些浏览器在图片无法显示时展示描述） width 图片宽度（单位 像素px） height 图片高度 宽度或高度只修改一个，另一个会等比例缩放 图片格式 jpeg（jpg）支持颜色丰富，不支持透明效果和动图。 gif 支持颜色较少，支持简单透明和动图 png 支持颜色丰富，支持复杂透明，不支持动图 webp 谷歌新推出的专门用来表示网页图片的一种格式，具备其他图片所有优点，不仅小功能也多 缺点：兼容性不行 base64 将图片进行base64编码，这样可以直接将图片转换为字符，通过字符形式引入图片，使用场景低 内联框架iframe内联框架用于向当前页面引入一个其他页面。 属性： src 指定要引入的网页的路径 frameborder 指定内联框架的边框粗细 音视频audio元素用来向页面中引入一个外部音频文件 属性： controls 是否允许用户控制播放 autoplay 自动播放，部分浏览器禁止此功能 loop 循环播放 对不起您的浏览器不支持此音频格式。 video元素用来向网页引入一个视频文件 使用方式和audio基本一样 Input 选择框selecte value=\"\" 默认会排在最上面 请选择 A B C ","date":"2022-02-24","objectID":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E7%AB%A0HTML5/:1:8","series":["前端学习笔记"],"tags":[],"title":"【前端学习笔记】HTML5","uri":"/blog/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E7%AB%A0HTML5/#选择框selecte"},{"categories":["performance"],"content":"选择压测工具是在选什么？压力测试是测试工程师日常工作中一项比较“有技术含量”的工作，很多人都对这项工作充满了好奇。除了少数特殊场景得靠是自己开发压测脚本外，大部分压测工作是可以选用成熟的压测工具来进行的。压测工具有非常多，有开源的、有商业化的，我下面罗列一些常见的： 工具 项目地址 ApacheBench https://httpd.apache.org/docs/2.4/programs/ab.html wrk https://github.com/wg/wrk Apache JMeter https://jmeter.apache.org/ Locust https://locust.io/ K6 https://k6.io/ Artillery https://artillery.io/ 除了LoadRunner这种商业压测工具之外，大部分测试人员在压测工具的选型时最重要的一点：是否熟悉。这种熟悉往往是出于过往的工作经历、身边同事的推荐、网上教程的多寡、脚本语言等因素。比如我在很多年前开始用Locust时，就是因为我个人擅长Python开发语言，即便在当时几乎没有中文教程。 但我在使用Locust一段时间之后，大约在2015年中，我意识到Locust作为一款压测工具，其能够产生的压力好像远远逊色于JMeter之类，于是开始关注压测工具背后的并发模型，去理解不同压测工具运行逻辑，尝试去解释我看到的性能差异。 ","date":"2022-02-17","objectID":"/blog/%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%E5%B7%AE%E5%88%AB/:0:1","series":[],"tags":["ab","wrk","jmeter","locust"],"title":"[转]ab、wrk、JMeter、Locust这些压测工具的并发模型差别","uri":"/blog/%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%E5%B7%AE%E5%88%AB/#选择压测工具是在选什么"},{"categories":["performance"],"content":"同步、异步、阻塞、非阻塞要讲并发模型，我们绕不开以下四个名词： 同步（Synchronous） 异步（Asynchronous） 阻塞 (Blocking) 非阻塞（Nonblocking） 而且我还要特地指出：目前你能通过搜索引擎找到的、能准确解释这四个概念的中文资料，是极少的。 我这边不会班门弄斧地来解释这四个词的差别，只是提一些大部分资料中忽视的点： 要区分同步、异步，必须讲清楚其所处的层，比如框架、用户空间、内核、IO模型 同步调用发起后，没有得到结果不返回，那么毫无疑问就是被阻塞了 异步调用发起后直接返回，毫无疑问，这个进程没有被阻塞 在**Operating System Concepts [9th Edition]**该书中描述对进程间通信进行了一些描述 也就是说，站在进程通信纬度上来看，阻塞、非阻塞与同步、异步是同义词，但是需要区分发送方、接收方： 阻塞发送 非阻塞发送 阻塞接受 非阻塞接受 上述不同类型的发送方法和不同类型的接收方法可以自由组合 另外，我们还知道Linux有五种I/O模型： 阻塞式IO（Blocking I/O） 非阻塞式IO（Nonblocking I/O） IO复用（I/O multiplexing） select poll epoll 信号驱动式IO（Signal Driver I/O） 异步IO（Asynchronous I/O） AIO 以上1-4其实都是同步IO，只有第五种模型才是异步IO 了解以上这些概念后，我们再来讲讲文章标题中提到的这些压测工具背后的并发模型 ","date":"2022-02-17","objectID":"/blog/%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%E5%B7%AE%E5%88%AB/:0:2","series":[],"tags":["ab","wrk","jmeter","locust"],"title":"[转]ab、wrk、JMeter、Locust这些压测工具的并发模型差别","uri":"/blog/%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%E5%B7%AE%E5%88%AB/#同步异步阻塞非阻塞"},{"categories":["performance"],"content":"基于多线程并发的ab、JMeterab、JMeter分别是用C、Java开发的、基于多线程并发模型的压测工具，也是目前最流行的开源压测工具，两者的工作原理类似，如下图： 不管ab还是JMeter，其所谓的虚拟用户(vuser)就是对应一个线程 在单个线程中，每个请求（query）都是同步调用的，下一个请求要等待前一个请求完成才能进行 一个请求（query）分成三部分： send - 施压端发送开始，直到承压端接收完成 wait - 承压端接收完成开始，直至业务处理结束 recv - 承压端返回数据，直至施压端接收完成 同一线程中连续的两个请求之间存在等待时间这种概念，即图中的空白处 在多线程并发模型下，是不是可以通过不断增加线程数量生产出更大的压力？ 答案是否定的。 事实上一个进程在一个时间点只能执行一个线程，而所谓的并发是指在进程里不断切换线程实现了看上去的多个任务的并发，但是线程上下文切换有很高的成本，过多的线程数反而会造成性能的严重下滑。 从应用角度来看，基于多线程的并发模型，往往需要设置最大并发数参数，而如果压测场景需要不断往上加压，那这类工具其实挺难应付的。 ","date":"2022-02-17","objectID":"/blog/%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%E5%B7%AE%E5%88%AB/:0:3","series":[],"tags":["ab","wrk","jmeter","locust"],"title":"[转]ab、wrk、JMeter、Locust这些压测工具的并发模型差别","uri":"/blog/%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%E5%B7%AE%E5%88%AB/#基于多线程并发的abjmeter"},{"categories":["performance"],"content":"wrk为什么比ab快？wrk是一款很类似ab的压测工具，同样是使用C语言开发，不过更加的『现代化』： wrk is a modern HTTP benchmarking tool capable of generating significant load when run on a single multi-core CPU. It combines a multithreaded design with scalable event notification systems such as epoll and kqueue. 我们通过wrk的执行参数来来解释其并发模型： connections: Connections to keep open threads: Number of threads to use wrk的connections接近ab的concurrency的概念，见：https://github.com/wg/wrk/issues/205 但是在ab中，concurrency即线程数，而wrk却有单独的threads参数。 wrk为了提升吞吐能力，使用基于epoll的IO复用模型，可以参考下图（图中实际为select），同时为了减少线程的上下文切换，官方建议thread的数量等同CPU核数，即每一个processor下只运行一个线程，这样来彻底了摆脱了线程切换的消耗。 注意了，在这种模型下，施压端发起请求是阻塞的，它需要等待多个请求一起发送，但是在接收时却是非阻塞的。 基于这种并发模型的wrk一定会比ab、jmeter这类强吗？ 答案是不一定。I/O复用不是银弹，它并不一定适用所有的压测场景。外网有wrk、jmeter的对比测试，可以看下这两种压测更适合哪些场景： wrk没有比JMeter更流行的原因可能是缺少GUI，同时起脚本使用lua语言，又比较小众。 ","date":"2022-02-17","objectID":"/blog/%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%E5%B7%AE%E5%88%AB/:0:4","series":[],"tags":["ab","wrk","jmeter","locust"],"title":"[转]ab、wrk、JMeter、Locust这些压测工具的并发模型差别","uri":"/blog/%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%E5%B7%AE%E5%88%AB/#wrk为什么比ab快"},{"categories":["performance"],"content":"Locust、Artillery身后的libuvLocust是用Python开发的分布式压测工具，近年来在国内比较流行。Locust并不是基于Python的多线程，而是coroutine（协程，gevent提供），gevent使用了libev或者libuv作为eventloop。 所谓的evetloop（事件循环）可以看下面这张图来加深理解： 这里介绍另外个压测工具Artillery，熟悉的人应该比较少，它是基于Node.js开发的。 这里为什么把它跟Locust归到一起来介绍？了解Node.js的人想必已经知道原因了：底层的libuv提供了极强悍的异步IO能力。 其事件循环逻辑： 想深入了解libuv可以参考官方文档，这里不多展开了：http://docs.libuv.org/en/v1.x/design.html 不过就我实在使用经验来看，Locust所能产生的并发匪夷所思的低，该问题有很多人向官方反馈过（包括我自己），我不确定到目前版本该问题是否已经根除。在你不确定的情况下，请谨慎使用Locust，包括其分布式执行模式。 ","date":"2022-02-17","objectID":"/blog/%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%E5%B7%AE%E5%88%AB/:0:5","series":[],"tags":["ab","wrk","jmeter","locust"],"title":"[转]ab、wrk、JMeter、Locust这些压测工具的并发模型差别","uri":"/blog/%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%E5%B7%AE%E5%88%AB/#locustartillery身后的libuv"},{"categories":["performance"],"content":"横向比较这些压测工具在我写这篇文章搜索资料之时，意外发现k6.io的blog上有目前已知压测工具的综合对比，非常完善，可以直接戳这里：https://k6.io/blog/comparing-best-open-source-load-testing-tools 对于这些开源的压测工具，我的观点： JMeter能够应付大部分压测场景，即便多线程并发模型不是最高效的 如果你的压测场景中，需要不断往上加压，请尝试基于异步API的压测工具，多线程并发满足不了需求 如果你不满足以上工具，请接着往下看 ","date":"2022-02-17","objectID":"/blog/%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%E5%B7%AE%E5%88%AB/:0:6","series":[],"tags":["ab","wrk","jmeter","locust"],"title":"[转]ab、wrk、JMeter、Locust这些压测工具的并发模型差别","uri":"/blog/%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%E5%B7%AE%E5%88%AB/#横向比较这些压测工具"},{"categories":["performance"],"content":"one more thing - Ultron除上面介绍的这些并发模型之外，我相信很多人听过Golang下的goroutine： goroutine可以理解是用户态线程，goroutine的切换没有内核开销 内存占用小，线程栈空间通常是 2M，goroutine 栈空间最小 2K G-M-P调度模型 golang为并发而生，go项目在未经优化的情况下就有很高的并发能力，有人曾经调侃，十年经验的cpp程序员用各种黑魔法写出来的服务也未必有golang项目的高并发能力。（ 一个段子而已，不要太当真） 那goroutine这么强，那有没有基于goroutine的开源压测工具？ 开始带货了 我这里推荐下ultron这个项目: https://github.com/qastub/ultron 基于goroutine的高并发能力，在与wrk、jmeter等工具的对比测试中，并发能力超出jmeter，仅次于wrk goroutine提供的是同步函数的语义，理解简单 对请求（或事务）进行了高度抽象，方便接入各种协议 提供了Result、Report事件监听接口，方便扩展，如内置了对Influxdb的支持，可以实时生成报告 参考资料： 怎样理解阻塞非阻塞与同步异步的区别？ JMeter VS WRK Comparing the best open source load testing tools since 2017! ","date":"2022-02-17","objectID":"/blog/%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%E5%B7%AE%E5%88%AB/:0:7","series":[],"tags":["ab","wrk","jmeter","locust"],"title":"[转]ab、wrk、JMeter、Locust这些压测工具的并发模型差别","uri":"/blog/%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%E5%B7%AE%E5%88%AB/#one-more-thing---ultron"},{"categories":["前端"],"content":"js 代码执行过程分为两个阶段词法分析：词法分析主要包括：分析变量声明、分析函数声明、分析形参三个部分。 执行阶段 引擎通过词法分析将我们写的js代码转成可以执行的代码，接下来才是执行。 ","date":"2022-01-10","objectID":"/blog/JS%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87/:0:0","series":[],"tags":["javascript"],"title":"JS变量提升、函数提升","uri":"/blog/JS%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87/#js-代码执行过程分为两个阶段"},{"categories":["前端"],"content":"var定义的变量提升 console.log(a); //undefined var a = 123; 因为变量a的声明被提到了作用域顶端。上面代码编译后应该是下面这个样子 var a; console.log(a) a = 123 //所以输出内容为 undeifend 看一道经典面试题 console.log(v1); var v1 = 100; function foo() { console.log(v1); var v1 = 200; console.log(v1); } foo(); console.log(v1); // undefined undefined 200 100 他的分析过程如下： //他的词法分析结果如下 var foo = ()=\u003econsole.log(1) foo() var foo = null foo = ()=\u003e console.log(2) foo() // 所以执行结果如下。 ","date":"2022-01-10","objectID":"/blog/JS%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87/:1:0","series":[],"tags":["javascript"],"title":"JS变量提升、函数提升","uri":"/blog/JS%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87/#var定义的变量提升"},{"categories":["前端"],"content":"函数提升具名函数的声明有两种方式：1. 函数声明式 2. 函数字面量式 //函数声明式 function bar () {} //变量形式声明； var foo = function () {} 函数 变量形式声明 和普通变量一样 提升的 只是一个没有值的变量。 函数声明式的提升现象和变量提升略有不同，函数声明式会提升到作用域最前边，并且将声明内容一起提升到最上边。 bar() var bar = function() { console.log(1); } // 报错：TypeError: bar is not a function bar() function bar() { console.log(1); } //输出结果1 function a(){} var a console.log(typeof a) //function function a(){} var a = 'wxz' console.log(typeof a)//string ","date":"2022-01-10","objectID":"/blog/JS%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87/:2:0","series":[],"tags":["javascript"],"title":"JS变量提升、函数提升","uri":"/blog/JS%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87/#函数提升"},{"categories":["前端"],"content":"知识点总结所有的声明都会提升到作用域的最顶上去。 同一个变量只会声明一次，其他的会被忽略掉或者覆盖掉。 变量声明的优先级高于函数声明的优先级。 函数声明和函数定义的部分一起被提升。 ","date":"2022-01-10","objectID":"/blog/JS%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87/:3:0","series":[],"tags":["javascript"],"title":"JS变量提升、函数提升","uri":"/blog/JS%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87/#知识点总结"},{"categories":["performance"],"content":"背景因为某天晚上的直播课,在开始直播间刚进入教室的时候,某些Android低端机会ANR. 经过排查是客户端收到了大量的进入教室和退出教室信令,客户端解析大量信令,会导致客户端cpu飙升. 因为直播信令是基于MQTT协议,每个学生端都会订阅同样的topic,所以学生端也会收到其他学生端的进入教室和退出教室信令. 我们基于上面的问题,需要对客户端进行压测,看一个客户端需要收到多少QPS的情况下不会ANR. 我们日常工作中很少会压测MQTT,基本上都是HTTP协议,本次也是记录一些学习过程. ","date":"2022-01-09","objectID":"/blog/MQTT%E5%8E%8B%E6%B5%8B/:0:0","series":[],"tags":["mqtt"],"title":"[转]MQTT压测","uri":"/blog/MQTT%E5%8E%8B%E6%B5%8B/#背景"},{"categories":["performance"],"content":"什么是信令?直播是一套负责的业务体系,信令更新是底层的交互方式,所以先要了解什么是信令. 可以参考: https://zhuanlan.zhihu.com/p/72028159 直播信令: 简单来说就是老师端发给学生端(客户端)的一些信号指令,比如:连麦、视频、发题、留言等. 这些信令是双向的、也有可能是一对多.我们用的MQTT协议,MQTT提供商有很多,比如融云、阿里云等 ","date":"2022-01-09","objectID":"/blog/MQTT%E5%8E%8B%E6%B5%8B/:0:0","series":[],"tags":["mqtt"],"title":"[转]MQTT压测","uri":"/blog/MQTT%E5%8E%8B%E6%B5%8B/#什么是信令"},{"categories":["performance"],"content":"MQTT协议","date":"2022-01-09","objectID":"/blog/MQTT%E5%8E%8B%E6%B5%8B/:0:0","series":[],"tags":["mqtt"],"title":"[转]MQTT压测","uri":"/blog/MQTT%E5%8E%8B%E6%B5%8B/#mqtt协议"},{"categories":["performance"],"content":"概念MQTT协议是基于发布/订阅模式的物联网通信协议，凭借简单易实现、支持 QoS、报文小等特点，占据了物联网协议的半壁江山 MQTT协议广泛应用于物联网、移动互联网、智能硬件、车联网、电力、能源等领域 ","date":"2022-01-09","objectID":"/blog/MQTT%E5%8E%8B%E6%B5%8B/:1:0","series":[],"tags":["mqtt"],"title":"[转]MQTT压测","uri":"/blog/MQTT%E5%8E%8B%E6%B5%8B/#概念"},{"categories":["performance"],"content":"名词","date":"2022-01-09","objectID":"/blog/MQTT%E5%8E%8B%E6%B5%8B/:2:0","series":[],"tags":["mqtt"],"title":"[转]MQTT压测","uri":"/blog/MQTT%E5%8E%8B%E6%B5%8B/#名词"},{"categories":["performance"],"content":"发布","date":"2022-01-09","objectID":"/blog/MQTT%E5%8E%8B%E6%B5%8B/:2:1","series":[],"tags":["mqtt"],"title":"[转]MQTT压测","uri":"/blog/MQTT%E5%8E%8B%E6%B5%8B/#发布"},{"categories":["performance"],"content":"订阅","date":"2022-01-09","objectID":"/blog/MQTT%E5%8E%8B%E6%B5%8B/:2:2","series":[],"tags":["mqtt"],"title":"[转]MQTT压测","uri":"/blog/MQTT%E5%8E%8B%E6%B5%8B/#订阅"},{"categories":["performance"],"content":"主题","date":"2022-01-09","objectID":"/blog/MQTT%E5%8E%8B%E6%B5%8B/:2:3","series":[],"tags":["mqtt"],"title":"[转]MQTT压测","uri":"/blog/MQTT%E5%8E%8B%E6%B5%8B/#主题"},{"categories":["performance"],"content":"会话保持","date":"2022-01-09","objectID":"/blog/MQTT%E5%8E%8B%E6%B5%8B/:2:4","series":[],"tags":["mqtt"],"title":"[转]MQTT压测","uri":"/blog/MQTT%E5%8E%8B%E6%B5%8B/#会话保持"},{"categories":["performance"],"content":"QoS:QoS 0 是一种 “fire and forget” 的消息发送模式：Sender (可能是 Publisher 或者 Broker) 发送一条消息之后，就不再关心它有没有发送到对方，也不设置任何重发机制。 QoS 1 包含了简单的重发机制，Sender 发送消息之后等待接收者的 ACK，如果没收到 ACK 则重新发送消息。这种模式能保证消息至少能到达一次，但无法保证消息重复。 QoS 2 设计了略微复杂的重发和重复消息发现机制，保证消息到达对方并且严格只到达一次 ","date":"2022-01-09","objectID":"/blog/MQTT%E5%8E%8B%E6%B5%8B/:2:5","series":[],"tags":["mqtt"],"title":"[转]MQTT压测","uri":"/blog/MQTT%E5%8E%8B%E6%B5%8B/#qos"},{"categories":["performance"],"content":"搭建MQTT服务","date":"2022-01-09","objectID":"/blog/MQTT%E5%8E%8B%E6%B5%8B/:0:0","series":[],"tags":["mqtt"],"title":"[转]MQTT压测","uri":"/blog/MQTT%E5%8E%8B%E6%B5%8B/#搭建mqtt服务"},{"categories":["performance"],"content":"本地搭建在Mac机器上 docker run -d --name emqx -p 1883:1883 -p 8083:8083 -p 8883:8883 -p 8084:8084 -p 18083:18083 emqx/emqx mqtt: http://127.0.0.1:18083 admin/public 发布消息 brew install mosquitto mosquitto_sub -h 127.0.0.1 -p 1883 -t topic -q 2 mosquitto_pub -h 127.0.0.1 -p 1883 -t topic -q 1 -m \"Hello, MQTT!\" ","date":"2022-01-09","objectID":"/blog/MQTT%E5%8E%8B%E6%B5%8B/:1:0","series":[],"tags":["mqtt"],"title":"[转]MQTT压测","uri":"/blog/MQTT%E5%8E%8B%E6%B5%8B/#本地搭建"},{"categories":["performance"],"content":"使用免费的使用 EMQ X 提供的 免费公共 MQTT 服务器，该服务基于 EMQ X 的 MQTT 物联网云平台 创建。服务器接入信息如 Broker: broker.emqx.io TCP Port: 1883 Websocket Port: 8083 ","date":"2022-01-09","objectID":"/blog/MQTT%E5%8E%8B%E6%B5%8B/:2:0","series":[],"tags":["mqtt"],"title":"[转]MQTT压测","uri":"/blog/MQTT%E5%8E%8B%E6%B5%8B/#使用免费的"},{"categories":["performance"],"content":"python连接MQTT","date":"2022-01-09","objectID":"/blog/MQTT%E5%8E%8B%E6%B5%8B/:0:0","series":[],"tags":["mqtt"],"title":"[转]MQTT压测","uri":"/blog/MQTT%E5%8E%8B%E6%B5%8B/#python连接mqtt"},{"categories":["performance"],"content":"paho-mqttpaho-mqtt 是目前 Python 中使用较多的 MQTT 客户端库，它在 Python 2.7 或 3.x 上为客户端类提供了对 MQTT v3.1 和 v3.1.1 的支持。它还提供了一些帮助程序功能，使将消息发布到 MQTT 服务器变得非常简单。 pip3 install -i https://pypi.doubanio.com/simple paho-mqtt ","date":"2022-01-09","objectID":"/blog/MQTT%E5%8E%8B%E6%B5%8B/:1:0","series":[],"tags":["mqtt"],"title":"[转]MQTT压测","uri":"/blog/MQTT%E5%8E%8B%E6%B5%8B/#paho-mqtt"},{"categories":["performance"],"content":"发布脚本如下 import time import random from paho.mqtt import client as mqtt_client \"\"\" 发布者 \"\"\" broker = 'broker.emqx.io' port = 1883 topic = \"/python/mqtt\" client_id = f'python-mqtt-{random.randint(0, 1000)}' def connect_mqtt(): def on_connect(client, userdata, flags, rc): if rc == 0: print(\"Connected to MQTT Broker!\") else: print(\"Failed to connect, return code %d\\n\", rc) # Set Connecting Client ID client = mqtt_client.Client(client_id) client.on_connect = on_connect client.connect(broker, port) return client def publish(client): msg_count = 0 while True: time.sleep(1) msg = f\"messages: {msg_count}\" result = client.publish(topic, msg) # result: [0, 1] status = result[0] if status == 0: print(f\"Send `{msg}` to topic `{topic}`\") else: print(f\"Failed to send message to topic {topic}\") msg_count += 1 def run(): client = connect_mqtt() client.loop_start() publish(client) if __name__ == '__main__': run() ","date":"2022-01-09","objectID":"/blog/MQTT%E5%8E%8B%E6%B5%8B/:2:0","series":[],"tags":["mqtt"],"title":"[转]MQTT压测","uri":"/blog/MQTT%E5%8E%8B%E6%B5%8B/#发布-1"},{"categories":["performance"],"content":"订阅 # python3.6 import random from paho.mqtt import client as mqtt_client broker = 'broker.emqx.io' port = 1883 topic = \"/python/mqtt\" # generate client ID with pub prefix randomly client_id = f'python-mqtt-{random.randint(0, 100)}' def connect_mqtt() -\u003e mqtt_client: def on_connect(client, userdata, flags, rc): if rc == 0: print(\"Connected to MQTT Broker!\") else: print(\"Failed to connect, return code %d\\n\", rc) client = mqtt_client.Client(client_id) client.on_connect = on_connect client.connect(broker, port) return client def subscribe(client: mqtt_client): def on_message(client, userdata, msg): print(f\"Received `{msg.payload.decode()}` from `{msg.topic}` topic\") client.subscribe(topic) client.on_message = on_message def run(): client = connect_mqtt() subscribe(client) client.loop_forever() if __name__ == '__main__': run() ","date":"2022-01-09","objectID":"/blog/MQTT%E5%8E%8B%E6%B5%8B/:3:0","series":[],"tags":["mqtt"],"title":"[转]MQTT压测","uri":"/blog/MQTT%E5%8E%8B%E6%B5%8B/#订阅-1"},{"categories":["performance"],"content":"jmeter压测MQTTjmeter本身就支持多协议压测,需要安装扩展插件. 插件下载完成后放到lib下. https://github.com/hgwz/Java-websocket/tree/master/lib/ext/mqtt-xmeter-1.0.1-jar-with- dependencies.jar 在取样器能看到MQTT插件说明安装成功. 在connect中输入host、username、password、clientid 在pub中输入topic、qos、message message type有三种格式,根据自己需要选择. 不能使用一个clientid,会出现连不上mqtt. 尽量模拟多个客户端,使用jmeter的随机函数. 此时连接和发送成功. ","date":"2022-01-09","objectID":"/blog/MQTT%E5%8E%8B%E6%B5%8B/:0:0","series":[],"tags":["mqtt"],"title":"[转]MQTT压测","uri":"/blog/MQTT%E5%8E%8B%E6%B5%8B/#jmeter压测mqtt"},{"categories":["performance"],"content":"locust压测MQTTlocust是python的一个基于协程的类库,locust也是可以进行MQTT协议压测 可以参考这个帖子,写的很详细. https://blog.csdn.net/qq_39214101/article/details/107997414 脚本如下: #!/user/bin/env python # -*- coding: utf-8 -*- import os import time from locust import User, task, between, events from paho.mqtt.client import Client broker = 'broker.emqx.io' topic = \"/python/mqtt\" class MQTTPubClient(Client): # 要集成paho的Client,最底层用的也是paho def on_connect_rewrite(self, client, userdata, flags, rc): print(\"Connected with result code: \" + str(rc)) def on_message_rewrite(self, client, userdata, msg): print(msg.topic + \" \" + str(msg.payload)) Client.on_connect = on_connect_rewrite Client.on_message = on_message_rewrite def __getattribute__(self, name): func = Client.__getattribute__(self, name) print(\"func:{}\".format(func)) def wrapper(*args, **kwargs): start_time = time.time() try: result = func(*args, **kwargs) print('*' * 100, '\\n', result, '$' * 100) except Exception as e: total_time = int((time.time() - start_time) * 1000) events.request_failure.fire(request_type=\"mqtt_pub\", name=name, response_time=total_time, exception=e, response_length=0) else: total_time = int((time.time() - start_time) * 1000) events.request_success.fire(request_type=\"mqtt_pub\", name=name, response_time=total_time, response_length=0) return wrapper class MQTTUser(User): abstract = True def __init__(self, *args, **kwargs): super(MQTTUser, self).__init__(*args, **kwargs) self.client = MQTTPubClient() class PubUser(MQTTUser): wait_time = between(3, 5) def on_start(self): self.client.connect(self.host, 1883, 1000) @task def test_mqtt_pub(self): print(\"start to send mqtt message\") print(self.client) self.client.publish(topic, payload='testggg', qos=0) class SubUser(MQTTUser): wait_time = between(3, 5) def on_start(self): self.client.connect(broker, 1883, 600) @task def test_mqtt_sub(self): print(\"recive message sussecc!!!\") self.client.subscribe(topic, qos=0) if __name__ == '__main__': os.system(\"locust -f locust_mqtt_demo1.py -u 1 -r 1 --headless --host=127.0.0.1\") 发布者 locust -f locust_mqtt.py PubUser -u 1 -r 1 --host=127.0.0.1 订阅者 locust -f locust_mqtt.py PubUser -u 1 -r 1 --host=127.0.0.1 在locust使用paho,由于是继承了client类, 在使用是有些方法可以根据业务需求来重写 ","date":"2022-01-09","objectID":"/blog/MQTT%E5%8E%8B%E6%B5%8B/:0:0","series":[],"tags":["mqtt"],"title":"[转]MQTT压测","uri":"/blog/MQTT%E5%8E%8B%E6%B5%8B/#locust压测mqtt"},{"categories":["performance"],"content":"客户端性能分析由于文章最开始提到客户端在直播间收到大量信令会ANR,我们需要看关注下设备的CPU. 这里使用的工具是perfdog: https://perfdog.qq.com/,这个工具安装使用很简单, 这里就讲解了. 下面这张图是,模拟压测产生ANR的客户端性能消耗. ","date":"2022-01-09","objectID":"/blog/MQTT%E5%8E%8B%E6%B5%8B/:0:0","series":[],"tags":["mqtt"],"title":"[转]MQTT压测","uri":"/blog/MQTT%E5%8E%8B%E6%B5%8B/#客户端性能分析"},{"categories":[],"content":"搭建hugo官方文档、DoIt主题文档、Hugo配置文件详解、Hugo文档 ","date":"2021-12-28","objectID":"/blog/%E5%BC%84%E4%B8%AAhugo%E7%8E%A9%E7%8E%A9/:1:0","series":["弄个blog玩玩"],"tags":["Hugo","blog"],"title":"使用hugo","uri":"/blog/%E5%BC%84%E4%B8%AAhugo%E7%8E%A9%E7%8E%A9/#搭建hugo"},{"categories":[],"content":"Hugo使用纪录优点：实时预览、生成速度快、配置简单。 缺点：对比HEXO，漂亮的主题资源少，相关的中文文档也少。 ","date":"2021-12-28","objectID":"/blog/%E5%BC%84%E4%B8%AAhugo%E7%8E%A9%E7%8E%A9/:2:0","series":["弄个blog玩玩"],"tags":["Hugo","blog"],"title":"使用hugo","uri":"/blog/%E5%BC%84%E4%B8%AAhugo%E7%8E%A9%E7%8E%A9/#hugo使用纪录"},{"categories":[],"content":"基础配置config.toml #URL 路径区分大小写。影响最终生成的静态资源目录地址，如Docker.md生成的路径为Docker/index.md #默认值为false，生成的文件夹为docker/index.md disablePathToLower = true #自动检测是否包含 中文\\日文\\韩文，影响预览 hasCJKLanguage = true #保留原文件名。已经被移除了，文件名如果包含除-以外的特殊字符会被清除，空格会转化成- preserveTaxonomyNames = true #Permalinks 配置 (https://gohugo.io/content-management/urls/#permalinks) [Permalinks] posts = \":year/:month/:filename\" ","date":"2021-12-28","objectID":"/blog/%E5%BC%84%E4%B8%AAhugo%E7%8E%A9%E7%8E%A9/:2:1","series":["弄个blog玩玩"],"tags":["Hugo","blog"],"title":"使用hugo","uri":"/blog/%E5%BC%84%E4%B8%AAhugo%E7%8E%A9%E7%8E%A9/#基础配置configtoml"},{"categories":[],"content":"文章内容配置 --- title: \"{{ replace .ContentBaseName \"-\" \" \" | title }}\" subtitle: \"\" date: {{ .Date }} lastmod: {{ .Date }} draft: true authors: [Forest] description: \"\" tags: [] categories: [] series: [] series_weight: 1 #首页屏蔽、搜索屏蔽 hiddenFromHomePage: false hiddenFromSearch: false #如果使用 typora 编辑文章，通过以下两项设置图片默认路径 typora-root-url: {{.File.Dir | replaceRE \"[^\\\\\\\\]+\\\\\\\\\" \"../\" }}../static/blog/{{.BaseFileName}} typora-copy-images-to: {{.File.Dir | replaceRE \"[^\\\\\\\\]+\\\\\\\\\" \"../\" }}../static/blog/{{.BaseFileName}}/{{.BaseFileName}}.assets/ --- #Hugo不会发布下面内容: publishdate 发布日期值设定在未来的内容 draft: true 草案状态设置为真的内容 expirydate 过期日期值设置为过去某事件的内容 ","date":"2021-12-28","objectID":"/blog/%E5%BC%84%E4%B8%AAhugo%E7%8E%A9%E7%8E%A9/:2:2","series":["弄个blog玩玩"],"tags":["Hugo","blog"],"title":"使用hugo","uri":"/blog/%E5%BC%84%E4%B8%AAhugo%E7%8E%A9%E7%8E%A9/#文章内容配置"},{"categories":[],"content":"命令 # 创建blog hugo new site my_website cd my_website # 创建第一篇文章 hugo new posts/first_post.md # 本地启动网站，去查看 http://localhost:1313 hugo serve -e production -D -F #生成静态资源到目标位置 hugo -d C:\\Users\\wxz\\Desktop\\publish [/]: hugo -help Usage: hugo [flags] hugo [command] Available Commands: check 包含一些验证检查 config 打印站点配置信息 convert 转化内容为其他不同模式 env 打印Hugo版本和环境信息 gen 几个有帮助的生成器的集合 help 关于命令的帮助 import 从它处导入你的站点 list 不同类型内容的列表 new 为站点生成新内容 server 高效能web服务器 version 打印Hugo版本号 Flags: -b, --baseURL string 对应于站点的域名(和路径),比如 https://spf13.com/ -D, --buildDrafts 包含标记为草案的内容 -E, --buildExpired 包含标记为过期的内容 -F, --buildFuture 包含标记发布日期为未来的的内容 --cacheDir string 缓存目录 默认是: $TMPDIR/hugo_cache/ --cleanDestinationDir 从目标目录删除不在static目录中内容 --config string 配置文件(默认是 path/config.yaml|json|toml) --configDir string 配置目录 (默认是 \"config\") -c, --contentDir string 内容目录路径 --debug 输出调试信息 -d, --destination string 输出文件的文件系统路径 --disableKinds strings 禁用其他不同格式的页面(home, RSS 等) --enableGitInfo 为页面添加Git修订版本、日期和作者等信息 -e, --environment string 构建环境 --forceSyncStatic 当static文件有变化时copy所有文件 --gc 构建后执行一些清理工作 (移除未用的缓存文件) -h, --help hugo的帮助 --i18n-warnings 显示丢失的翻译 --ignoreCache 忽略缓存 -l, --layoutDir string layout布局目录 --log 启用Log日志 --logFile string 日志文件路径 (如果设置此选项,自动启动日志) --minify 对支持的输出内容格式最小化(如HTML, XML 等) --noChmod 不同步文件的许可模式 --noTimes 不同步文件的修改时间 --path-warnings 目标路径重复是打印警告信息 --quiet 在安静模式构建 --renderToMemory 显示在内存中(仅仅在性能测试中有用) -s, --source string 读取文件的相对文件系统路径 --templateMetrics 显示模板执行的指标 --templateMetricsHints 计算一些改善的提示，当和 --templateMetrics一起使用时 -t, --theme strings 要使用的主题(位于 /themes/THEMENAME/) --themesDir string 主题路径的文件系统路径 --trace file 写跟踪信息的文件(一般来说无用) -v, --verbose 显示冗长的输出 --verboseLog 记录冗长的日志 -w, --watch 监控文件系统变化,并且在必要时重新创建网站文件 使用 \"hugo [command] --help\" 获得某个命令的更多信息. ","date":"2021-12-28","objectID":"/blog/%E5%BC%84%E4%B8%AAhugo%E7%8E%A9%E7%8E%A9/:2:3","series":["弄个blog玩玩"],"tags":["Hugo","blog"],"title":"使用hugo","uri":"/blog/%E5%BC%84%E4%B8%AAhugo%E7%8E%A9%E7%8E%A9/#命令"},{"categories":[],"content":"目录及模板说明 #post目录下的文章模板，具体配置见“文章内容配置” archetypes\\post.md #资源文件夹，里面的所有内容都会生成为静态资源文件 static\\ ","date":"2021-12-28","objectID":"/blog/%E5%BC%84%E4%B8%AAhugo%E7%8E%A9%E7%8E%A9/:2:4","series":["弄个blog玩玩"],"tags":["Hugo","blog"],"title":"使用hugo","uri":"/blog/%E5%BC%84%E4%B8%AAhugo%E7%8E%A9%E7%8E%A9/#目录及模板说明"},{"categories":[],"content":"ShortCodeHugo提供的简单代码段，可以生成HTML代码。简介、提供的方法 ","date":"2021-12-28","objectID":"/blog/%E5%BC%84%E4%B8%AAhugo%E7%8E%A9%E7%8E%A9/:2:5","series":["弄个blog玩玩"],"tags":["Hugo","blog"],"title":"使用hugo","uri":"/blog/%E5%BC%84%E4%B8%AAhugo%E7%8E%A9%E7%8E%A9/#shortcode"},{"categories":[],"content":"DoIt主题使用纪录 # 推荐服务启动命令 # --disableFastRender 参数来实时预览你正在编辑的文章页面. # -e production 命令来开启 评论系统, CDN 和 fingerprint 特性. hugo serve -e productio --disableFastRender ","date":"2021-12-28","objectID":"/blog/%E5%BC%84%E4%B8%AAhugo%E7%8E%A9%E7%8E%A9/:3:0","series":["弄个blog玩玩"],"tags":["Hugo","blog"],"title":"使用hugo","uri":"/blog/%E5%BC%84%E4%B8%AAhugo%E7%8E%A9%E7%8E%A9/#doit主题使用纪录"},{"categories":[],"content":"Hugo搭配typora，静态资源如何保存？ Typora 设置图片复制到指定目录 my_website_DoIt\\static\\blog\\${filename}\\${filename}.assets\\ 设置Hugo 模板 archetypes\\default.md，加上 Typora 的资源根目录 typora-root-url ，使用hugo 的 shortcode 自动生成相对路径。 typora-root-url: {{.File.Dir | replaceRE \"[^\\\\\\\\]+\\\\\\\\\" \"../\" }}../static/blog/{{.BaseFileName}} #也可以单独加上设置图片复制到指定目录 typora-copy-images-to: {{.File.Dir | replaceRE \"[^\\\\\\\\]+\\\\\\\\\" \"../\" }}../static/blog/{{.BaseFileName}}/{{.BaseFileName}}.assets/ md和静态资源结构 my_blog └── content └── posts ├── first.md └── second.md └── static └── blog ├── first.assets │ ├── image1 │ ├── image2 └── second.assets │ ├── image1 │ ├── image2 Hugo 设置 config.toml设置文章目录 [Permalinks] posts = \"blog/:filename\" md中图片路径 ![image](BaseFileName.assets/image.png) 最终生成静态资源结构 blog └── first ├── first.assets │ ├── image1 │ ├── image2 └── first.md └── second ├── second.assets │ ├── image1 │ ├── image2 └── second.md ","date":"2021-12-28","objectID":"/blog/%E5%BC%84%E4%B8%AAhugo%E7%8E%A9%E7%8E%A9/:4:0","series":["弄个blog玩玩"],"tags":["Hugo","blog"],"title":"使用hugo","uri":"/blog/%E5%BC%84%E4%B8%AAhugo%E7%8E%A9%E7%8E%A9/#hugo搭配typora静态资源如何保存"},{"categories":[],"content":"步骤 安装hexo npm install -g hexo-cli 初始化hexo #会生成一个myblog文件夹，文件夹内生成相关配置文件 hexo init myblog #下载node_modules npm install #新建完成后，指定文件夹目录下有： node_modules: 依赖包 public：存放生成的页面 scaffolds：生成文章的一些模板 source：用来存放你的文章 themes：主题 ** _config.yml: 博客的配置文件** 启动hexo服务 hexo g hexo server #命令说明 hexo n \"我的博客\" == hexo new \"我的博客\" #新建文章 hexo g == hexo generate #生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy #部署 hexo server #Hexo会监视文件变动并自动更新，无须重启服务器 hexo server -s #静态模式 hexo server -p 5000 #更改端口 hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存，若是网页正常情况下可以忽略这条命令 ","date":"2021-12-28","objectID":"/blog/%E5%BC%84%E4%B8%AAhexo%E7%8E%A9%E7%8E%A9/:0:0","series":["弄个blog玩玩"],"tags":["hexo","blog"],"title":"搭建hexo","uri":"/blog/%E5%BC%84%E4%B8%AAhexo%E7%8E%A9%E7%8E%A9/#步骤"},{"categories":[],"content":"踩的坑 wxz@DESKTOP-RFS74RI  ~\\Desktop\\wxzBlog [14:12] ❯ hexo g ERROR Cannot find module 'C:\\Users\\wxz\\Desktop\\wxzBlog\\node_modules\\bluebird\\js\\release\\bluebird.js'. Please verify that ERROR Local hexo loading failed in ~\\Desktop\\wxzBlog ERROR Try running: 'rm -rf node_modules \u0026\u0026 npm install --force' hexo依赖包下载失败导致的报错，删除node_modules、package-lock.json然后重新执行 npm install。 ","date":"2021-12-28","objectID":"/blog/%E5%BC%84%E4%B8%AAhexo%E7%8E%A9%E7%8E%A9/:0:0","series":["弄个blog玩玩"],"tags":["hexo","blog"],"title":"搭建hexo","uri":"/blog/%E5%BC%84%E4%B8%AAhexo%E7%8E%A9%E7%8E%A9/#踩的坑"},{"categories":[],"content":"1、服务器系统配置初始化 #/bin/bash # 安装系统性能分析工具及其他 yuminstallgccmakeautoconfvimsysstatnet-toolsiostatiftopiotpwgetlrzszlsofunzipopenssh-clientsnet-toolvimntpdate-y# 设置时区并同步时间 ln-s/usr/share/zoneinfo/Asia/Shanghai/etc/localtimeif!crontab-l|grepntpdate\u0026\u003e/dev/null;then(echo\"* 1 * * * ntpdate time.windows.com \u003e/dev/null 2\u003e\u00261\";crontab-l)|crontabfi# 禁用selinux sed-i'/SELINUX/{s/permissive/disabled/}'/etc/selinux/config# 关闭防火墙 ifegrep\"7.[0-9]\"/etc/redhat-release\u0026\u003e/dev/null;thensystemctlstopfirewalldsystemctldisablefirewalldelifegrep\"6.[0-9]\"/etc/redhat-release\u0026\u003e/dev/null;thenserviceiptablesstopchkconfigiptablesofffi# 历史命令显示操作时间 if!grepHISTTIMEFORMAT/etc/bashrc;thenecho'export HISTTIMEFORMAT=\"%Y-%m-%d %H:%M:%S `whoami` \"'\u003e\u003e/etc/bashrcfi# SSH超时时间 if!grep\"TMOUT=600\"/etc/profile\u0026\u003e/dev/null;thenecho\"export TMOUT=600\"\u003e\u003e/etc/profilefi# 禁止root远程登录 切记给系统添加普通用户，给su到root的权限 sed-i's/#PermitRootLogin yes/PermitRootLogin no/'/etc/ssh/sshd_config# 禁止定时任务向发送邮件 sed-i's/^MAILTO=root/MAILTO=\"\"/'/etc/crontab# 设置最大打开文件数 if!grep\"* soft nofile 65535\"/etc/security/limits.conf\u0026\u003e/dev/null;thencat\u003e\u003e/etc/security/limits.conf\u003c\u003cEOF*softnofile65535*hardnofile65535EOFfi# 系统内核优化 cat\u003e\u003e/etc/sysctl.conf\u003c\u003cEOFnet.ipv4.tcp_syncookies=1net.ipv4.tcp_max_tw_buckets=20480net.ipv4.tcp_max_syn_backlog=20480net.core.netdev_max_backlog=262144net.ipv4.tcp_fin_timeout=20EOF# 减少SWAP使用 echo\"0\"\u003e/proc/sys/vm/swappiness ","date":"2021-12-13","objectID":"/blog/%E5%AE%9E%E7%94%A8shell%E8%84%9A%E6%9C%AC/:1:0","series":[],"tags":["shell"],"title":"【转】实用shell脚本","uri":"/blog/%E5%AE%9E%E7%94%A8shell%E8%84%9A%E6%9C%AC/#1服务器系统配置初始化"},{"categories":[],"content":"2、批量创建多个用户并设置密码 #!/bin/bash USER_LIST=$@ USER_FILE=./user.info for USER in $USER_LIST;do if ! id $USER \u0026\u003e/dev/null; then PASS=$(echo $RANDOM |md5sum |cut -c 1-8) useradd $USER echo $PASS | passwd --stdin $USER \u0026\u003e/dev/null echo \"$USER$PASS\" \u003e\u003e $USER_FILE echo \"$USERUser create successful.\" else echo \"$USERUser already exists!\" fi done ","date":"2021-12-13","objectID":"/blog/%E5%AE%9E%E7%94%A8shell%E8%84%9A%E6%9C%AC/:2:0","series":[],"tags":["shell"],"title":"【转】实用shell脚本","uri":"/blog/%E5%AE%9E%E7%94%A8shell%E8%84%9A%E6%9C%AC/#2批量创建多个用户并设置密码"},{"categories":[],"content":"3、一键查看服务器利用率 #!/bin/bash function cpu(){ util=$(vmstat | awk '{if(NR==3)print $13+$14}') iowait=$(vmstat | awk '{if(NR==3)print $16}') echo \"CPU -使用率：${util}% ,等待磁盘IO相应使用率：${iowait}:${iowait}%\" } function memory (){ total=`free -m |awk '{if(NR==2)printf \"%.1f\",$2/1024}'` used=`free -m |awk '{if(NR==2) printf \"%.1f\",($2-$NF)/1024}'` available=`free -m |awk '{if(NR==2) printf \"%.1f\",$NF/1024}'` echo \"内存 - 总大小: ${total}G , 使用: ${used}G , 剩余: ${available}G\" } disk(){ fs=$(df -h |awk '/^\\/dev/{print $1}') for p in $fs; do mounted=$(df -h |awk '$1==\"'$p'\"{print $NF}') size=$(df -h |awk '$1==\"'$p'\"{print $2}') used=$(df -h |awk '$1==\"'$p'\"{print $3}') used_percent=$(df -h |awk '$1==\"'$p'\"{print $5}') echo \"硬盘 - 挂载点: $mounted, 总大小: $size, 使用: $used, 使用率: $used_percent\" done } function tcp_status() { summary=$(ss -antp |awk '{status[$1]++}END{for(i in status) printf i\":\"status[i]\" \"}') echo \"TCP连接状态 - $summary\" } cpu memory disk tcp_status ","date":"2021-12-13","objectID":"/blog/%E5%AE%9E%E7%94%A8shell%E8%84%9A%E6%9C%AC/:3:0","series":[],"tags":["shell"],"title":"【转】实用shell脚本","uri":"/blog/%E5%AE%9E%E7%94%A8shell%E8%84%9A%E6%9C%AC/#3一键查看服务器利用率"},{"categories":[],"content":"4、找出占用CPU 内存过高的进程 #!/bin/bash echo \"-------------------CUP占用前10排序--------------------------------\" ps -eo user,pid,pcpu,pmem,args --sort=-pcpu |head -n 10 echo \"-------------------内存占用前10排序--------------------------------\" ps -eo user,pid,pcpu,pmem,args --sort=-pmem |head -n 10 ","date":"2021-12-13","objectID":"/blog/%E5%AE%9E%E7%94%A8shell%E8%84%9A%E6%9C%AC/:4:0","series":[],"tags":["shell"],"title":"【转】实用shell脚本","uri":"/blog/%E5%AE%9E%E7%94%A8shell%E8%84%9A%E6%9C%AC/#4找出占用cpu-内存过高的进程"},{"categories":[],"content":"5、查看网卡的实时流量 #!/bin/bash eth0=$1 echo -e \"流量进入--流量传出 \" while true; do old_in=$(cat /proc/net/dev |grep $eth0 |awk '{print $2}') old_out=$(cat /proc/net/dev |grep $eth0 |awk '{print $10}') sleep 1 new_in=$(cat /proc/net/dev |grep $eth0 |awk '{print $2}') new_out=$(cat /proc/net/dev |grep $eth0 |awk '{print $10}') in=$(printf \"%.1f%s\" \"$((($new_in-$old_in)/1024))\" \"KB/s\") out=$(printf \"%.1f%s\" \"$((($new_out-$old_out)/1024))\" \"KB/s\") echo \"$in$out\" done ","date":"2021-12-13","objectID":"/blog/%E5%AE%9E%E7%94%A8shell%E8%84%9A%E6%9C%AC/:5:0","series":[],"tags":["shell"],"title":"【转】实用shell脚本","uri":"/blog/%E5%AE%9E%E7%94%A8shell%E8%84%9A%E6%9C%AC/#5查看网卡的实时流量"},{"categories":[],"content":"6、监控多台服务器磁盘利用率脚本 #!/bin/bash HOST_INFO=host.info for IP in $(awk '/^[^#]/{print $1}' $HOST_INFO); do #取出用户名和端口 USER=$(awk -v ip=$IP 'ip==$1{print $2}' $HOST_INFO) PORT=$(awk -v ip=$IP 'ip==$1{print $3}' $HOST_INFO) #创建临时文件，保存信息 TMP_FILE=/tmp/disk.tmp #通过公钥登录获取主机磁盘信息 ssh -p $PORT $USER@$IP 'df -h' \u003e $TMP_FILE #分析磁盘占用空间 USE_RATE_LIST=$(awk 'BEGIN{OFS=\"=\"}/^\\/dev/{print $NF,int($5)}' $TMP_FILE) #循环磁盘列表，进行判断 for USE_RATE in $USE_RATE_LIST; do #取出等号（=）右边的值 挂载点名称 PART_NAME=${USE_RATE%=*} #取出等号（=）左边的值 磁盘利用率 USE_RATE=${USE_RATE#*=} #进行判断 if [ $USE_RATE -ge 80 ]; then echo \"Warning: $PART_NAMEPartition usage $USE_RATE%!\" echo \"服务器$IP的磁盘空间占用过高，请及时处理\" | mail -s \"空间不足警告\" 你的qq@qq.com else echo \"服务器$IP的$PART_NAME目录空间良好\" fi done done ","date":"2021-12-13","objectID":"/blog/%E5%AE%9E%E7%94%A8shell%E8%84%9A%E6%9C%AC/:6:0","series":[],"tags":["shell"],"title":"【转】实用shell脚本","uri":"/blog/%E5%AE%9E%E7%94%A8shell%E8%84%9A%E6%9C%AC/#6监控多台服务器磁盘利用率脚本"},{"categories":[],"content":"7、批量检测网站是否异常并邮件通知 #!/bin/bash URL_LIST=\"www.baidu.com www.ctnrs.com www.der-matech.net.cn www.der-matech.com.cn www.der-matech.cn www.der-matech.top www.der-matech.org\" for URL in $URL_LIST; do FAIL_COUNT=0 for ((i=1;i\u003c=3;i++)); do HTTP_CODE=$(curl -o /dev/null --connect-timeout 3 -s -w \"%{http_code}\" $URL) if [ $HTTP_CODE -eq 200 ]; then echo \"$URLOK\" break else echo \"$URLretry $FAIL_COUNT\" let FAIL_COUNT++ fi done if [ $FAIL_COUNT -eq 3 ]; then echo \"Warning: $URLAccess failure!\" echo \"网站$URL坏掉，请及时处理\" | mail -s \"$URL网站高危\" 1794748404@qq.com fi done ","date":"2021-12-13","objectID":"/blog/%E5%AE%9E%E7%94%A8shell%E8%84%9A%E6%9C%AC/:7:0","series":[],"tags":["shell"],"title":"【转】实用shell脚本","uri":"/blog/%E5%AE%9E%E7%94%A8shell%E8%84%9A%E6%9C%AC/#7批量检测网站是否异常并邮件通知"},{"categories":[],"content":"8、批量主机远程执行命令脚本 #!/bin/bash COMMAND=$* HOST_INFO=host.info for IP in $(awk '/^[^#]/{print $1}' $HOST_INFO); do USER=$(awk -v ip=$IP 'ip==$1{print $2}' $HOST_INFO) PORT=$(awk -v ip=$IP 'ip==$1{print $3}' $HOST_INFO) PASS=$(awk -v ip=$IP 'ip==$1{print $4}' $HOST_INFO) expect -c \" spawn ssh -p $PORT$USER@$IPexpect { \\\"(yes/no)\\\" {send \\\"yes\\r\\\"; exp_continue} \\\"password:\\\" {send \\\"$PASS\\r\\\"; exp_continue} \\\"$USER@*\\\" {send \\\"$COMMAND\\r exit\\r\\\"; exp_continue} } \" echo \"-------------------\" done ","date":"2021-12-13","objectID":"/blog/%E5%AE%9E%E7%94%A8shell%E8%84%9A%E6%9C%AC/:8:0","series":[],"tags":["shell"],"title":"【转】实用shell脚本","uri":"/blog/%E5%AE%9E%E7%94%A8shell%E8%84%9A%E6%9C%AC/#8批量主机远程执行命令脚本"},{"categories":[],"content":"9、一键部署LNMP网站平台脚本 #!/bin/bash NGINX_V=1.15.6 PHP_V=5.6.36 TMP_DIR=/tmp INSTALL_DIR=/usr/local PWD_C=$PWD echo echo -e \"\\tMenu\\n\" echo -e \"1. Install Nginx\" echo -e \"2. Install PHP\" echo -e \"3. Install MySQL\" echo -e \"4. Deploy LNMP\" echo -e \"9. Quit\" function command_status_check() { if [ $? -ne 0 ]; then echo $1 exit fi } function install_nginx() { cd $TMP_DIR yum install -y gcc gcc-c++ make openssl-devel pcre-devel wget wget http://nginx.org/download/nginx-${NGINX_V}.tar.gz tar zxf nginx-${NGINX_V}.tar.gz cd nginx-${NGINX_V} ./configure --prefix=$INSTALL_DIR/nginx \\ --with-http_ssl_module \\ --with-http_stub_status_module \\ --with-stream command_status_check \"Nginx - 平台环境检查失败！\" make -j 4 command_status_check \"Nginx - 编译失败！\" make install command_status_check \"Nginx - 安装失败！\" mkdir -p $INSTALL_DIR/nginx/conf/vhost alias cp=cp ; cp -rf $PWD_C/nginx.conf $INSTALL_DIR/nginx/conf rm -rf $INSTALL_DIR/nginx/html/* echo \"ok\" \u003e $INSTALL_DIR/nginx/html/status.html echo '\u003c?php echo \"ok\"?\u003e' \u003e $INSTALL_DIR/nginx/html/status.php $INSTALL_DIR/nginx/sbin/nginx command_status_check \"Nginx - 启动失败！\" } function install_php() { cd $TMP_DIR yum install -y gcc gcc-c++ make gd-devel libxml2-devel \\ libcurl-devel libjpeg-devel libpng-devel openssl-devel \\ libmcrypt-devel libxslt-devel libtidy-devel wget http://docs.php.net/distributions/php-${PHP_V}.tar.gz tar zxf php-${PHP_V}.tar.gz cd php-${PHP_V} ./configure --prefix=$INSTALL_DIR/php \\ --with-config-file-path=$INSTALL_DIR/php/etc \\ --enable-fpm --enable-opcache \\ --with-mysql --with-mysqli --with-pdo-mysql \\ --with-openssl --with-zlib --with-curl --with-gd \\ --with-jpeg-dir --with-png-dir --with-freetype-dir \\ --enable-mbstring --enable-hash command_status_check \"PHP - 平台环境检查失败！\" make -j 4 command_status_check \"PHP - 编译失败！\" make install command_status_check \"PHP - 安装失败！\" cp php.ini-production $INSTALL_DIR/php/etc/php.ini cp sapi/fpm/php-fpm.conf $INSTALL_DIR/php/etc/php-fpm.conf cp sapi/fpm/init.d.php-fpm /etc/init.d/php-fpm chmod +x /etc/init.d/php-fpm /etc/init.d/php-fpm start command_status_check \"PHP - 启动失败！\" } read -p \"请输入编号：\" number case $number in 1) install_nginx;; 2) install_php;; 3) install_mysql;; 4) install_nginx install_php ;; 9) exit;; esac ","date":"2021-12-13","objectID":"/blog/%E5%AE%9E%E7%94%A8shell%E8%84%9A%E6%9C%AC/:9:0","series":[],"tags":["shell"],"title":"【转】实用shell脚本","uri":"/blog/%E5%AE%9E%E7%94%A8shell%E8%84%9A%E6%9C%AC/#9一键部署lnmp网站平台脚本"},{"categories":[],"content":"10、监控MySQL主从同步状态是否异常脚本 #!/bin/bash HOST=localhost USER=root PASSWD=123.com IO_SQL_STATUS=$(mysql -h$HOST -u$USER -p$PASSWD -e 'show slave status\\G' 2\u003e/dev/null |awk '/Slave_.*_Running:/{print $1$2}') for i in $IO_SQL_STATUS; do THREAD_STATUS_NAME=${i%:*} THREAD_STATUS=${i#*:} if [ \"$THREAD_STATUS\" != \"Yes\" ]; then echo \"Error: MySQL Master-Slave $THREAD_STATUS_NAMEstatus is $THREAD_STATUS!\" |mail -s \"Master-Slave Staus\" xxx@163.com fi done ","date":"2021-12-13","objectID":"/blog/%E5%AE%9E%E7%94%A8shell%E8%84%9A%E6%9C%AC/:10:0","series":[],"tags":["shell"],"title":"【转】实用shell脚本","uri":"/blog/%E5%AE%9E%E7%94%A8shell%E8%84%9A%E6%9C%AC/#10监控mysql主从同步状态是否异常脚本"},{"categories":[],"content":"11、MySql数据库备份脚本分库备份 mysqldump -uroot -pxxx -B A \u003e A.sql #!/bin/bash DATE=$(date +%F_%H-%M-%S) HOST=localhost USER=backup PASS=123.com BACKUP_DIR=/data/db_backup DB_LIST=$(mysql -h$HOST -u$USER -p$PASS -s -e \"show databases;\" 2\u003e/dev/null |egrep -v \"Database|information_schema|mysql|performance_schema|sys\") for DB in $DB_LIST; do BACKUP_NAME=$BACKUP_DIR/${DB}_${DATE}.sql if ! mysqldump -h$HOST -u$USER -p$PASS -B $DB \u003e $BACKUP_NAME 2\u003e/dev/null; then echo \"$BACKUP_NAME备份失败!\" fi done 分表备份 mysqldump -uroot -pxxx -A t \u003e t.sql #!/bin/bash DATE=$(date +%F_%H-%M-%S) HOST=localhost USER=backup PASS=123.com BACKUP_DIR=/data/db_backup DB_LIST=$(mysql -h$HOST -u$USER -p$PASS -s -e \"show databases;\" 2\u003e/dev/null |egrep -v \"Database|information_schema|mysql|performance_schema|sys\") for DB in $DB_LIST; do BACKUP_DB_DIR=$BACKUP_DIR/${DB}_${DATE} [ ! -d $BACKUP_DB_DIR ] \u0026\u0026 mkdir -p $BACKUP_DB_DIR \u0026\u003e/dev/null TABLE_LIST=$(mysql -h$HOST -u$USER -p$PASS -s -e \"use $DB;show tables;\" 2\u003e/dev/null) for TABLE in $TABLE_LIST; do BACKUP_NAME=$BACKUP_DB_DIR/${TABLE}.sql if ! mysqldump -h$HOST -u$USER -p$PASS $DB $TABLE \u003e $BACKUP_NAME 2\u003e/dev/null; then echo \"$BACKUP_NAME备份失败!\" fi done done ","date":"2021-12-13","objectID":"/blog/%E5%AE%9E%E7%94%A8shell%E8%84%9A%E6%9C%AC/:11:0","series":[],"tags":["shell"],"title":"【转】实用shell脚本","uri":"/blog/%E5%AE%9E%E7%94%A8shell%E8%84%9A%E6%9C%AC/#11mysql数据库备份脚本"},{"categories":[],"content":"11、MySql数据库备份脚本分库备份 mysqldump -uroot -pxxx -B A A.sql #!/bin/bash DATE=$(date +%F_%H-%M-%S) HOST=localhost USER=backup PASS=123.com BACKUP_DIR=/data/db_backup DB_LIST=$(mysql -h$HOST -u$USER -p$PASS -s -e \"show databases;\" 2/dev/null |egrep -v \"Database|information_schema|mysql|performance_schema|sys\") for DB in $DB_LIST; do BACKUP_NAME=$BACKUP_DIR/${DB}_${DATE}.sql if ! mysqldump -h$HOST -u$USER -p$PASS -B $DB $BACKUP_NAME 2/dev/null; then echo \"$BACKUP_NAME备份失败!\" fi done 分表备份 mysqldump -uroot -pxxx -A t t.sql #!/bin/bash DATE=$(date +%F_%H-%M-%S) HOST=localhost USER=backup PASS=123.com BACKUP_DIR=/data/db_backup DB_LIST=$(mysql -h$HOST -u$USER -p$PASS -s -e \"show databases;\" 2/dev/null |egrep -v \"Database|information_schema|mysql|performance_schema|sys\") for DB in $DB_LIST; do BACKUP_DB_DIR=$BACKUP_DIR/${DB}_${DATE} [ ! -d $BACKUP_DB_DIR ] \u0026\u0026 mkdir -p $BACKUP_DB_DIR \u0026/dev/null TABLE_LIST=$(mysql -h$HOST -u$USER -p$PASS -s -e \"use $DB;show tables;\" 2/dev/null) for TABLE in $TABLE_LIST; do BACKUP_NAME=$BACKUP_DB_DIR/${TABLE}.sql if ! mysqldump -h$HOST -u$USER -p$PASS $DB $TABLE $BACKUP_NAME 2/dev/null; then echo \"$BACKUP_NAME备份失败!\" fi done done ","date":"2021-12-13","objectID":"/blog/%E5%AE%9E%E7%94%A8shell%E8%84%9A%E6%9C%AC/:11:0","series":[],"tags":["shell"],"title":"【转】实用shell脚本","uri":"/blog/%E5%AE%9E%E7%94%A8shell%E8%84%9A%E6%9C%AC/#分库备份"},{"categories":[],"content":"11、MySql数据库备份脚本分库备份 mysqldump -uroot -pxxx -B A A.sql #!/bin/bash DATE=$(date +%F_%H-%M-%S) HOST=localhost USER=backup PASS=123.com BACKUP_DIR=/data/db_backup DB_LIST=$(mysql -h$HOST -u$USER -p$PASS -s -e \"show databases;\" 2/dev/null |egrep -v \"Database|information_schema|mysql|performance_schema|sys\") for DB in $DB_LIST; do BACKUP_NAME=$BACKUP_DIR/${DB}_${DATE}.sql if ! mysqldump -h$HOST -u$USER -p$PASS -B $DB $BACKUP_NAME 2/dev/null; then echo \"$BACKUP_NAME备份失败!\" fi done 分表备份 mysqldump -uroot -pxxx -A t t.sql #!/bin/bash DATE=$(date +%F_%H-%M-%S) HOST=localhost USER=backup PASS=123.com BACKUP_DIR=/data/db_backup DB_LIST=$(mysql -h$HOST -u$USER -p$PASS -s -e \"show databases;\" 2/dev/null |egrep -v \"Database|information_schema|mysql|performance_schema|sys\") for DB in $DB_LIST; do BACKUP_DB_DIR=$BACKUP_DIR/${DB}_${DATE} [ ! -d $BACKUP_DB_DIR ] \u0026\u0026 mkdir -p $BACKUP_DB_DIR \u0026/dev/null TABLE_LIST=$(mysql -h$HOST -u$USER -p$PASS -s -e \"use $DB;show tables;\" 2/dev/null) for TABLE in $TABLE_LIST; do BACKUP_NAME=$BACKUP_DB_DIR/${TABLE}.sql if ! mysqldump -h$HOST -u$USER -p$PASS $DB $TABLE $BACKUP_NAME 2/dev/null; then echo \"$BACKUP_NAME备份失败!\" fi done done ","date":"2021-12-13","objectID":"/blog/%E5%AE%9E%E7%94%A8shell%E8%84%9A%E6%9C%AC/:11:0","series":[],"tags":["shell"],"title":"【转】实用shell脚本","uri":"/blog/%E5%AE%9E%E7%94%A8shell%E8%84%9A%E6%9C%AC/#分表备份"},{"categories":[],"content":"12、Nginx访问日志分析 #!/bin/bash # 日志格式: $remote_addr - $remote_user [$time_local] \"$request\" $status $body_bytes_sent \"$http_referer\" \"$http_user_agent\" \"$http_x_forwarded_for\" LOG_FILE=$1 echo \"统计访问最多的10个IP\" awk '{a[$1]++}END{print \"UV:\",length(a);for(v in a)print v,a[v]}' $LOG_FILE |sort -k2 -nr |head -10 echo \"----------------------\" echo \"统计时间段访问最多的IP\" awk '$4\u003e=\"[01/Dec/2018:13:20:25\" \u0026\u0026 $4\u003c=\"[27/Nov/2018:16:20:49\"{a[$1]++}END{for(v in a)print v,a[v]}' $LOG_FILE |sort -k2 -nr|head -10 echo \"----------------------\" echo \"统计访问最多的10个页面\" awk '{a[$7]++}END{print \"PV:\",length(a);for(v in a){if(a[v]\u003e10)print v,a[v]}}' $LOG_FILE |sort -k2 -nr echo \"----------------------\" echo \"统计访问页面状态码数量\" awk '{a[$7\" \"$9]++}END{for(v in a){if(a[v]\u003e5)print v,a[v]}}' $LOG_FILE |sort -k3 -nr ","date":"2021-12-13","objectID":"/blog/%E5%AE%9E%E7%94%A8shell%E8%84%9A%E6%9C%AC/:12:0","series":[],"tags":["shell"],"title":"【转】实用shell脚本","uri":"/blog/%E5%AE%9E%E7%94%A8shell%E8%84%9A%E6%9C%AC/#12nginx访问日志分析"},{"categories":[],"content":"13、Nginx访问日志自动按天（周、月）切割 #!/bin/bash #nginx日志目录 LOG_DIR=/www/server/nginx/logs #获取到上一天的时间 YESTERDAY_TIME=$(date -d \"yesterday\" +%F) #归档日志取时间 LOG_MONTH_DIR=$LOG_DIR/$(date +\"%Y-%m\") #归档日志的名称 LOG_FILE_LIST=\"access.log\" for LOG_FILE in $LOG_FILE_LIST; do [ ! -d $LOG_MONTH_DIR ] \u0026\u0026 mkdir -p $LOG_MONTH_DIR mv $LOG_DIR/$LOG_FILE $LOG_MONTH_DIR/${LOG_FILE}_${YESTERDAY_TIME} done kill -USR1 $(cat $LOG_DIR/nginx.pid) ","date":"2021-12-13","objectID":"/blog/%E5%AE%9E%E7%94%A8shell%E8%84%9A%E6%9C%AC/:13:0","series":[],"tags":["shell"],"title":"【转】实用shell脚本","uri":"/blog/%E5%AE%9E%E7%94%A8shell%E8%84%9A%E6%9C%AC/#13nginx访问日志自动按天周月切割"},{"categories":[],"content":"14、自动发布Java项目（Tomcat） #!/bin/bash DATE=$(date +%F_%T) TOMCAT_NAME=$1 TOMCAT_DIR=/usr/local/$TOMCAT_NAME ROOT=$TOMCAT_DIR/webapps/ROOT BACKUP_DIR=/data/backup WORK_DIR=/tmp PROJECT_NAME=tomcat-java-demo # 拉取代码 cd $WORK_DIR if [ ! -d $PROJECT_NAME ]; then git clone https://github.com/lizhenliang/tomcat-java-demo cd $PROJECT_NAME else cd $PROJECT_NAME git pull fi # 构建 mvn clean package -Dmaven.test.skip=true if [ $? -ne 0 ]; then echo \"maven build failure!\" exit 1 fi # 部署 TOMCAT_PID=$(ps -ef |grep \"$TOMCAT_NAME\" |egrep -v \"grep|$$\" |awk 'NR==1{print $2}') [ -n \"$TOMCAT_PID\" ] \u0026\u0026 kill -9 $TOMCAT_PID [ -d $ROOT ] \u0026\u0026 mv $ROOT $BACKUP_DIR/${TOMCAT_NAME}_ROOT$DATE unzip $WORK_DIR/$PROJECT_NAME/target/*.war -d $ROOT $TOMCAT_DIR/bin/startup.sh ","date":"2021-12-13","objectID":"/blog/%E5%AE%9E%E7%94%A8shell%E8%84%9A%E6%9C%AC/:14:0","series":[],"tags":["shell"],"title":"【转】实用shell脚本","uri":"/blog/%E5%AE%9E%E7%94%A8shell%E8%84%9A%E6%9C%AC/#14自动发布java项目tomcat"},{"categories":[],"content":"15、自动发布PHP项目 #!/bin/bash DATE=$(date +%F_%T) WWWROOT=/usr/local/nginx/html/$1 BACKUP_DIR=/data/backup WORK_DIR=/tmp PROJECT_NAME=php-demo # 拉取代码 cd $WORK_DIR if [ ! -d $PROJECT_NAME ]; then git clone https://github.com/lizhenliang/php-demo cd $PROJECT_NAME else cd $PROJECT_NAME git pull fi # 部署 if [ ! -d $WWWROOT ]; then mkdir -p $WWWROOT rsync -avz --exclude=.git $WORK_DIR/$PROJECT_NAME/* $WWWROOT else rsync -avz --exclude=.git $WORK_DIR/$PROJECT_NAME/* $WWWROOT fi ","date":"2021-12-13","objectID":"/blog/%E5%AE%9E%E7%94%A8shell%E8%84%9A%E6%9C%AC/:15:0","series":[],"tags":["shell"],"title":"【转】实用shell脚本","uri":"/blog/%E5%AE%9E%E7%94%A8shell%E8%84%9A%E6%9C%AC/#15自动发布php项目"},{"categories":[],"content":"16、DOS攻击防范（自动屏蔽攻击IP） #!/bin/bash DATE=$(date +%d/%b/%Y:%H:%M) #nginx日志 LOG_FILE=/usr/local/nginx/logs/demo2.access.log #分析ip的访问情况 ABNORMAL_IP=$(tail -n5000 $LOG_FILE |grep $DATE |awk '{a[$1]++}END{for(i in a)if(a[i]\u003e10)print i}') for IP in $ABNORMAL_IP; do if [ $(iptables -vnL |grep -c \"$IP\") -eq 0 ]; then iptables -I INPUT -s $IP -j DROP echo \"$(date +'%F_%T')$IP\" \u003e\u003e /tmp/drop_ip.log fi done ","date":"2021-12-13","objectID":"/blog/%E5%AE%9E%E7%94%A8shell%E8%84%9A%E6%9C%AC/:16:0","series":[],"tags":["shell"],"title":"【转】实用shell脚本","uri":"/blog/%E5%AE%9E%E7%94%A8shell%E8%84%9A%E6%9C%AC/#16dos攻击防范自动屏蔽攻击ip"},{"categories":[],"content":"17、目录入侵检测与告警 #!/bin/bash MON_DIR=/opt inotifywait -mqr --format %f -e create $MON_DIR |\\ while read files; do #同步文件 rsync -avz /opt /tmp/opt #检测文件是否被修改 #echo \"$(date +'%F %T') create $files\" | mail -s \"dir monitor\" xxx@163.com done ","date":"2021-12-13","objectID":"/blog/%E5%AE%9E%E7%94%A8shell%E8%84%9A%E6%9C%AC/:17:0","series":[],"tags":["shell"],"title":"【转】实用shell脚本","uri":"/blog/%E5%AE%9E%E7%94%A8shell%E8%84%9A%E6%9C%AC/#17目录入侵检测与告警"},{"categories":[],"content":"Typora+picgo+七牛云 注册七牛云 实名认证，赠送10G免费存储空间，默认送一个CDN域名但是只有3个月使用期限，所以需要自己购买域名。 新增CDN域名（必须要备案过的域名），系统会生成一个CNAME 将CDN域名解析至CNAME域名即可绑定成功 新增空间并配置CDN域名，配置默认外域链接名为配置好的CDN域名，上传一张图片，图片详情里面的文件连接方式即可变更为你的CDN域名。 下载安装picgo，选择七牛图床，AccessKey/SecretKey在七牛云个人设置-密钥管理中配置，配置好后上传图片即可成功 在typora-偏好设置-图像 里，设置上传服务设定，复制粘贴图片即可自动上传到七牛云上 ","date":"2021-11-18","objectID":"/blog/TyporaPicgo7%E7%89%9B%E4%BA%91/:1:0","series":["弄个blog玩玩"],"tags":["typora","picgo","七牛云"],"title":"Typora+picgo+7牛云","uri":"/blog/TyporaPicgo7%E7%89%9B%E4%BA%91/#typorapicgo七牛云"},{"categories":[],"content":"PICGO插件插件库：Awesome-picgo 图片压缩插件：compress 自定义图片路径插件：rename-file ","date":"2021-11-18","objectID":"/blog/TyporaPicgo7%E7%89%9B%E4%BA%91/:2:0","series":["弄个blog玩玩"],"tags":["typora","picgo","七牛云"],"title":"Typora+picgo+7牛云","uri":"/blog/TyporaPicgo7%E7%89%9B%E4%BA%91/#picgo插件"},{"categories":[],"content":"图片保存本地图片压缩工具：Caesium Image Compressor ","date":"2021-11-18","objectID":"/blog/TyporaPicgo7%E7%89%9B%E4%BA%91/:3:0","series":["弄个blog玩玩"],"tags":["typora","picgo","七牛云"],"title":"Typora+picgo+7牛云","uri":"/blog/TyporaPicgo7%E7%89%9B%E4%BA%91/#图片保存本地"},{"categories":[],"content":"Typora文档 ","date":"2021-11-18","objectID":"/blog/TyporaPicgo7%E7%89%9B%E4%BA%91/:4:0","series":["弄个blog玩玩"],"tags":["typora","picgo","七牛云"],"title":"Typora+picgo+7牛云","uri":"/blog/TyporaPicgo7%E7%89%9B%E4%BA%91/#typora"},{"categories":["performance"],"content":"数据量过大导致优化器使用错误索引1、线上告警：CPU接近跑满，突破“严重”级别阈值 2、问题SQL：抓取今早 08:16 分慢查询如下 select*fromorder_park_orderwhereplate_no=''andtype=2andstatusin(0,1,2,3,4,99)orderbystart_datedesclimit1; 扫描订单表行数接近全表数据（约三千万），估计很大可能性是走的全表扫描。 3、查看SQL的执行计划： 走的是全索引扫描index类型（注意不是索引查找如ref、range类型等，index类型比all类型即全表扫描好不到哪儿去），使用的竟然是start_date字段上的索引，而且扫描行数才13行就离谱。 这是因为explain工具本局限性，特别对如有limit的语句支持不够好，有时候统计并不准确。 对于innodb引擎，可以使用下面语句来获取实际扫描行数： 注意上面的 Handler_read_prev 含义参见官方文档： https://dev.mysql.com/doc/refman/5.7/en/server-status-variables.html#statvar_Handler_read_prev The number of requests to read the previous row in key order. This read method is mainly used to optimize ORDER BY … DESC. 含义就是在进行索引扫描时，按照索引倒序从数据文件里取数据的次数（一般就是有 ORDER BY … DESC 的情况) 亦即实际扫描行数和慢查询日志里面的是相符的，都是接近三千万的全表数据量，而不是explain里面展示的仅仅13条。 4、原SQL的耗时由此估计也是集中在过程中数据的回表处理，通过查看SQL的执行过程可以进一步确认： 原SQL在测试环境执行一次需要4百多秒（低于线上配置），可以看到绝大部分耗时都是在 Sending data 特别注意 Sending data 不是字面上的发送数据，而是包括收集（主要是回表)+发送数据 这里加了limit，耗时主要就是在过程中的数据收集上，亦即前面分析的走到错误的 start_date 索引上导致的回表进行全表数据操作 5、为什么会走到 start_date 上的索引？ 应该是优化器被 order by 给误导，优化器本意是利用索引的有序性，省去排序的成本，但这只是一方面。 分析原SQL的where条件，where条件中只有 plate_no 有索引： （1）当where条件只有plate_no时，是可以用到索引的，执行还是很快的： 注意上面的是 Using index （2）当where条件不只有plate_no时，仍然可以用到索引，但执行变得很慢了： 注意上面的 Using where ，与上面 Using index 区别， 表示因为索引 idx_park_order_plt_no 只包含 (plate_no,id)列，只通过该索引是没办法判断type=2条件的，因而会有通过索引收集到的一批id去返回数据文件取数据（回表）。 （3）为什么加了type=2就变慢了呢？除了回表操作，还因为数据量的影响： where 条件 plate_no='' 实际数据量有100多万，也就是说差不多要回表获取百万计的行 总结：因为即使应用了正确索引但条件筛选的数据量大，再加上索引不能覆盖where条件的其他字段，导致发生回表的大量数据操作，本身成本较高！更糟糕的是，在成本较高的情况下，因为需要进行order by倒序的诱导，优化器后又进一步选择了错误的 start_date 索引上，最后的结果是性能更低！！如此多方面因素，造成了这样的情况结果。 ","date":"2021-09-16","objectID":"/blog/%E6%95%B0%E6%8D%AE%E9%87%8F%E8%BF%87%E5%A4%A7%E5%AF%BC%E8%87%B4%E4%BC%98%E5%8C%96%E5%99%A8%E4%BD%BF%E7%94%A8%E9%94%99%E8%AF%AF%E7%B4%A2%E5%BC%95/:0:0","series":[],"tags":["mysql"],"title":"[慢SQL分析]数据量过大导致优化器使用错误索引","uri":"/blog/%E6%95%B0%E6%8D%AE%E9%87%8F%E8%BF%87%E5%A4%A7%E5%AF%BC%E8%87%B4%E4%BC%98%E5%8C%96%E5%99%A8%E4%BD%BF%E7%94%A8%E9%94%99%E8%AF%AF%E7%B4%A2%E5%BC%95/#数据量过大导致优化器使用错误索引"},{"categories":[],"content":"一、背景介绍\u0026方案制定公司的支付系统主要走微信支付，其他还有支付宝、无感支付、余额支付、线下现金支付。要开展自动化测试所以需要从接口层面打通支付流程。 1、先从简单的微信扫车位码缴费接口开始整活，其本质是扫码后跳转微信公众号缴费。使用fiddler抓包获取其整个接口调用链。 2、根据接口调用链review研发代码，抓取服务器关键日志，理清订单支付逻辑，分析和微信支付的交互点主要在于下面三部分。 1）调用微信统一下单接口在微信支付服务后台生成预支付交易单。 2）支付完成后微信把相关支付结果及用户信息通过回调接口发送给我们。 3）调用微信查询订单接口查询订单状态。 3、需要mock一个服务器模拟微信支付服务后台，提供统一下单、查询订单接口，以及调用回调接口通知缴费成功。 ","date":"2021-08-28","objectID":"/blog/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98mock/:1:0","series":[],"tags":["支付"],"title":"微信支付mock","uri":"/blog/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98mock/#一背景介绍方案制定"},{"categories":[],"content":"二、整活细节virtualXposed 安装微信抓包使用fiddler抓包。测试环境公众号H5页面使用的http协议可以直接抓，但是后面要抓小程序的包，安卓7微信7以上版本由于证书信任问题小程序无法直接抓包，所以用virtualXposed把微信装到虚拟机里再抓包。 直接调用服务器接口，忽略网关由于vpn的原因云服务器的端口都是通的，可以直接访问，所以调用接口的时候可以直接调用服务接口，省掉加密验证关卡，脚本写起来方便简洁很多。 方案一、通过jumpssh、SSH Command抓取服务器日志组装参数调用回调接口前端调用下单接口后，后台服务器会根据该笔订单入场时间、车场计费规则、车牌欠费记录、用户信息等数据组装参数调用微信统一下单接口，这部分信息分散在各处但是会在日志中打印出来，通过直接抓服务器日志正则表达式取参数值的方式组装接口调用参数。 python用的jumpssh开发抓取服务器日志代码。运维给的jumpserver堡垒机账号，先登陆堡垒机账号再跳转到服务器上，尝试了很久发现无法实现跳转到服务器上执行命令，估计是堡垒机上权限不够，所以悄悄自己建了个账号，只给了日志目录查看权限。 jmeter版用 SSH Command 实现。 方案二、mock 微信支付服务后台服务提供接口mock微信支付服务后台接口，异步调用回调接口。 方案二、通过脚本在jenkins拉取代码后修改代码再编译 通过脚本修改微信支付域名、注释签名验证。 ","date":"2021-08-28","objectID":"/blog/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98mock/:2:0","series":[],"tags":["支付"],"title":"微信支付mock","uri":"/blog/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98mock/#二整活细节"},{"categories":[],"content":"二、整活细节virtualXposed 安装微信抓包使用fiddler抓包。测试环境公众号H5页面使用的http协议可以直接抓，但是后面要抓小程序的包，安卓7微信7以上版本由于证书信任问题小程序无法直接抓包，所以用virtualXposed把微信装到虚拟机里再抓包。 直接调用服务器接口，忽略网关由于vpn的原因云服务器的端口都是通的，可以直接访问，所以调用接口的时候可以直接调用服务接口，省掉加密验证关卡，脚本写起来方便简洁很多。 方案一、通过jumpssh、SSH Command抓取服务器日志组装参数调用回调接口前端调用下单接口后，后台服务器会根据该笔订单入场时间、车场计费规则、车牌欠费记录、用户信息等数据组装参数调用微信统一下单接口，这部分信息分散在各处但是会在日志中打印出来，通过直接抓服务器日志正则表达式取参数值的方式组装接口调用参数。 python用的jumpssh开发抓取服务器日志代码。运维给的jumpserver堡垒机账号，先登陆堡垒机账号再跳转到服务器上，尝试了很久发现无法实现跳转到服务器上执行命令，估计是堡垒机上权限不够，所以悄悄自己建了个账号，只给了日志目录查看权限。 jmeter版用 SSH Command 实现。 方案二、mock 微信支付服务后台服务提供接口mock微信支付服务后台接口，异步调用回调接口。 方案二、通过脚本在jenkins拉取代码后修改代码再编译 通过脚本修改微信支付域名、注释签名验证。 ","date":"2021-08-28","objectID":"/blog/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98mock/:2:0","series":[],"tags":["支付"],"title":"微信支付mock","uri":"/blog/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98mock/#virtualxposed-安装微信抓包"},{"categories":[],"content":"二、整活细节virtualXposed 安装微信抓包使用fiddler抓包。测试环境公众号H5页面使用的http协议可以直接抓，但是后面要抓小程序的包，安卓7微信7以上版本由于证书信任问题小程序无法直接抓包，所以用virtualXposed把微信装到虚拟机里再抓包。 直接调用服务器接口，忽略网关由于vpn的原因云服务器的端口都是通的，可以直接访问，所以调用接口的时候可以直接调用服务接口，省掉加密验证关卡，脚本写起来方便简洁很多。 方案一、通过jumpssh、SSH Command抓取服务器日志组装参数调用回调接口前端调用下单接口后，后台服务器会根据该笔订单入场时间、车场计费规则、车牌欠费记录、用户信息等数据组装参数调用微信统一下单接口，这部分信息分散在各处但是会在日志中打印出来，通过直接抓服务器日志正则表达式取参数值的方式组装接口调用参数。 python用的jumpssh开发抓取服务器日志代码。运维给的jumpserver堡垒机账号，先登陆堡垒机账号再跳转到服务器上，尝试了很久发现无法实现跳转到服务器上执行命令，估计是堡垒机上权限不够，所以悄悄自己建了个账号，只给了日志目录查看权限。 jmeter版用 SSH Command 实现。 方案二、mock 微信支付服务后台服务提供接口mock微信支付服务后台接口，异步调用回调接口。 方案二、通过脚本在jenkins拉取代码后修改代码再编译 通过脚本修改微信支付域名、注释签名验证。 ","date":"2021-08-28","objectID":"/blog/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98mock/:2:0","series":[],"tags":["支付"],"title":"微信支付mock","uri":"/blog/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98mock/#直接调用服务器接口忽略网关"},{"categories":[],"content":"二、整活细节virtualXposed 安装微信抓包使用fiddler抓包。测试环境公众号H5页面使用的http协议可以直接抓，但是后面要抓小程序的包，安卓7微信7以上版本由于证书信任问题小程序无法直接抓包，所以用virtualXposed把微信装到虚拟机里再抓包。 直接调用服务器接口，忽略网关由于vpn的原因云服务器的端口都是通的，可以直接访问，所以调用接口的时候可以直接调用服务接口，省掉加密验证关卡，脚本写起来方便简洁很多。 方案一、通过jumpssh、SSH Command抓取服务器日志组装参数调用回调接口前端调用下单接口后，后台服务器会根据该笔订单入场时间、车场计费规则、车牌欠费记录、用户信息等数据组装参数调用微信统一下单接口，这部分信息分散在各处但是会在日志中打印出来，通过直接抓服务器日志正则表达式取参数值的方式组装接口调用参数。 python用的jumpssh开发抓取服务器日志代码。运维给的jumpserver堡垒机账号，先登陆堡垒机账号再跳转到服务器上，尝试了很久发现无法实现跳转到服务器上执行命令，估计是堡垒机上权限不够，所以悄悄自己建了个账号，只给了日志目录查看权限。 jmeter版用 SSH Command 实现。 方案二、mock 微信支付服务后台服务提供接口mock微信支付服务后台接口，异步调用回调接口。 方案二、通过脚本在jenkins拉取代码后修改代码再编译 通过脚本修改微信支付域名、注释签名验证。 ","date":"2021-08-28","objectID":"/blog/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98mock/:2:0","series":[],"tags":["支付"],"title":"微信支付mock","uri":"/blog/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98mock/#方案一通过jumpsshssh-command抓取服务器日志组装参数调用回调接口"},{"categories":[],"content":"二、整活细节virtualXposed 安装微信抓包使用fiddler抓包。测试环境公众号H5页面使用的http协议可以直接抓，但是后面要抓小程序的包，安卓7微信7以上版本由于证书信任问题小程序无法直接抓包，所以用virtualXposed把微信装到虚拟机里再抓包。 直接调用服务器接口，忽略网关由于vpn的原因云服务器的端口都是通的，可以直接访问，所以调用接口的时候可以直接调用服务接口，省掉加密验证关卡，脚本写起来方便简洁很多。 方案一、通过jumpssh、SSH Command抓取服务器日志组装参数调用回调接口前端调用下单接口后，后台服务器会根据该笔订单入场时间、车场计费规则、车牌欠费记录、用户信息等数据组装参数调用微信统一下单接口，这部分信息分散在各处但是会在日志中打印出来，通过直接抓服务器日志正则表达式取参数值的方式组装接口调用参数。 python用的jumpssh开发抓取服务器日志代码。运维给的jumpserver堡垒机账号，先登陆堡垒机账号再跳转到服务器上，尝试了很久发现无法实现跳转到服务器上执行命令，估计是堡垒机上权限不够，所以悄悄自己建了个账号，只给了日志目录查看权限。 jmeter版用 SSH Command 实现。 方案二、mock 微信支付服务后台服务提供接口mock微信支付服务后台接口，异步调用回调接口。 方案二、通过脚本在jenkins拉取代码后修改代码再编译 通过脚本修改微信支付域名、注释签名验证。 ","date":"2021-08-28","objectID":"/blog/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98mock/:2:0","series":[],"tags":["支付"],"title":"微信支付mock","uri":"/blog/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98mock/#方案二mock-微信支付服务后台服务提供接口"},{"categories":["大数据"],"content":"启动hbase shell，list查看表名 scan ","date":"2021-08-21","objectID":"/blog/hbaseShell/:0:0","series":[],"tags":["hbase"],"title":"hbase_shell","uri":"/blog/hbaseShell/#"},{"categories":[],"content":"https://github.com/wxzForest/new-pac/blob/master/%E8%87%AA%E5%BB%BAssr%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B.md ","date":"2021-06-27","objectID":"/blog/%E6%90%AD%E5%BB%BAssr/:0:0","series":[],"tags":["ssr"],"title":"搭建ssr","uri":"/blog/%E6%90%AD%E5%BB%BAssr/#"},{"categories":["python"],"content":"先了解两个概念：深度优先、广度优先。 深度优先 or 广度优先深度优先和广度优先是两种不同的算法策略，两者有什么区别呢？ 如图，B 继承 A， C 继承 A， D 继承 B 和 C。 深度优先遍历是从 D 开始往上搜索到 B，若 B 没有数据，则继续往上搜索到 A； 广度优先遍历是从 D 开始往上搜索到 B，若 B 没有数据，则搜索和 B 同级的 C 里的数据，若同级的 C 里还是没有数据，再继续往上搜索到 A 。 Tips：py2 经典类是按深度优先来继承的，新式类是按广度优先来继承的。 py3 经典类和新式类都是统一按广度优先来继承的。 Python3 里的多继承顺序先定义几个类，B 继承 A， C 继承 A， D 继承 B 和 C class A(): def __init__(self): print(\"A\") class B(A): def __init__(self): print(\"B\") class C(A): def __init__(self): print(\"C\") class D(B,C): def __init__(self): print(\"D\") 当 D 里面没有参数时，到父类里找。我们知道，D 的父类是 B 和 C，且定义的顺序是 B在左，C在右。验证以下代码后，可以看到，继承顺序是从左到右的 class A(): def __init__(self): print(\"A\") class B(A): def __init__(self): print(\"B\") class C(A): def __init__(self): print(\"C\") class D(B,C): pass # def __init__(self): # print(\"D\") D() # D里面没有，则找父类（从左往右），找到B # B 当 B 里面也没有参数时，D 就找父类 C class A(): def __init__(self): print(\"A\") class B(A): pass # def __init__(self): # print(\"B\") class C(A): def __init__(self): print(\"C\") class D(B,C): pass # def __init__(self): # print(\"D\") D() # C 那么，当 B 和 C里都没有参数时，D该找谁呢？——答案是： A class A(): def __init__(self): print(\"A\") class B(A): pass # def __init__(self): # print(\"B\") class C(A): pass # def __init__(self): # print(\"C\") class D(B,C): pass # def __init__(self): # print(\"D\") D() # A ","date":"2021-05-07","objectID":"/blog/Python%E5%A4%9A%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%E5%8F%8A%E9%A1%BA%E5%BA%8F/:0:0","series":[],"tags":[],"title":"Python多继承方式及顺序","uri":"/blog/Python%E5%A4%9A%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%E5%8F%8A%E9%A1%BA%E5%BA%8F/#"},{"categories":["python"],"content":"先了解两个概念：深度优先、广度优先。 深度优先 or 广度优先深度优先和广度优先是两种不同的算法策略，两者有什么区别呢？ 如图，B 继承 A， C 继承 A， D 继承 B 和 C。 深度优先遍历是从 D 开始往上搜索到 B，若 B 没有数据，则继续往上搜索到 A； 广度优先遍历是从 D 开始往上搜索到 B，若 B 没有数据，则搜索和 B 同级的 C 里的数据，若同级的 C 里还是没有数据，再继续往上搜索到 A 。 Tips：py2 经典类是按深度优先来继承的，新式类是按广度优先来继承的。 py3 经典类和新式类都是统一按广度优先来继承的。 Python3 里的多继承顺序先定义几个类，B 继承 A， C 继承 A， D 继承 B 和 C class A(): def __init__(self): print(\"A\") class B(A): def __init__(self): print(\"B\") class C(A): def __init__(self): print(\"C\") class D(B,C): def __init__(self): print(\"D\") 当 D 里面没有参数时，到父类里找。我们知道，D 的父类是 B 和 C，且定义的顺序是 B在左，C在右。验证以下代码后，可以看到，继承顺序是从左到右的 class A(): def __init__(self): print(\"A\") class B(A): def __init__(self): print(\"B\") class C(A): def __init__(self): print(\"C\") class D(B,C): pass # def __init__(self): # print(\"D\") D() # D里面没有，则找父类（从左往右），找到B # B 当 B 里面也没有参数时，D 就找父类 C class A(): def __init__(self): print(\"A\") class B(A): pass # def __init__(self): # print(\"B\") class C(A): def __init__(self): print(\"C\") class D(B,C): pass # def __init__(self): # print(\"D\") D() # C 那么，当 B 和 C里都没有参数时，D该找谁呢？——答案是： A class A(): def __init__(self): print(\"A\") class B(A): pass # def __init__(self): # print(\"B\") class C(A): pass # def __init__(self): # print(\"C\") class D(B,C): pass # def __init__(self): # print(\"D\") D() # A ","date":"2021-05-07","objectID":"/blog/Python%E5%A4%9A%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%E5%8F%8A%E9%A1%BA%E5%BA%8F/:0:0","series":[],"tags":[],"title":"Python多继承方式及顺序","uri":"/blog/Python%E5%A4%9A%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%E5%8F%8A%E9%A1%BA%E5%BA%8F/#深度优先-or-广度优先"},{"categories":["python"],"content":"先了解两个概念：深度优先、广度优先。 深度优先 or 广度优先深度优先和广度优先是两种不同的算法策略，两者有什么区别呢？ 如图，B 继承 A， C 继承 A， D 继承 B 和 C。 深度优先遍历是从 D 开始往上搜索到 B，若 B 没有数据，则继续往上搜索到 A； 广度优先遍历是从 D 开始往上搜索到 B，若 B 没有数据，则搜索和 B 同级的 C 里的数据，若同级的 C 里还是没有数据，再继续往上搜索到 A 。 Tips：py2 经典类是按深度优先来继承的，新式类是按广度优先来继承的。 py3 经典类和新式类都是统一按广度优先来继承的。 Python3 里的多继承顺序先定义几个类，B 继承 A， C 继承 A， D 继承 B 和 C class A(): def __init__(self): print(\"A\") class B(A): def __init__(self): print(\"B\") class C(A): def __init__(self): print(\"C\") class D(B,C): def __init__(self): print(\"D\") 当 D 里面没有参数时，到父类里找。我们知道，D 的父类是 B 和 C，且定义的顺序是 B在左，C在右。验证以下代码后，可以看到，继承顺序是从左到右的 class A(): def __init__(self): print(\"A\") class B(A): def __init__(self): print(\"B\") class C(A): def __init__(self): print(\"C\") class D(B,C): pass # def __init__(self): # print(\"D\") D() # D里面没有，则找父类（从左往右），找到B # B 当 B 里面也没有参数时，D 就找父类 C class A(): def __init__(self): print(\"A\") class B(A): pass # def __init__(self): # print(\"B\") class C(A): def __init__(self): print(\"C\") class D(B,C): pass # def __init__(self): # print(\"D\") D() # C 那么，当 B 和 C里都没有参数时，D该找谁呢？——答案是： A class A(): def __init__(self): print(\"A\") class B(A): pass # def __init__(self): # print(\"B\") class C(A): pass # def __init__(self): # print(\"C\") class D(B,C): pass # def __init__(self): # print(\"D\") D() # A ","date":"2021-05-07","objectID":"/blog/Python%E5%A4%9A%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%E5%8F%8A%E9%A1%BA%E5%BA%8F/:0:0","series":[],"tags":[],"title":"Python多继承方式及顺序","uri":"/blog/Python%E5%A4%9A%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%E5%8F%8A%E9%A1%BA%E5%BA%8F/#python3-里的多继承顺序"},{"categories":["performance"],"content":"一、背景介绍","date":"2021-04-08","objectID":"/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%85%A8%E9%93%BE%E8%B7%AF%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:1:0","series":[],"tags":["jmeter","websocket"],"title":"记一次全链路性能测试","uri":"/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%85%A8%E9%93%BE%E8%B7%AF%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/#一背景介绍"},{"categories":["performance"],"content":"二、准备工作","date":"2021-04-08","objectID":"/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%85%A8%E9%93%BE%E8%B7%AF%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:2:0","series":[],"tags":["jmeter","websocket"],"title":"记一次全链路性能测试","uri":"/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%85%A8%E9%93%BE%E8%B7%AF%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/#二准备工作"},{"categories":["performance"],"content":"三、用Jmeter开始整活","date":"2021-04-08","objectID":"/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%85%A8%E9%93%BE%E8%B7%AF%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:3:0","series":[],"tags":["jmeter","websocket"],"title":"记一次全链路性能测试","uri":"/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%85%A8%E9%93%BE%E8%B7%AF%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/#三用jmeter开始整活"},{"categories":["performance"],"content":"3.1 数据准备数据准备部分1、调用创建运营主体接口，对运营主体名称打标“test压力测试${__time(yyyyMMdd,)}”，方便后期维护数据，考虑到一般压测时间不会跨天，用yyyyMMdd区隔压测数据，可扩展成yyyyMM区隔。 2、需要获取运营主体id，接口未返回，调用JDBC Request，查询出id并保存到vars中。 3、调用创建车场接口，对车场名打标“test压力测试${code}”。需要获取车场id，接口未返回，调用JDBC Request查询出id并保存到vars中。 4、调用创建场内区域接口，同样对区域名称打标“压力测试${code}”。需要获取区域id，接口未返回，调用JDBC Request查询出id并保存到vars中。 5、调用创建车位接口，一个车场创建30个车位。 查询数据库数据1个车场车位数一般在32个左右 6、调用创建收费规则接口，有“遂宁资费”、“沙坪坝资费”两种类型资费比较典型，可分别压测。同样的资费名打标“test性能测试”。需要资费id，接口返回了，用正则表达式提取器提取。 7、将车场和收费规则关联，收费员和车场关联，涉及大量字符串处理，先手动在平台上操作。 ","date":"2021-04-08","objectID":"/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%85%A8%E9%93%BE%E8%B7%AF%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:3:1","series":[],"tags":["jmeter","websocket"],"title":"记一次全链路性能测试","uri":"/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%85%A8%E9%93%BE%E8%B7%AF%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/#31-数据准备"},{"categories":["performance"],"content":"3.2、地磁部分（高位视频、低位视频流程类似）3.2.1、数据准备1、调用地磁注册接口，对设备编号打标，保持和车位号一致“${code}”。需要获取地磁id，接口未返回，调用JDBC Request查询出id并保存到vars中。 2、需要车位id，调用JDBC Request根据车位号“${code}”查询出车位id并保存到vars中。 3、调用地磁绑定接口，将地磁设备和车位号绑定。 3.2.2、场景构建1、地磁入场后立刻离场——未产生资费：调用地磁入场接口后等待5秒，调用地磁离场接口。 2、地磁入场后欠费离场：调用地磁入场接口后等待1分10秒，产生资费，调用地磁离场接口（自费规则设置的免停时长1分钟）。 3、地磁入场后现金缴费离场：调用地磁入场接口后等待1分10秒，产生资费，调用现金支付接口，调用地磁离场接口。 4、地磁入场后微信线上缴费离场：调用地磁入场接口后等待1分10秒，产生资费，调用微信支付回调接口，调用地磁离场接口。 5、以上几种场景根据实际业务情况使用循环控制器按比例配置请求次数。 ","date":"2021-04-08","objectID":"/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%85%A8%E9%93%BE%E8%B7%AF%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:3:2","series":[],"tags":["jmeter","websocket"],"title":"记一次全链路性能测试","uri":"/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%85%A8%E9%93%BE%E8%B7%AF%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/#32地磁部分高位视频低位视频流程类似"},{"categories":["performance"],"content":"3.2、地磁部分（高位视频、低位视频流程类似）3.2.1、数据准备1、调用地磁注册接口，对设备编号打标，保持和车位号一致“${code}”。需要获取地磁id，接口未返回，调用JDBC Request查询出id并保存到vars中。 2、需要车位id，调用JDBC Request根据车位号“${code}”查询出车位id并保存到vars中。 3、调用地磁绑定接口，将地磁设备和车位号绑定。 3.2.2、场景构建1、地磁入场后立刻离场——未产生资费：调用地磁入场接口后等待5秒，调用地磁离场接口。 2、地磁入场后欠费离场：调用地磁入场接口后等待1分10秒，产生资费，调用地磁离场接口（自费规则设置的免停时长1分钟）。 3、地磁入场后现金缴费离场：调用地磁入场接口后等待1分10秒，产生资费，调用现金支付接口，调用地磁离场接口。 4、地磁入场后微信线上缴费离场：调用地磁入场接口后等待1分10秒，产生资费，调用微信支付回调接口，调用地磁离场接口。 5、以上几种场景根据实际业务情况使用循环控制器按比例配置请求次数。 ","date":"2021-04-08","objectID":"/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%85%A8%E9%93%BE%E8%B7%AF%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:3:2","series":[],"tags":["jmeter","websocket"],"title":"记一次全链路性能测试","uri":"/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%85%A8%E9%93%BE%E8%B7%AF%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/#321数据准备"},{"categories":["performance"],"content":"3.2、地磁部分（高位视频、低位视频流程类似）3.2.1、数据准备1、调用地磁注册接口，对设备编号打标，保持和车位号一致“${code}”。需要获取地磁id，接口未返回，调用JDBC Request查询出id并保存到vars中。 2、需要车位id，调用JDBC Request根据车位号“${code}”查询出车位id并保存到vars中。 3、调用地磁绑定接口，将地磁设备和车位号绑定。 3.2.2、场景构建1、地磁入场后立刻离场——未产生资费：调用地磁入场接口后等待5秒，调用地磁离场接口。 2、地磁入场后欠费离场：调用地磁入场接口后等待1分10秒，产生资费，调用地磁离场接口（自费规则设置的免停时长1分钟）。 3、地磁入场后现金缴费离场：调用地磁入场接口后等待1分10秒，产生资费，调用现金支付接口，调用地磁离场接口。 4、地磁入场后微信线上缴费离场：调用地磁入场接口后等待1分10秒，产生资费，调用微信支付回调接口，调用地磁离场接口。 5、以上几种场景根据实际业务情况使用循环控制器按比例配置请求次数。 ","date":"2021-04-08","objectID":"/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%85%A8%E9%93%BE%E8%B7%AF%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:3:2","series":[],"tags":["jmeter","websocket"],"title":"记一次全链路性能测试","uri":"/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%85%A8%E9%93%BE%E8%B7%AF%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/#322场景构建"},{"categories":["performance"],"content":"3.3、POS机部分3.3.1、进出场缴费场景构建1、POS入场后欠费离场 2、POS入场后异常离场 3、POS入场后现金缴费离场 4、POS入场后微信扫码支付缴费离场 3.3.2、欠费补缴、预付费场景构建1、POS入场后欠费离场，扫小票二维码补缴欠费。 2、POS入场后欠费离场，H5页面输入车牌补缴欠费。 3、POS入场后欠费离场，通过小程序补缴欠费。 4、POS入场后现金缴纳预付费，费用未消耗完退费离场。 5、POS入场后线上缴纳预付费，费用未消耗完自动退费离场。 6、POS入场后线上缴纳预付费，费用消耗完产生新的资费缴费离场。 ","date":"2021-04-08","objectID":"/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%85%A8%E9%93%BE%E8%B7%AF%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:3:3","series":[],"tags":["jmeter","websocket"],"title":"记一次全链路性能测试","uri":"/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%85%A8%E9%93%BE%E8%B7%AF%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/#33pos机部分"},{"categories":["performance"],"content":"3.3、POS机部分3.3.1、进出场缴费场景构建1、POS入场后欠费离场 2、POS入场后异常离场 3、POS入场后现金缴费离场 4、POS入场后微信扫码支付缴费离场 3.3.2、欠费补缴、预付费场景构建1、POS入场后欠费离场，扫小票二维码补缴欠费。 2、POS入场后欠费离场，H5页面输入车牌补缴欠费。 3、POS入场后欠费离场，通过小程序补缴欠费。 4、POS入场后现金缴纳预付费，费用未消耗完退费离场。 5、POS入场后线上缴纳预付费，费用未消耗完自动退费离场。 6、POS入场后线上缴纳预付费，费用消耗完产生新的资费缴费离场。 ","date":"2021-04-08","objectID":"/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%85%A8%E9%93%BE%E8%B7%AF%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:3:3","series":[],"tags":["jmeter","websocket"],"title":"记一次全链路性能测试","uri":"/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%85%A8%E9%93%BE%E8%B7%AF%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/#331进出场缴费场景构建"},{"categories":["performance"],"content":"3.3、POS机部分3.3.1、进出场缴费场景构建1、POS入场后欠费离场 2、POS入场后异常离场 3、POS入场后现金缴费离场 4、POS入场后微信扫码支付缴费离场 3.3.2、欠费补缴、预付费场景构建1、POS入场后欠费离场，扫小票二维码补缴欠费。 2、POS入场后欠费离场，H5页面输入车牌补缴欠费。 3、POS入场后欠费离场，通过小程序补缴欠费。 4、POS入场后现金缴纳预付费，费用未消耗完退费离场。 5、POS入场后线上缴纳预付费，费用未消耗完自动退费离场。 6、POS入场后线上缴纳预付费，费用消耗完产生新的资费缴费离场。 ","date":"2021-04-08","objectID":"/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%85%A8%E9%93%BE%E8%B7%AF%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:3:3","series":[],"tags":["jmeter","websocket"],"title":"记一次全链路性能测试","uri":"/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%85%A8%E9%93%BE%E8%B7%AF%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/#332欠费补缴预付费场景构建"},{"categories":["performance"],"content":"3.4、云MS摄像头进出场压测该摄像头通过websocket协议与服务器连接。 摄像头注册 入场 初始化循环控制器、循环判断控制器 循环接受返回结果 接收到开闸命令返回开闸 ","date":"2021-04-08","objectID":"/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%85%A8%E9%93%BE%E8%B7%AF%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:3:4","series":[],"tags":["jmeter","websocket"],"title":"记一次全链路性能测试","uri":"/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%85%A8%E9%93%BE%E8%B7%AF%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/#34云ms摄像头进出场压测"},{"categories":["performance"],"content":"监控","date":"2021-04-08","objectID":"/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%85%A8%E9%93%BE%E8%B7%AF%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:4:0","series":[],"tags":["jmeter","websocket"],"title":"记一次全链路性能测试","uri":"/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%85%A8%E9%93%BE%E8%B7%AF%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/#监控"},{"categories":["performance"],"content":"调优","date":"2021-04-08","objectID":"/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%85%A8%E9%93%BE%E8%B7%AF%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:5:0","series":[],"tags":["jmeter","websocket"],"title":"记一次全链路性能测试","uri":"/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%85%A8%E9%93%BE%E8%B7%AF%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/#调优"},{"categories":["performance"],"content":"出于对Linux操作系统的兴趣，以及对底层知识的强烈欲望，因此整理了这篇文章。本文也可以作为检验基础知识的指标，另外文章涵盖了一个系统的方方面面。如果没有完善的计算机系统知识，网络知识和操作系统知识，文档中的工具，是不可能完全掌握的，另外对系统性能分析和优化是一个长期的系列。 本文档主要是结合Linux 大牛，Netflix 高级性能架构师 Brendan Gregg 更新 Linux 性能调优工具的博文，搜集Linux系统性能优化相关文章整理后的一篇综合性文章，主要是结合博文对涉及到的原理和性能测试的工具展开说明。 ","date":"2021-03-29","objectID":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/:0:0","series":[],"tags":[],"title":"[转]Linux性能分析工具汇总合集","uri":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/#"},{"categories":["performance"],"content":"性能分析工具首先来看一张图： 上图是Brendan Gregg 的一次性能分析的分享，这里面的所有工具都可以通过man来获得它的帮助文档，下问简单介绍介绍一下常规的用法： ","date":"2021-03-29","objectID":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/:1:0","series":[],"tags":[],"title":"[转]Linux性能分析工具汇总合集","uri":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/#性能分析工具"},{"categories":["performance"],"content":"vmstat–虚拟内存统计vmstat(VirtualMeomoryStatistics,虚拟内存统计) 是Linux中监控内存的常用工具,可对操作系统的虚拟内存、进程、CPU等的整体情况进行监视。 vmstat的常规用法：vmstat interval times即每隔interval秒采样一次，共采样times次，如果省略times,则一直采集数据，直到用户手动停止为止。简单举个例子： 可以使用ctrl+c停止vmstat采集数据。 第一行显示了系统自启动以来的平均值，第二行开始显示现在正在发生的情况，接下来的行会显示每5秒间隔发生了什么，每一列的含义在头部，如下所示： procs：r这一列显示了多少进程在等待cpu，b列显示多少进程正在不可中断的休眠（等待IO）。 memory：swapd列显示了多少块被换出了磁盘（页面交换），剩下的列显示了多少块是空闲的（未被使用），多少块正在被用作缓冲区，以及多少正在被用作操作系统的缓存。 swap：显示交换活动：每秒有多少块正在被换入（从磁盘）和换出（到磁盘）。 io：显示了多少块从块设备读取（bi）和写出（bo）,通常反映了硬盘I/O。 system：显示每秒中断(in)和上下文切换（cs）的数量。 cpu：显示所有的cpu时间花费在各类操作的百分比，包括执行用户代码（非内核），执行系统代码（内核），空闲以及等待IO。 内存不足的表现：free memory急剧减少，回收buffer和cacher也无济于事，大量使用交换分区（swpd）,页面交换（swap）频繁，读写磁盘数量（io）增多，缺页中断（in）增多，上下文切换（cs）次数增多，等待IO的进程数（b）增多，大量CPU时间用于等待IO（wa） ","date":"2021-03-29","objectID":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/:2:0","series":[],"tags":[],"title":"[转]Linux性能分析工具汇总合集","uri":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/#vmstat--虚拟内存统计"},{"categories":["performance"],"content":"iostat–用于报告中央处理器统计信息iostat用于报告中央处理器（CPU）统计信息和整个系统、适配器、tty 设备、磁盘和 CD-ROM 的输入/输出统计信息，默认显示了与vmstat相同的cpu使用信息，使用以下命令显示扩展的设备统计： 第一行显示的是自系统启动以来的平均值，然后显示增量的平均值，每个设备一行。 常见linux的磁盘IO指标的缩写习惯：rq是request,r是read,w是write,qu是queue，sz是size,a是verage,tm是time,svc是service。 rrqm/s和wrqm/s：每秒合并的读和写请求，“合并的”意味着操作系统从队列中拿出多个逻辑请求合并为一个请求到实际磁盘。 r/s和w/s：每秒发送到设备的读和写请求数。 rsec/s和wsec/s：每秒读和写的扇区数。 avgrq –sz：请求的扇区数。 avgqu –sz：在设备队列中等待的请求数。 await：每个IO请求花费的时间。 svctm：实际请求（服务）时间。 %util：至少有一个活跃请求所占时间的百分比。 ","date":"2021-03-29","objectID":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/:3:0","series":[],"tags":[],"title":"[转]Linux性能分析工具汇总合集","uri":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/#iostat--用于报告中央处理器统计信息"},{"categories":["performance"],"content":"dstat–系统监控工具dstat显示了cpu使用情况，磁盘io情况，网络发包情况和换页情况，输出是彩色的，可读性较强，相对于vmstat和iostat的输入更加详细且较为直观。在使用时，直接输入命令即可，当然也可以使用特定参数。 如下：dstat –cdlmnpsy ","date":"2021-03-29","objectID":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/:4:0","series":[],"tags":[],"title":"[转]Linux性能分析工具汇总合集","uri":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/#dstat--系统监控工具"},{"categories":["performance"],"content":"iotop–LINUX进程实时监控工具iotop命令是专门显示硬盘IO的命令，界面风格类似top命令，可以显示IO负载具体是由哪个进程产生的。是一个用来监视磁盘I/O使用状况的top类工具，具有与top相似的UI，其中包括PID、用户、I/O、进程等相关信息。 可以以非交互的方式使用： iotop –bod interval，查看每个进程的I/O，可以使用pidstat，pidstat –d instat ","date":"2021-03-29","objectID":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/:5:0","series":[],"tags":[],"title":"[转]Linux性能分析工具汇总合集","uri":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/#iotop--linux进程实时监控工具"},{"categories":["performance"],"content":"pidstat–监控系统资源情况pidstat主要用于监控全部或指定进程占用系统资源的情况,如CPU,内存、设备IO、任务切换、线程等。 使用方法： pidstat –d interval #统计CPU使用信息 pidstat –u interval #统计内存信息 Pidstat –r interval ","date":"2021-03-29","objectID":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/:6:0","series":[],"tags":[],"title":"[转]Linux性能分析工具汇总合集","uri":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/#pidstat--监控系统资源情况"},{"categories":["performance"],"content":"toptop命令的汇总区域显示了五个方面的系统性能信息： 负载：时间，登陆用户数，系统平均负载； 进程：运行，睡眠，停止，僵尸； cpu:用户态，核心态，NICE,空闲，等待IO,中断等； 内存：总量，已用，空闲（系统角度），缓冲，缓存； 交换分区：总量，已用，空闲 任务区域默认显示：进程ID,有效用户，进程优先级，NICE值，进程使用的虚拟内存，物理内存和共享内存，进程状态，CPU占用率，内存占用率，累计CPU时间，进程命令行信息。 ","date":"2021-03-29","objectID":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/:7:0","series":[],"tags":[],"title":"[转]Linux性能分析工具汇总合集","uri":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/#top"},{"categories":["performance"],"content":"htophtop 是Linux系统中的一个互动的进程查看器,一个文本模式的应用程序(在控制台或者X终端中),需要ncurses。 Htop可让用户交互式操作，支持颜色主题，可横向或纵向滚动浏览进程列表，并支持鼠标操作。 与top相比，htop有以下优点： 可以横向或者纵向滚动浏览进程列表，以便看到所有的进程和完整的命令行。 在启动上，比top更快。 杀进程时不需要输入进程号。 htop支持鼠标操作。 ","date":"2021-03-29","objectID":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/:8:0","series":[],"tags":[],"title":"[转]Linux性能分析工具汇总合集","uri":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/#htop"},{"categories":["performance"],"content":"mpstatmpstat 是Multiprocessor Statistics的缩写，是实时系统监控工具。其报告与CPU的一些统计信息，这些信息存放在/proc/stat文件中。在多CPUs系统里，其不但能查看所有CPU的平均状况信息，而且能够查看特定CPU的信息。常见用法： mpstat –P ALL interval times ","date":"2021-03-29","objectID":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/:9:0","series":[],"tags":[],"title":"[转]Linux性能分析工具汇总合集","uri":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/#mpstat"},{"categories":["performance"],"content":"netstatNetstat用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。 常见用法： netstat –npl #可以查看你要打开的端口是否已经打开。 netstat –rn #打印路由表信息。 netstat –in #提供系统上的接口信息，打印每个接口的MTU,输入分组数，输入错误，输出分组数，输出错误，冲突以及当前的输出队列的长度。 ","date":"2021-03-29","objectID":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/:10:0","series":[],"tags":[],"title":"[转]Linux性能分析工具汇总合集","uri":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/#netstat"},{"categories":["performance"],"content":"ps–显示当前进程的状态ps参数太多，具体使用方法可以参考man ps， 常用的方法： ps aux #hsserver ps –ef |grep #hundsun #杀掉某一程序的方法 ps aux | grep mysqld | grep –v grep | awk ‘{print $2 }’ xargs kill -9 #杀掉僵尸进程 ps –eal | awk ‘{if ($2 == “Z”){print $4}}’ | xargs kill -9 ","date":"2021-03-29","objectID":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/:11:0","series":[],"tags":[],"title":"[转]Linux性能分析工具汇总合集","uri":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/#ps--显示当前进程的状态"},{"categories":["performance"],"content":"strace跟踪程序执行过程中产生的系统调用及接收到的信号，帮助分析程序或命令执行中遇到的异常情况。 举例：查看mysqld在linux上加载哪种配置文件，可以通过运行下面的命令： strace –e stat64 mysqld –print –defaults \u003e /dev/null ","date":"2021-03-29","objectID":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/:12:0","series":[],"tags":[],"title":"[转]Linux性能分析工具汇总合集","uri":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/#strace"},{"categories":["performance"],"content":"uptime能够打印系统总共运行了多长时间和系统的平均负载，uptime命令最后输出的三个数字的含义分别是1分钟，5分钟，15分钟内系统的平均负荷。 ","date":"2021-03-29","objectID":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/:13:0","series":[],"tags":[],"title":"[转]Linux性能分析工具汇总合集","uri":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/#uptime"},{"categories":["performance"],"content":"lsoflsof(list open files)是一个列出当前系统打开文件的工具。通过lsof工具能够查看这个列表对系统检测及排错，常见的用法： #查看文件系统阻塞 lsof /boot #查看端口号被哪个进程占用 lsof -i : 3306 #查看用户打开哪些文件 lsof –u username #查看进程打开哪些文件 lsof –p 4838 #查看远程已打开的网络链接 lsof –i @192.168.34.128 ","date":"2021-03-29","objectID":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/:14:0","series":[],"tags":[],"title":"[转]Linux性能分析工具汇总合集","uri":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/#lsof"},{"categories":["performance"],"content":"perfperf是Linux kernel自带的系统性能优化工具。优势在于与Linux Kernel的紧密结合，它可以最先应用到加入Kernel的new feature，用于查看热点函数，查看cashe miss的比率，从而帮助开发者来优化程序性能。 性能调优工具如 perf，Oprofile 等的基本原理都是对被监测对象进行采样，最简单的情形是根据 tick 中断进行采样，即在 tick 中断内触发采样点，在采样点里判断程序当时的上下文。假如一个程序 90% 的时间都花费在函数 foo() 上，那么 90% 的采样点都应该落在函数 foo() 的上下文中。运气不可捉摸，但我想只要采样频率足够高，采样时间足够长，那么以上推论就比较可靠。因此，通过 tick 触发采样，我们便可以了解程序中哪些地方最耗时间，从而重点分析。 汇总：结合以上常用的性能测试命令并联系文初的性能分析工具的图，就可以初步了解到性能分析过程中哪个方面的性能使用哪方面的工具（命令）。 ","date":"2021-03-29","objectID":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/:15:0","series":[],"tags":[],"title":"[转]Linux性能分析工具汇总合集","uri":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/#perf"},{"categories":["performance"],"content":"常用的性能测试工具熟练并精通了第二部分的性能分析命令工具，引入几个性能测试的工具，介绍之前先简单了解几个性能测试工具： perf_events一款随 Linux 内核代码一同发布和维护的性能诊断工具，由内核社区维护和发展。Perf 不仅可以用于应用程序的性能统计分析，也可以应用于内核代码的性能统计和分析。 eBPF tools一款使用bcc进行的性能追踪的工具,eBPF map可以使用定制的eBPF程序被广泛应用于内核调优方面，也可以读取用户级的异步代码。重要的是这个外部的数据可以在用户空间管理。这个k-v格式的map数据体是通过在用户空间调用bpf系统调用创建、添加、删除等操作管理的。 perf-tools:一款基于 perf_events (perf) 和 ftrace 的Linux性能分析调优工具集。Perf-Tools 依赖库少，使用简单。支持Linux 3.2 及以上内核版本。 bcc(BPF Compiler Collection)一款使用eBPF的perf性能分析工具。一个用于创建高效的内核跟踪和操作程序的工具包，包括几个有用的工具和示例。利用扩展的BPF（伯克利数据包过滤器），正式称为eBPF，一个新的功能，首先被添加到Linux 3.15。多用途需要Linux 4.1以上BCC。 ktap一种新型的linux脚本动态性能跟踪工具。允许用户跟踪Linux内核动态。ktap是设计给具有互操作性，允许用户调整操作的见解，排除故障和延长内核和应用程序。它类似于Linux和Solaris DTrace SystemTap。 Flame Graphs是一款使用perf,system tap,ktap可视化的图形软件，允许最频繁的代码路径快速准确地识别，可以是使用github.com/brendangregg/flamegraph中的开发源代码的程序生成。 ","date":"2021-03-29","objectID":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/:16:0","series":[],"tags":[],"title":"[转]Linux性能分析工具汇总合集","uri":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/#常用的性能测试工具"},{"categories":["performance"],"content":"常用的性能测试工具熟练并精通了第二部分的性能分析命令工具，引入几个性能测试的工具，介绍之前先简单了解几个性能测试工具： perf_events一款随 Linux 内核代码一同发布和维护的性能诊断工具，由内核社区维护和发展。Perf 不仅可以用于应用程序的性能统计分析，也可以应用于内核代码的性能统计和分析。 eBPF tools一款使用bcc进行的性能追踪的工具,eBPF map可以使用定制的eBPF程序被广泛应用于内核调优方面，也可以读取用户级的异步代码。重要的是这个外部的数据可以在用户空间管理。这个k-v格式的map数据体是通过在用户空间调用bpf系统调用创建、添加、删除等操作管理的。 perf-tools:一款基于 perf_events (perf) 和 ftrace 的Linux性能分析调优工具集。Perf-Tools 依赖库少，使用简单。支持Linux 3.2 及以上内核版本。 bcc(BPF Compiler Collection)一款使用eBPF的perf性能分析工具。一个用于创建高效的内核跟踪和操作程序的工具包，包括几个有用的工具和示例。利用扩展的BPF（伯克利数据包过滤器），正式称为eBPF，一个新的功能，首先被添加到Linux 3.15。多用途需要Linux 4.1以上BCC。 ktap一种新型的linux脚本动态性能跟踪工具。允许用户跟踪Linux内核动态。ktap是设计给具有互操作性，允许用户调整操作的见解，排除故障和延长内核和应用程序。它类似于Linux和Solaris DTrace SystemTap。 Flame Graphs是一款使用perf,system tap,ktap可视化的图形软件，允许最频繁的代码路径快速准确地识别，可以是使用github.com/brendangregg/flamegraph中的开发源代码的程序生成。 ","date":"2021-03-29","objectID":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/:16:0","series":[],"tags":[],"title":"[转]Linux性能分析工具汇总合集","uri":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/#perf_events"},{"categories":["performance"],"content":"常用的性能测试工具熟练并精通了第二部分的性能分析命令工具，引入几个性能测试的工具，介绍之前先简单了解几个性能测试工具： perf_events一款随 Linux 内核代码一同发布和维护的性能诊断工具，由内核社区维护和发展。Perf 不仅可以用于应用程序的性能统计分析，也可以应用于内核代码的性能统计和分析。 eBPF tools一款使用bcc进行的性能追踪的工具,eBPF map可以使用定制的eBPF程序被广泛应用于内核调优方面，也可以读取用户级的异步代码。重要的是这个外部的数据可以在用户空间管理。这个k-v格式的map数据体是通过在用户空间调用bpf系统调用创建、添加、删除等操作管理的。 perf-tools:一款基于 perf_events (perf) 和 ftrace 的Linux性能分析调优工具集。Perf-Tools 依赖库少，使用简单。支持Linux 3.2 及以上内核版本。 bcc(BPF Compiler Collection)一款使用eBPF的perf性能分析工具。一个用于创建高效的内核跟踪和操作程序的工具包，包括几个有用的工具和示例。利用扩展的BPF（伯克利数据包过滤器），正式称为eBPF，一个新的功能，首先被添加到Linux 3.15。多用途需要Linux 4.1以上BCC。 ktap一种新型的linux脚本动态性能跟踪工具。允许用户跟踪Linux内核动态。ktap是设计给具有互操作性，允许用户调整操作的见解，排除故障和延长内核和应用程序。它类似于Linux和Solaris DTrace SystemTap。 Flame Graphs是一款使用perf,system tap,ktap可视化的图形软件，允许最频繁的代码路径快速准确地识别，可以是使用github.com/brendangregg/flamegraph中的开发源代码的程序生成。 ","date":"2021-03-29","objectID":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/:16:0","series":[],"tags":[],"title":"[转]Linux性能分析工具汇总合集","uri":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/#ebpf-tools"},{"categories":["performance"],"content":"常用的性能测试工具熟练并精通了第二部分的性能分析命令工具，引入几个性能测试的工具，介绍之前先简单了解几个性能测试工具： perf_events一款随 Linux 内核代码一同发布和维护的性能诊断工具，由内核社区维护和发展。Perf 不仅可以用于应用程序的性能统计分析，也可以应用于内核代码的性能统计和分析。 eBPF tools一款使用bcc进行的性能追踪的工具,eBPF map可以使用定制的eBPF程序被广泛应用于内核调优方面，也可以读取用户级的异步代码。重要的是这个外部的数据可以在用户空间管理。这个k-v格式的map数据体是通过在用户空间调用bpf系统调用创建、添加、删除等操作管理的。 perf-tools:一款基于 perf_events (perf) 和 ftrace 的Linux性能分析调优工具集。Perf-Tools 依赖库少，使用简单。支持Linux 3.2 及以上内核版本。 bcc(BPF Compiler Collection)一款使用eBPF的perf性能分析工具。一个用于创建高效的内核跟踪和操作程序的工具包，包括几个有用的工具和示例。利用扩展的BPF（伯克利数据包过滤器），正式称为eBPF，一个新的功能，首先被添加到Linux 3.15。多用途需要Linux 4.1以上BCC。 ktap一种新型的linux脚本动态性能跟踪工具。允许用户跟踪Linux内核动态。ktap是设计给具有互操作性，允许用户调整操作的见解，排除故障和延长内核和应用程序。它类似于Linux和Solaris DTrace SystemTap。 Flame Graphs是一款使用perf,system tap,ktap可视化的图形软件，允许最频繁的代码路径快速准确地识别，可以是使用github.com/brendangregg/flamegraph中的开发源代码的程序生成。 ","date":"2021-03-29","objectID":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/:16:0","series":[],"tags":[],"title":"[转]Linux性能分析工具汇总合集","uri":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/#perf-tools"},{"categories":["performance"],"content":"常用的性能测试工具熟练并精通了第二部分的性能分析命令工具，引入几个性能测试的工具，介绍之前先简单了解几个性能测试工具： perf_events一款随 Linux 内核代码一同发布和维护的性能诊断工具，由内核社区维护和发展。Perf 不仅可以用于应用程序的性能统计分析，也可以应用于内核代码的性能统计和分析。 eBPF tools一款使用bcc进行的性能追踪的工具,eBPF map可以使用定制的eBPF程序被广泛应用于内核调优方面，也可以读取用户级的异步代码。重要的是这个外部的数据可以在用户空间管理。这个k-v格式的map数据体是通过在用户空间调用bpf系统调用创建、添加、删除等操作管理的。 perf-tools:一款基于 perf_events (perf) 和 ftrace 的Linux性能分析调优工具集。Perf-Tools 依赖库少，使用简单。支持Linux 3.2 及以上内核版本。 bcc(BPF Compiler Collection)一款使用eBPF的perf性能分析工具。一个用于创建高效的内核跟踪和操作程序的工具包，包括几个有用的工具和示例。利用扩展的BPF（伯克利数据包过滤器），正式称为eBPF，一个新的功能，首先被添加到Linux 3.15。多用途需要Linux 4.1以上BCC。 ktap一种新型的linux脚本动态性能跟踪工具。允许用户跟踪Linux内核动态。ktap是设计给具有互操作性，允许用户调整操作的见解，排除故障和延长内核和应用程序。它类似于Linux和Solaris DTrace SystemTap。 Flame Graphs是一款使用perf,system tap,ktap可视化的图形软件，允许最频繁的代码路径快速准确地识别，可以是使用github.com/brendangregg/flamegraph中的开发源代码的程序生成。 ","date":"2021-03-29","objectID":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/:16:0","series":[],"tags":[],"title":"[转]Linux性能分析工具汇总合集","uri":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/#bccbpf-compiler-collection"},{"categories":["performance"],"content":"常用的性能测试工具熟练并精通了第二部分的性能分析命令工具，引入几个性能测试的工具，介绍之前先简单了解几个性能测试工具： perf_events一款随 Linux 内核代码一同发布和维护的性能诊断工具，由内核社区维护和发展。Perf 不仅可以用于应用程序的性能统计分析，也可以应用于内核代码的性能统计和分析。 eBPF tools一款使用bcc进行的性能追踪的工具,eBPF map可以使用定制的eBPF程序被广泛应用于内核调优方面，也可以读取用户级的异步代码。重要的是这个外部的数据可以在用户空间管理。这个k-v格式的map数据体是通过在用户空间调用bpf系统调用创建、添加、删除等操作管理的。 perf-tools:一款基于 perf_events (perf) 和 ftrace 的Linux性能分析调优工具集。Perf-Tools 依赖库少，使用简单。支持Linux 3.2 及以上内核版本。 bcc(BPF Compiler Collection)一款使用eBPF的perf性能分析工具。一个用于创建高效的内核跟踪和操作程序的工具包，包括几个有用的工具和示例。利用扩展的BPF（伯克利数据包过滤器），正式称为eBPF，一个新的功能，首先被添加到Linux 3.15。多用途需要Linux 4.1以上BCC。 ktap一种新型的linux脚本动态性能跟踪工具。允许用户跟踪Linux内核动态。ktap是设计给具有互操作性，允许用户调整操作的见解，排除故障和延长内核和应用程序。它类似于Linux和Solaris DTrace SystemTap。 Flame Graphs是一款使用perf,system tap,ktap可视化的图形软件，允许最频繁的代码路径快速准确地识别，可以是使用github.com/brendangregg/flamegraph中的开发源代码的程序生成。 ","date":"2021-03-29","objectID":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/:16:0","series":[],"tags":[],"title":"[转]Linux性能分析工具汇总合集","uri":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/#ktap"},{"categories":["performance"],"content":"常用的性能测试工具熟练并精通了第二部分的性能分析命令工具，引入几个性能测试的工具，介绍之前先简单了解几个性能测试工具： perf_events一款随 Linux 内核代码一同发布和维护的性能诊断工具，由内核社区维护和发展。Perf 不仅可以用于应用程序的性能统计分析，也可以应用于内核代码的性能统计和分析。 eBPF tools一款使用bcc进行的性能追踪的工具,eBPF map可以使用定制的eBPF程序被广泛应用于内核调优方面，也可以读取用户级的异步代码。重要的是这个外部的数据可以在用户空间管理。这个k-v格式的map数据体是通过在用户空间调用bpf系统调用创建、添加、删除等操作管理的。 perf-tools:一款基于 perf_events (perf) 和 ftrace 的Linux性能分析调优工具集。Perf-Tools 依赖库少，使用简单。支持Linux 3.2 及以上内核版本。 bcc(BPF Compiler Collection)一款使用eBPF的perf性能分析工具。一个用于创建高效的内核跟踪和操作程序的工具包，包括几个有用的工具和示例。利用扩展的BPF（伯克利数据包过滤器），正式称为eBPF，一个新的功能，首先被添加到Linux 3.15。多用途需要Linux 4.1以上BCC。 ktap一种新型的linux脚本动态性能跟踪工具。允许用户跟踪Linux内核动态。ktap是设计给具有互操作性，允许用户调整操作的见解，排除故障和延长内核和应用程序。它类似于Linux和Solaris DTrace SystemTap。 Flame Graphs是一款使用perf,system tap,ktap可视化的图形软件，允许最频繁的代码路径快速准确地识别，可以是使用github.com/brendangregg/flamegraph中的开发源代码的程序生成。 ","date":"2021-03-29","objectID":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/:16:0","series":[],"tags":[],"title":"[转]Linux性能分析工具汇总合集","uri":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/#flame-graphs"},{"categories":["performance"],"content":"Linux observability tools | Linux 性能观测工具首先学习的Basic Tool有如下：uptime、top(htop)、mpstat、isstat、vmstat、free、ping、nicstat、dstat。Linux性能检测常用的10个基本命令 高级的命令如下：sar、netstat、pidstat、strace、tcpdump、blktrace、iotop、slabtop、sysctl、/proc。值得收藏！Linux系统常用命令速查手册 ","date":"2021-03-29","objectID":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/:17:0","series":[],"tags":[],"title":"[转]Linux性能分析工具汇总合集","uri":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/#linux-observability-tools--linux-性能观测工具"},{"categories":["performance"],"content":"Linux observability tools | Linux 性能观测工具首先学习的Basic Tool有如下：uptime、top(htop)、mpstat、isstat、vmstat、free、ping、nicstat、dstat。Linux性能检测常用的10个基本命令 高级的命令如下：sar、netstat、pidstat、strace、tcpdump、blktrace、iotop、slabtop、sysctl、/proc。值得收藏！Linux系统常用命令速查手册 ","date":"2021-03-29","objectID":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/:17:0","series":[],"tags":[],"title":"[转]Linux性能分析工具汇总合集","uri":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/#首先学习的basic-tool有如下"},{"categories":["performance"],"content":"Linux observability tools | Linux 性能观测工具首先学习的Basic Tool有如下：uptime、top(htop)、mpstat、isstat、vmstat、free、ping、nicstat、dstat。Linux性能检测常用的10个基本命令 高级的命令如下：sar、netstat、pidstat、strace、tcpdump、blktrace、iotop、slabtop、sysctl、/proc。值得收藏！Linux系统常用命令速查手册 ","date":"2021-03-29","objectID":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/:17:0","series":[],"tags":[],"title":"[转]Linux性能分析工具汇总合集","uri":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/#高级的命令如下"},{"categories":["performance"],"content":"Linux benchmarking tools | Linux 性能测评工具是一款性能测评工具，对于不同模块的性能测试可以使用相应的工具，想要深入了解，可以参考最下文的附件文档。 ","date":"2021-03-29","objectID":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/:18:0","series":[],"tags":[],"title":"[转]Linux性能分析工具汇总合集","uri":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/#linux-benchmarking-tools--linux-性能测评工具"},{"categories":["performance"],"content":"Linux tuning tools | Linux 性能调优工具是一款性能调优工具，主要是从linux内核源码层进行的调优，想要深入了解，可以参考下文附件文档。 ","date":"2021-03-29","objectID":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/:19:0","series":[],"tags":[],"title":"[转]Linux性能分析工具汇总合集","uri":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/#linux-tuning-tools--linux-性能调优工具"},{"categories":["performance"],"content":"Linux observability sar | linux性能观测工具sar（System Activity Reporter系统活动情况报告)是目前LINUX上最为全面的系统性能分析工具之一，可以从多方面对系统的活动进行报告，包括：文件的读写情况、系统调用的使用情况、磁盘I/O、CPU效率、内存使用状况、进程活动及IPC有关的活动等方面。 sar的常归使用方式： sar [options] [-A] [-o file] t [n] 其中： t #为采样间隔，n为采样次数，默认值是1； -o file #表示将命令结果以二进制格式存放在文件中，file 是文件名。 options #为命令行选项 来源：https://rdc.hundsun.com/portal/article/731.html?ref=myread ","date":"2021-03-29","objectID":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/:20:0","series":[],"tags":[],"title":"[转]Linux性能分析工具汇总合集","uri":"/blog/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E5%90%88%E9%9B%86/#linux-observability-sar--linux性能观测工具"},{"categories":[],"content":"小服务器，内存只有2G不够用，得精打细算限制下容器占用的内存，有几种方式可考虑。 ","date":"2020-09-02","objectID":"/blog/docker%E9%99%90%E5%88%B6%E5%AE%B9%E5%99%A8%E5%8D%A0%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F/:0:0","series":[],"tags":["docker"],"title":"Docker限制容器占用的内存大小","uri":"/blog/docker%E9%99%90%E5%88%B6%E5%AE%B9%E5%99%A8%E5%8D%A0%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F/#"},{"categories":[],"content":"一、直接限制docker容器的内存容器使用的内存包括物理内存和 swap。Docker 通过下面两组参数来限制容器内存的大小： -m：限制内存的大小。如：-m 100M，表示容器最多使用100M内存。-m 1G，最多使用1G内存。 –-memory-swap：设置swap 的使用限额。 执行docker run –help命令可看到以上命令相关介绍### 1.1 https://blog.csdn.net/qq_37611270/article/details/97243704 https://www.lixianyang.xyz/posts/docker-%E5%86%85%E5%AD%98-limit-%E4%B8%8E-swap-%E9%99%90%E5%88%B6/ ","date":"2020-09-02","objectID":"/blog/docker%E9%99%90%E5%88%B6%E5%AE%B9%E5%99%A8%E5%8D%A0%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F/:1:0","series":[],"tags":["docker"],"title":"Docker限制容器占用的内存大小","uri":"/blog/docker%E9%99%90%E5%88%B6%E5%AE%B9%E5%99%A8%E5%8D%A0%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F/#一直接限制docker容器的内存"},{"categories":["自动化测试"],"content":"Airtest图像识别算法 1、模板匹配（templateMatching） 2、基于特侦点的图像识别算法（SURF Matching、BRISK Matching） 模板匹配 1、模板匹配无法跨分辨率识别。 2、一定有相对最佳的匹配结果（一定会给一个匹配结果出来，即使相差很大）。 3、方法名：tpl。 特侦点识别 1、跨分辨率识别。 2、不一定有匹配结果。 3、方法名：[kaze，brisk，akaze，orb，sift，surf，brief] airtest使用中实际会采用轮询的方式去匹配，具体为先采用模板匹配查询，再采用特侦点匹配查询，直到查询出一个最优解。 # 使用BRISK算法匹配 try match with BRISKMatching find_best_result() run time is 0.21 s. match result: None resize: (160, 208)-\u003e(160, 208), resolution: (1080, 2400)=\u003e(1080, 1920) try match with SURFMatching find_best_result() run time is 0.23 s. try match with TemplateMatching # confidence置信度只有0.399所以结果被舍弃了 [Template] threshold=0.7, result={'result': (123, 1285), 'rectangle': ((43, 1181), (43, 1389), (203, 1389), (203, 1181)), 'confidence': 0.3993876576423645} find_best_result() run time is 0.08 s. try match with BRISKMatching find_best_result() run time is 0.22 s. match result: None resize: (160, 208)-\u003e(160, 208), resolution: (1080, 2400)=\u003e(1080, 1920) try match with SURFMatching 'Target area is 5 times bigger or 0.2 times smaller than sch_img.' try match with TemplateMatching [Template] threshold=0.7, result={'result': (123, 1285), 'rectangle': ((43, 1181), (43, 1389), (203, 1389), (203, 1181)), 'confidence': 0.3993876576423645} find_best_result() run time is 0.08 s. try match with BRISKMatching find_best_result() run time is 0.21 s. match result: None resize: (160, 208)-\u003e(160, 208), resolution: (1080, 2400)=\u003e(1080, 1920) try match with SURFMatching ","date":"2020-08-16","objectID":"/blog/AirTest%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E7%AE%97%E6%B3%95/:0:0","series":[],"tags":["airtest"],"title":"AirTest图像识别算法","uri":"/blog/AirTest%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E7%AE%97%E6%B3%95/#"},{"categories":["自动化测试"],"content":"Airtest图像识别算法 1、模板匹配（templateMatching） 2、基于特侦点的图像识别算法（SURF Matching、BRISK Matching） 模板匹配 1、模板匹配无法跨分辨率识别。 2、一定有相对最佳的匹配结果（一定会给一个匹配结果出来，即使相差很大）。 3、方法名：tpl。 特侦点识别 1、跨分辨率识别。 2、不一定有匹配结果。 3、方法名：[kaze，brisk，akaze，orb，sift，surf，brief] airtest使用中实际会采用轮询的方式去匹配，具体为先采用模板匹配查询，再采用特侦点匹配查询，直到查询出一个最优解。 # 使用BRISK算法匹配 try match with BRISKMatching find_best_result() run time is 0.21 s. match result: None resize: (160, 208)-(160, 208), resolution: (1080, 2400)=(1080, 1920) try match with SURFMatching find_best_result() run time is 0.23 s. try match with TemplateMatching # confidence置信度只有0.399所以结果被舍弃了 [Template] threshold=0.7, result={'result': (123, 1285), 'rectangle': ((43, 1181), (43, 1389), (203, 1389), (203, 1181)), 'confidence': 0.3993876576423645} find_best_result() run time is 0.08 s. try match with BRISKMatching find_best_result() run time is 0.22 s. match result: None resize: (160, 208)-(160, 208), resolution: (1080, 2400)=(1080, 1920) try match with SURFMatching 'Target area is 5 times bigger or 0.2 times smaller than sch_img.' try match with TemplateMatching [Template] threshold=0.7, result={'result': (123, 1285), 'rectangle': ((43, 1181), (43, 1389), (203, 1389), (203, 1181)), 'confidence': 0.3993876576423645} find_best_result() run time is 0.08 s. try match with BRISKMatching find_best_result() run time is 0.21 s. match result: None resize: (160, 208)-(160, 208), resolution: (1080, 2400)=(1080, 1920) try match with SURFMatching ","date":"2020-08-16","objectID":"/blog/AirTest%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E7%AE%97%E6%B3%95/:0:0","series":[],"tags":["airtest"],"title":"AirTest图像识别算法","uri":"/blog/AirTest%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E7%AE%97%E6%B3%95/#airtest图像识别算法"},{"categories":["网络"],"content":"OSI 七层模型通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯，因此其最主要的功能就是帮助不同类型的主机实现数据传输 。 完成中继功能的节点通常称为中继系统。在OSI七层模型中，处于不同层的中继系统具有不同的名称。 一个设备工作在哪一层，关键看它工作时利用哪一层的数据头部信息。网桥工作时，是以MAC头部来决定转发端口的，因此显然它是数据链路层的设备。 具体说: 物理层：网卡，网线，集线器，中继器，调制解调器 数据链路层：网桥，交换机 网络层：路由器 网关工作在第四层传输层及其以上 集线器是物理层设备,采用广播的形式来传输信息。 交换机就是用来进行报文交换的机器。多为链路层设备(二层交换机)，能够进行地址学习，采用存储转发的形式来交换报文.。 路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。选择通畅快捷的近路，能大大提高通信速度，减轻网络系统通信负荷，节约网络系统资源，提高网络系统畅通率。 交换机和路由器的区别 交换机拥有一条很高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条总线上，控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上，通过内部交换矩阵迅速将数据包传送到目的端口，目的MAC若不存在则广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部MAC地址表中。 使用交换机也可以把网络“分段”，通过对照MAC地址表，交换机只允许必要的网络流量通过交换机。通过交换机的过滤和转发，可以有效的隔离广播风暴，减少误包和错包的出现，避免共享冲突。 交换机在同一时刻可进行多个端口对之间的数据传输。每一端口都可视为独立的网段，连接在其上的网络设备独自享有全部的带宽，无须同其他设备竞争使用。当节点A向节点D发送数据时，节点B可同时向节点C发送数据，而且这两个传输都享有网络的全部带宽，都有着自己的虚拟连接。假使这里使用的是10Mbps的以太网交换机，那么该交换机这时的总流通量就等于2×10Mbps＝20Mbps，而使用10Mbps的共享式HUB时，一个HUB的总流通量也不会超出10Mbps。 总之，交换机是一种基于MAC地址识别，能完成封装转发数据包功能的网络设备。交换机可以“学习”MAC地址，并把其存放在内部地址表中，通过在数据帧的始发者和目标接收者之间建立临时的交换路径，使数据帧直接由源地址到达目的地址。 从过滤网络流量的角度来看，路由器的作用与交换机和网桥非常相似。但是与工作在网络物理层，从物理上划分网段的交换机不同，路由器使用专门的软件协议从逻辑上对整个网络进行划分。例如，一台支持IP协议的路由器可以把网络划分成多个子网段，只有指向特殊IP地址的网络流量才可以通过路由器。对于每一个接收到的数据包，路由器都会重新计算其校验值，并写入新的物理地址。因此，使用路由器转发和过滤数据的速度往往要比只查看数据包物理地址的交换机慢。但是，对于那些结构复杂的网络，使用路由器可以提高网络的整体效率。路由器的另外一个明显优势就是可以自动过滤网络广播。 集线器与路由器在功能上有什么不同? 首先说HUB,也就是集线器。它的作用可以简单的理解为将一些机器连接起来组成一个局域网。而交换机（又名交换式集线器）作用与集线器大体相同。但是两者在性能上有区别：集线器采用的式共享带宽的工作方式，而交换机是独享带宽。这样在机器很多或数据量很大时，两者将会有比较明显的。而路由器与以上两者有明显区别，它的作用在于连接不同的网段并且找到网络中数据传输最合适的路径。路由器是产生于交换机之后，就像交换机产生于集线器之后，所以路由器与交换机也有一定联系，不是完全独立的两种设备。路由器主要克服了交换机不能路由转发数据包的不足。 总的来说，路由器与交换机的主要区别体现在以下几个方面： （1）工作层次不同 最初的的交换机是工作在数据链路层，而路由器一开始就设计工作在网络层。由于交换机工作在数据链路层，所以它的工作原理比较简单，而路由器工作在网络层，可以得到更多的协议信息，路由器可以做出更加智能的转发决策。 （2）数据转发所依据的对象不同 交换机是利用物理地址或者说MAC地址来确定转发数据的目的地址。而路由器则是利用IP地址来确定数据转发的地址。IP地址是在软件中实现的，描述的是设备所在的网络。MAC地址通常是硬件自带的，由网卡生产商来分配的，而且已经固化到了网卡中去，一般来说是不可更改的。而IP地址则通常由网络管理员或系统自动分配。 （3）传统的交换机只能分割冲突域，不能分割广播域；而路由器可以分割广播域 由交换机连接的网段仍属于同一个广播域，广播数据包会在交换机连接的所有网段上传播，在某些情况下会导致通信拥挤和安全漏洞。连接到路由器上的网段会被分配成不同的广播域，广播数据不会穿过路由器。虽然第三层以上交换机具有VLAN功能，也可以分割广播域，但是各子广播域之间是不能通信交流的，它们之间的交流仍然需要路由器。 （4）路由器提供了防火墙的服务 路由器仅仅转发特定地址的数据包，不传送不支持路由协议的数据包传送和未知目标网络数据包的传送，从而可以防止广播风暴。 物理层 在OSI参考模型中，物理层（Physical Layer）是参考模型的最低层，也是OSI模型的第一层。 物理层的主要功能是：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。 物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。 数据链路层 数据链路层（Data Link Layer）是OSI模型的第二层，负责建立和管理节点间的链路。该层的主要功能是：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。 在计算机网络中由于各种干扰的存在，物理链路是不可靠的。因此，这一层的主要功能是在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。 该层通常又被分为介质访问控制（MAC）和逻辑链路控制（LLC）两个子层。 MAC子层的主要任务是解决共享型网络中多用户对信道竞争的问题，完成网络介质的访问控制； LLC子层的主要任务是建立和维护网络连接，执行差错校验、流量控制和链路控制。 数据链路层的具体工作是接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层；并且，还负责处理接收端发回的确认帧的信息，以便提供可靠的数据传输。 网络层 网络层（Network Layer）是OSI模型的第三层，它是OSI参考模型中最复杂的一层，也是通信子网的最高一层。它在下两层的基础上向资源子网提供服务。其主要任务是：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。该层控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。 一般地，数据链路层是解决同一网络内节点之间的通信，而网络层主要解决不同子网间的通信。例如在广域网之间通信时，必然会遇到路由（即两节点间可能有多条路径）选择问题。 在实现网络层功能时，需要解决的主要问题如下： 寻址：数据链路层中使用的物理地址（如MAC地址）仅解决网络内部的寻址问题。在不同子网之间通信时，为了识别和找到网络中的设备，每一子网中的设备都会被分配一个唯一的地址。由于各子网使用的物理技术可能不同，因此这个地址应当是逻辑地址（如IP地址）。 交换：规定不同的信息交换方式。常见的交换技术有：线路交换技术和存储转发技术，后者又包括报文交换技术和分组交换技术。 路由算法：当源节点和目的节点之间存在多条路径时，本层可以根据路由算法，通过网络为数据分组选择最佳路径，并将信息从最合适的路径由发送端传送到接收端。 连接服务：与数据链路层流量控制不同的是，前者控制的是网络相邻节点间的流量，后者控制的是从源节点到目的节点间的流量。其目的在于防止阻塞，并进行差错检测。 传输层 OSI下3层的主要任务是数据通信，上3层的任务是数据处理。而传输层（Transport Layer）是OSI模型的第4层。因此该层是通信子网和资源子网的接口和桥梁，起到承上启下的作用。 该层的主要任务是：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。传输层的作用是向高层屏蔽下层数据通信的细节，即向用户透明地传送报文。该层常见的协议：TCP/IP中的TCP协议、Novell网络中的SPX协议和微软的NetBIOS/NetBEUI协议。 传输层提供会话层和网络层之间的传输服务，这种服务从会话层获得数据，并在必要时，对数据进行分割。然后，传输层将数据传递到网络层，并确保数据能正确无误地传送到网络层。因此，传输层负责提供两节点之间数据的可靠传送，当两节点的联系确定之后，传输层则负责监督工作。综上，传输层的主要功能如下： 传输连接管理：提供建立、维护和拆除传输连接的功能。传输层在网络层的基础上为高层提供“面向连接”和“面向无接连”的两种服务。 处理传输差错：提供可靠的“面向连接”和不太可靠的“面向无连接”的数据传输服务、差错控制和流量控制。在提供“面向连接”服务时，通过这一层传输的数据将由目标设备确认，如果在指定的时间内","date":"2020-02-17","objectID":"/blog/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/:0:0","series":[],"tags":["TCP/IP"],"title":"[转]OSI七层模型","uri":"/blog/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/#"},{"categories":["兼容性测试"],"content":"一般可能导致APP存在兼容性问题的几个原因分析：1、不同厂家的UI操作系统存在差异化，可能导致APP功能实现存在兼容性问题。 2、不同硬件操作系统版本兼容性不一致，可能导致APP功能实现存在兼容性问题。 3、不同分辨率的设备，独特设计的如刘海屏、挖空屏可能导致APP的UI展示存在兼容性问题。 ","date":"2019-11-18","objectID":"/blog/%E4%BA%91%E6%B5%8B%E5%B9%B3%E5%8F%B0%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B%E9%99%84%E4%BB%B6/:1:0","series":["兼容性测试方案选型"],"tags":["云测","兼容性测试"],"title":"云测平台兼容性测试方案选型（附件）","uri":"/blog/%E4%BA%91%E6%B5%8B%E5%B9%B3%E5%8F%B0%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B%E9%99%84%E4%BB%B6/#一般可能导致app存在兼容性问题的几个原因分析"},{"categories":["兼容性测试"],"content":"市场调研结果梳理：","date":"2019-11-18","objectID":"/blog/%E4%BA%91%E6%B5%8B%E5%B9%B3%E5%8F%B0%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B%E9%99%84%E4%BB%B6/:2:0","series":["兼容性测试方案选型"],"tags":["云测","兼容性测试"],"title":"云测平台兼容性测试方案选型（附件）","uri":"/blog/%E4%BA%91%E6%B5%8B%E5%B9%B3%E5%8F%B0%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B%E9%99%84%E4%BB%B6/#市场调研结果梳理"},{"categories":["兼容性测试"],"content":"1、市面常见手机型号？经查阅相关资料及报告： （腾讯移动分析报告2019年11月*-2020年11**月设备活跃指数与设备品牌指数数据)* （友盟指数报告2019年11月*-2020年11**月手机品牌结构变化数据)* 市面常见手机型号结论： 根据以上报告分析得出，表格内品牌及型号手机是当前市面上使用率较高手机，兼容性测试需要尽可能覆盖到以下型号： 品牌 型号 OPPO oppo A5全网通版(pbam00) 华为 HUAWEI P30(ELE-AL00) 华为 华为nova5 Pro(SEA-AL10) OPPO OPPO R17(PBEM00) OPPO OPPO A57 VIVO VIVO X9 OPPO OPPO R15(PACM00) 荣耀 荣耀9X(HLK-AL00) VIVO vivo Y3 (V1901A) OPPO OPPO A9(PCAM10) 小米 小米 6 小米 Redmi 9 IPHONE IPHONE 10 IPHONE IPHONE 7PLUS IPHONE IPHONE 6S-PLUS IPHONE IPHONE 7 ","date":"2019-11-18","objectID":"/blog/%E4%BA%91%E6%B5%8B%E5%B9%B3%E5%8F%B0%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B%E9%99%84%E4%BB%B6/:2:1","series":["兼容性测试方案选型"],"tags":["云测","兼容性测试"],"title":"云测平台兼容性测试方案选型（附件）","uri":"/blog/%E4%BA%91%E6%B5%8B%E5%B9%B3%E5%8F%B0%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B%E9%99%84%E4%BB%B6/#1市面常见手机型号"},{"categories":["兼容性测试"],"content":"2.市面常见安卓版本？经查阅相关资料及报告 （腾讯移动分析报告2019年11月*-2020年11**月操作系统分布数据)* （友盟指数报告2019年11月*-2020年11**月硬件功能趋势数据)* 市面常见安卓版本结论： 兼容性测试需要覆盖到常见的以下版本： 安卓：10、9、8.1、7.1 IPHONE：13.6、13.7、14.1、13.3 ","date":"2019-11-18","objectID":"/blog/%E4%BA%91%E6%B5%8B%E5%B9%B3%E5%8F%B0%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B%E9%99%84%E4%BB%B6/:2:2","series":["兼容性测试方案选型"],"tags":["云测","兼容性测试"],"title":"云测平台兼容性测试方案选型（附件）","uri":"/blog/%E4%BA%91%E6%B5%8B%E5%B9%B3%E5%8F%B0%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B%E9%99%84%E4%BB%B6/#2市面常见安卓版本"},{"categories":["兼容性测试"],"content":"云测testin平台能够提供的兼容性解决方案标准兼容测试免费版： 优势： 免费、自动化测试、自动出测试报告、安卓/IOS系统版本可以完全覆盖、不同设备分辨率可以完全覆盖。 劣势： 1、每天限使用1次； 2、只能做安装、启动、卸载、monkey随机测试，不能实现业务场景； 3、部分市面常见机型覆盖不到。 价格： 免费，每天限使用1次。 远程真机付费自动化测试： 优势： 1、业务场景可以全覆盖，市面常见机型覆盖基本可以覆盖，安卓/IOS系统版本可以完全覆盖，不同设备分辨率可以完全覆盖； 2、购买分钟数后随时可用，远程连接云端真机测试； 3、人工手动测试，可操作性强，可随时复现问题； 劣势： 1、需要设计开发自动化测试脚本、或者人工手动测试完成，会增加测试时间，覆盖机型越多增加的时间成本和经济成本越高； 2、不能自动出测试报告，需要将自动化测试报告整合为兼容性测试报告； 3、需要进行人员培训，需要学习使用云测平台云端录入脚本、常见adb命令等； 价格： 市面常用手机列举了13款，假定一次兼容性测试预计在15分钟内完成： 如购买季包1888元，单次兼容性测试价格大概：(1888/900)(1315)=409元 如按需购买，单机3元/分钟打9折，单次兼容性测试价格大概：13153*0.9=526.5元 深度兼容测试： 最低5000元套餐： 1、单次测试最低收费5000，包含100款机型兼容性测试。【可以覆盖完全上面列举所有机型、系统版本、设备分辨率】 2、由testin业务方编写自动化脚本，脚本运行时间在10分钟内。【满足UI展示相关的大部分业务需求，但涉及到停车缴费业务因为需要和设备或POS互动完成出入场缴费、测试数据准备工作，还需要我方配合设计开发脚本，我方工作量也不会小】 其他定制套餐，根据需求方个性化定制，单次测试价格从5000至50000不等。 ","date":"2019-11-18","objectID":"/blog/%E4%BA%91%E6%B5%8B%E5%B9%B3%E5%8F%B0%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B%E9%99%84%E4%BB%B6/:3:0","series":["兼容性测试方案选型"],"tags":["云测","兼容性测试"],"title":"云测平台兼容性测试方案选型（附件）","uri":"/blog/%E4%BA%91%E6%B5%8B%E5%B9%B3%E5%8F%B0%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B%E9%99%84%E4%BB%B6/#云测testin平台能够提供的兼容性解决方案"},{"categories":["兼容性测试"],"content":"参考资料：腾讯移动分析：https://mta.qq.com/mta/data/device/os 友盟指数：https://compass.umeng.com/?utm_source=zzbanner 云测官网：http://tpayapi.testin.cn/ ","date":"2019-11-18","objectID":"/blog/%E4%BA%91%E6%B5%8B%E5%B9%B3%E5%8F%B0%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B%E9%99%84%E4%BB%B6/:4:0","series":["兼容性测试方案选型"],"tags":["云测","兼容性测试"],"title":"云测平台兼容性测试方案选型（附件）","uri":"/blog/%E4%BA%91%E6%B5%8B%E5%B9%B3%E5%8F%B0%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B%E9%99%84%E4%BB%B6/#参考资料"},{"categories":["兼容性测试"],"content":"关于兼容性测试解决方案，经过调研云测平台能够给我们提供以下3种解决方案。我本人比较推荐1和2共同使用，建议先购买云测月包套餐666元，初期主要用于编写兼容性测试脚本，待脚本稳定后可选择购买季包套餐（单次兼容性测试价格大概409元）或者按需购买套餐（单次兼容性测试价格大概526.5元）。 以下是简单说明，详细报告请查阅附件。 1、标准兼容测试免费版：优势： 免费、自动化测试、自动出测试报告、安卓/IOS系统版本可以完全覆盖、不同设备分辨率可以完全覆盖。 劣势： 1、每天限使用1次； 2、只能做安装、启动、卸载、monkey随机测试，不能实现业务场景； 3、部分市面常见机型覆盖不到。 价格： 免费，每天限使用1次。 2、远程真机付费自动化测试：优势： 1、业务场景可以全覆盖，市面常见机型覆盖基本可以覆盖，安卓/IOS系统版本可以完全覆盖，不同设备分辨率可以完全覆盖； 2、购买分钟数后随时可用，远程连接云端真机测试； 3、人工手动测试，可操作性强，可随时复现问题； 劣势： 1、需要设计开发自动化测试脚本、或者人工手动测试完成，会增加测试时间，覆盖机型越多增加的时间成本和经济成本越高； 2、不能自动出测试报告，需要将自动化测试报告整合为兼容性测试报告； 3、需要进行人员培训，需要学习使用云测平台云端录入脚本、常见adb命令等； 价格： 市面常用手机列举了13款，假定一次兼容性测试预计在15分钟内完成： 如购买季包1888元，单次兼容性测试价格大概：(1888/900)(1315)=409元 如按需购买，单机3元/分钟打9折，单次兼容性测试价格大概：13153*0.9=526.5元 3、深度兼容测试：最低5000元套餐： 1、单次测试最低收费5000，包含100款机型兼容性测试。【可以覆盖完全上面列举所有机型、系统版本、设备分辨率】 2、由testin业务方编写自动化脚本，脚本运行时间在10分钟内。【满足UI展示相关的大部分业务需求，但涉及到停车缴费业务因为需要和设备或POS互动完成出入场缴费、测试数据准备工作，还需要我方配合设计开发脚本，我方工作量也不会小】 其他定制套餐，根据需求方个性化定制，单次测试价格从5000至50000不等。 ","date":"2019-11-18","objectID":"/blog/%E4%BA%91%E6%B5%8B%E5%B9%B3%E5%8F%B0%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B/:0:0","series":["兼容性测试方案选型"],"tags":["云测","兼容性测试"],"title":"云测平台兼容性测试方案选型","uri":"/blog/%E4%BA%91%E6%B5%8B%E5%B9%B3%E5%8F%B0%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B/#"},{"categories":["兼容性测试"],"content":"关于兼容性测试解决方案，经过调研云测平台能够给我们提供以下3种解决方案。我本人比较推荐1和2共同使用，建议先购买云测月包套餐666元，初期主要用于编写兼容性测试脚本，待脚本稳定后可选择购买季包套餐（单次兼容性测试价格大概409元）或者按需购买套餐（单次兼容性测试价格大概526.5元）。 以下是简单说明，详细报告请查阅附件。 1、标准兼容测试免费版：优势： 免费、自动化测试、自动出测试报告、安卓/IOS系统版本可以完全覆盖、不同设备分辨率可以完全覆盖。 劣势： 1、每天限使用1次； 2、只能做安装、启动、卸载、monkey随机测试，不能实现业务场景； 3、部分市面常见机型覆盖不到。 价格： 免费，每天限使用1次。 2、远程真机付费自动化测试：优势： 1、业务场景可以全覆盖，市面常见机型覆盖基本可以覆盖，安卓/IOS系统版本可以完全覆盖，不同设备分辨率可以完全覆盖； 2、购买分钟数后随时可用，远程连接云端真机测试； 3、人工手动测试，可操作性强，可随时复现问题； 劣势： 1、需要设计开发自动化测试脚本、或者人工手动测试完成，会增加测试时间，覆盖机型越多增加的时间成本和经济成本越高； 2、不能自动出测试报告，需要将自动化测试报告整合为兼容性测试报告； 3、需要进行人员培训，需要学习使用云测平台云端录入脚本、常见adb命令等； 价格： 市面常用手机列举了13款，假定一次兼容性测试预计在15分钟内完成： 如购买季包1888元，单次兼容性测试价格大概：(1888/900)(1315)=409元 如按需购买，单机3元/分钟打9折，单次兼容性测试价格大概：13153*0.9=526.5元 3、深度兼容测试：最低5000元套餐： 1、单次测试最低收费5000，包含100款机型兼容性测试。【可以覆盖完全上面列举所有机型、系统版本、设备分辨率】 2、由testin业务方编写自动化脚本，脚本运行时间在10分钟内。【满足UI展示相关的大部分业务需求，但涉及到停车缴费业务因为需要和设备或POS互动完成出入场缴费、测试数据准备工作，还需要我方配合设计开发脚本，我方工作量也不会小】 其他定制套餐，根据需求方个性化定制，单次测试价格从5000至50000不等。 ","date":"2019-11-18","objectID":"/blog/%E4%BA%91%E6%B5%8B%E5%B9%B3%E5%8F%B0%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B/:0:0","series":["兼容性测试方案选型"],"tags":["云测","兼容性测试"],"title":"云测平台兼容性测试方案选型","uri":"/blog/%E4%BA%91%E6%B5%8B%E5%B9%B3%E5%8F%B0%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B/#1标准兼容测试免费版"},{"categories":["兼容性测试"],"content":"关于兼容性测试解决方案，经过调研云测平台能够给我们提供以下3种解决方案。我本人比较推荐1和2共同使用，建议先购买云测月包套餐666元，初期主要用于编写兼容性测试脚本，待脚本稳定后可选择购买季包套餐（单次兼容性测试价格大概409元）或者按需购买套餐（单次兼容性测试价格大概526.5元）。 以下是简单说明，详细报告请查阅附件。 1、标准兼容测试免费版：优势： 免费、自动化测试、自动出测试报告、安卓/IOS系统版本可以完全覆盖、不同设备分辨率可以完全覆盖。 劣势： 1、每天限使用1次； 2、只能做安装、启动、卸载、monkey随机测试，不能实现业务场景； 3、部分市面常见机型覆盖不到。 价格： 免费，每天限使用1次。 2、远程真机付费自动化测试：优势： 1、业务场景可以全覆盖，市面常见机型覆盖基本可以覆盖，安卓/IOS系统版本可以完全覆盖，不同设备分辨率可以完全覆盖； 2、购买分钟数后随时可用，远程连接云端真机测试； 3、人工手动测试，可操作性强，可随时复现问题； 劣势： 1、需要设计开发自动化测试脚本、或者人工手动测试完成，会增加测试时间，覆盖机型越多增加的时间成本和经济成本越高； 2、不能自动出测试报告，需要将自动化测试报告整合为兼容性测试报告； 3、需要进行人员培训，需要学习使用云测平台云端录入脚本、常见adb命令等； 价格： 市面常用手机列举了13款，假定一次兼容性测试预计在15分钟内完成： 如购买季包1888元，单次兼容性测试价格大概：(1888/900)(1315)=409元 如按需购买，单机3元/分钟打9折，单次兼容性测试价格大概：13153*0.9=526.5元 3、深度兼容测试：最低5000元套餐： 1、单次测试最低收费5000，包含100款机型兼容性测试。【可以覆盖完全上面列举所有机型、系统版本、设备分辨率】 2、由testin业务方编写自动化脚本，脚本运行时间在10分钟内。【满足UI展示相关的大部分业务需求，但涉及到停车缴费业务因为需要和设备或POS互动完成出入场缴费、测试数据准备工作，还需要我方配合设计开发脚本，我方工作量也不会小】 其他定制套餐，根据需求方个性化定制，单次测试价格从5000至50000不等。 ","date":"2019-11-18","objectID":"/blog/%E4%BA%91%E6%B5%8B%E5%B9%B3%E5%8F%B0%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B/:0:0","series":["兼容性测试方案选型"],"tags":["云测","兼容性测试"],"title":"云测平台兼容性测试方案选型","uri":"/blog/%E4%BA%91%E6%B5%8B%E5%B9%B3%E5%8F%B0%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B/#2远程真机付费自动化测试"},{"categories":["兼容性测试"],"content":"关于兼容性测试解决方案，经过调研云测平台能够给我们提供以下3种解决方案。我本人比较推荐1和2共同使用，建议先购买云测月包套餐666元，初期主要用于编写兼容性测试脚本，待脚本稳定后可选择购买季包套餐（单次兼容性测试价格大概409元）或者按需购买套餐（单次兼容性测试价格大概526.5元）。 以下是简单说明，详细报告请查阅附件。 1、标准兼容测试免费版：优势： 免费、自动化测试、自动出测试报告、安卓/IOS系统版本可以完全覆盖、不同设备分辨率可以完全覆盖。 劣势： 1、每天限使用1次； 2、只能做安装、启动、卸载、monkey随机测试，不能实现业务场景； 3、部分市面常见机型覆盖不到。 价格： 免费，每天限使用1次。 2、远程真机付费自动化测试：优势： 1、业务场景可以全覆盖，市面常见机型覆盖基本可以覆盖，安卓/IOS系统版本可以完全覆盖，不同设备分辨率可以完全覆盖； 2、购买分钟数后随时可用，远程连接云端真机测试； 3、人工手动测试，可操作性强，可随时复现问题； 劣势： 1、需要设计开发自动化测试脚本、或者人工手动测试完成，会增加测试时间，覆盖机型越多增加的时间成本和经济成本越高； 2、不能自动出测试报告，需要将自动化测试报告整合为兼容性测试报告； 3、需要进行人员培训，需要学习使用云测平台云端录入脚本、常见adb命令等； 价格： 市面常用手机列举了13款，假定一次兼容性测试预计在15分钟内完成： 如购买季包1888元，单次兼容性测试价格大概：(1888/900)(1315)=409元 如按需购买，单机3元/分钟打9折，单次兼容性测试价格大概：13153*0.9=526.5元 3、深度兼容测试：最低5000元套餐： 1、单次测试最低收费5000，包含100款机型兼容性测试。【可以覆盖完全上面列举所有机型、系统版本、设备分辨率】 2、由testin业务方编写自动化脚本，脚本运行时间在10分钟内。【满足UI展示相关的大部分业务需求，但涉及到停车缴费业务因为需要和设备或POS互动完成出入场缴费、测试数据准备工作，还需要我方配合设计开发脚本，我方工作量也不会小】 其他定制套餐，根据需求方个性化定制，单次测试价格从5000至50000不等。 ","date":"2019-11-18","objectID":"/blog/%E4%BA%91%E6%B5%8B%E5%B9%B3%E5%8F%B0%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B/:0:0","series":["兼容性测试方案选型"],"tags":["云测","兼容性测试"],"title":"云测平台兼容性测试方案选型","uri":"/blog/%E4%BA%91%E6%B5%8B%E5%B9%B3%E5%8F%B0%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B/#3深度兼容测试"},{"categories":[],"content":"CA证书抓包应用内置的CA证书必须安装到系统中。android系统将CA证书分为用户CA证书和系统CA证书。 安卓7.0开始谷歌改变了网络安全策略。用户CA证书默认不被TSL/SSL连接信任，解决方法：1、安装系统CA证书(root)。2、虚拟机安装app抓包(virtualxpose)。 其他原因抓不到包：公钥证书固定、双向认证、非http协议抓包。 HttpCanary使用man-in-the-middle(MITM)技术抓取和解析TLS/SSL协议数据包，比如常见的HTTPS、WSS等加密请求，所以使用之前必须先安装HttpCanary根证书。 ","date":"2019-11-10","objectID":"/blog/%E7%94%A8%E6%88%B7CA%E8%AF%81%E4%B9%A6%E9%99%90%E5%88%B6/:1:0","series":[],"tags":["抓包","httpcanary"],"title":"用户CA证书限制","uri":"/blog/%E7%94%A8%E6%88%B7CA%E8%AF%81%E4%B9%A6%E9%99%90%E5%88%B6/#ca证书"},{"categories":["python"],"content":"嵌套函数的调用示例 def func1(a1): def func2(a2): def func3(a3): print(f'{a1},{a2},{a3}') return func3 return func2 func1(1)(2)(3) # 1,2,3 闭包示例 def func1(): def func2(a2): def func3(a3): print(f'{a2},{a3}') print(\"func3\") print(func3.__closure__) return func3 print(\"func2\") print(func2.__closure__) return func2 print(func1.__closure__) func1()(2)(3) # None # func2 # None # func3 # (\u003ccell at 0x000001FCA4B03AC8: int object at 0x00007FFD0F3A6690\u003e,) # 2,3 函数名.__closure__ 在函数是闭包函数时，返回一个cell元素；不是闭包时，返回None。上例中func1、func2都不是闭包，func3是闭包，区别在于func3中引入了func2中的变量，可见闭包的特点就是内部函数引用了外部函数中的变量。 另可知，闭包及嵌套函数执行顺序为，内部函数只会被定义，只有当内部函数被调用时才执行其内部代码。 装饰器示例 def add_tag(func): def add_func(*args,**kwargs): return f'\u003csb\u003e {func(*args,**kwargs)}' return add_func def print_text(name): return f'{name}' @add_tag def print_text2(name): return f'{name}' print(add_tag(print_text)('wxz')) print(print_text2('wxz')) # \u003csb\u003e wxz # \u003csb\u003e wxz print(print_text3.__name__) # add_func add_tag(print_text)(‘wxz’)和print_text2(‘wxz’)是等价的，装饰器实际就是嵌套函数（吗？其实还是有些不一样，见下面）。 另外可以看到执行func.__name__返回的是装饰器内的add_func方法名，原因是 add_func 覆写了 print_text3 函数的 name、doc、modual 三个属性。改回来的话可以使用Python 中的 functools.wraps 装饰器，如下面的代码。 带参数的装饰器示例 def add_anytag(tagname): def add_tag(func): @wraps(func) def add_func(*args, **kwargs): return f'\u003c{tagname}\u003e {func(*args, **kwargs)} \u003c/{tagname}\u003e' return add_func return add_tag def print_text33(name): return f'{name}' @add_anytag(tagname='div') def print_text3(name): return f'{name}' print(add_anytag('div')(print_text33)('baba')) print(print_text3('wxz')) # \u003cdiv\u003e baba \u003c/div\u003e # \u003cdiv\u003e wxz \u003c/div\u003e print(print_text3.__name__) # print_text3 add_anytag(‘div’)(print_text33)(‘baba’)和print_text3(‘wxz’)效果也是等价的。 如果想直接访问原始的无装饰器的函数怎么办？装饰器到底是什么 def real_decorator(func): print('【装饰器】：当装饰器被定义时我就会被加载。') def inner_decorator(*args, **kwargs): print('【装饰器】：func执行前调用') func() print('【装饰器】：func执行后调用') return inner_decorator print('func定义前我会打印出来') @real_decorator def test_decorator(): print('【func】：我是func') print('func定义后我会打印出来') test_decorator() print('func执行后我会打印出来') # func定义前我会打印出来 # 【装饰器】：当装饰器被定义时我就会被加载。 # func定义后我会打印出来 # 【装饰器】：func执行前调用 # 【func】：我是func # 【装饰器】：func执行后调用 # func执行后我会打印出来 由上面可见，装饰器real_decorator在被定义到test_decorator头上时就被执行了。它的本质相当于执行下面这行代码 # 定义一个变量do_real_decorator do_real_decorator = real_decorator(test_decorator) 所以real_decorator里面的print在test_decorator执行前就执行了。下面看下多个装饰器的情况。 多个装饰器 def set_func1(func): print('外壁巴布1') def wrapper1(*args,**kwargs): print('装饰内容开始1') func(*args, **kwargs) print('装饰内容结束1') print('外壁巴布11') return wrapper1 # 定义第二个装饰器 def set_func2(func): print('外壁巴布2') def wrapper2(*args,**kwargs): print('装饰内容开始2') func(*args, **kwargs) print('装饰内容结束2') print('外壁巴布22') return wrapper2 # 定义第二个装饰器 def set_func3(func): print('外壁巴布3') def wrapper3(*args,**kwargs): print('装饰内容开始3') func(*args, **kwargs) print('装饰内容结束3') print('外壁巴布33') return wrapper3 @set_func1 @set_func2 @set_func3 def show(): print('Show Run....') def show2(): print('show run2') print('》》》》》》》》》》》》》》》》》我是分割线，免得你看懵逼了') show() # 外壁巴布3 # 外壁巴布33 # 外壁巴布2 # 外壁巴布22 # 外壁巴布1 # 外壁巴布11 # 》》》》》》》》》》》》》》》》》我是分割线，免得你看懵逼了 # 装饰内容开始1 # 装饰内容开始2 # 装饰内容开始3 # Show Run.... # 装饰内容结束3 # 装饰内容结束2 # 装饰内容结束1 可见，多个装饰器被定义的顺序是从下到上，转换成嵌套函数则是，最下层是最内层。 set_func1(set_func2(set_func3(show2)))() 和 show() 是等价的。 def show2(): print('show run2') set_func1(set_func2(set_func3(show2)))() # 外壁巴布3 # 外壁巴布33 # 外壁巴布2 # 外壁巴布22 # 外壁巴布1 # 外壁巴布11 # 装饰内容开始1 # 装饰内容开始2 # 装饰内容开始3 # show run2 # 装饰内容结束3 # 装饰内容结束2 # 装饰内容结束1 ","date":"2019-06-30","objectID":"/blog/python%E5%B5%8C%E5%A5%97%E5%87%BD%E6%95%B0%E9%97%AD%E5%8C%85%E8%A3%85%E9%A5%B0%E5%99%A8/:0:0","series":[],"tags":[],"title":"Python嵌套函数、闭包、装饰器","uri":"/blog/python%E5%B5%8C%E5%A5%97%E5%87%BD%E6%95%B0%E9%97%AD%E5%8C%85%E8%A3%85%E9%A5%B0%E5%99%A8/#"},{"categories":["python"],"content":"嵌套函数的调用示例 def func1(a1): def func2(a2): def func3(a3): print(f'{a1},{a2},{a3}') return func3 return func2 func1(1)(2)(3) # 1,2,3 闭包示例 def func1(): def func2(a2): def func3(a3): print(f'{a2},{a3}') print(\"func3\") print(func3.__closure__) return func3 print(\"func2\") print(func2.__closure__) return func2 print(func1.__closure__) func1()(2)(3) # None # func2 # None # func3 # (,) # 2,3 函数名.__closure__ 在函数是闭包函数时，返回一个cell元素；不是闭包时，返回None。上例中func1、func2都不是闭包，func3是闭包，区别在于func3中引入了func2中的变量，可见闭包的特点就是内部函数引用了外部函数中的变量。 另可知，闭包及嵌套函数执行顺序为，内部函数只会被定义，只有当内部函数被调用时才执行其内部代码。 装饰器示例 def add_tag(func): def add_func(*args,**kwargs): return f' {func(*args,**kwargs)}' return add_func def print_text(name): return f'{name}' @add_tag def print_text2(name): return f'{name}' print(add_tag(print_text)('wxz')) print(print_text2('wxz')) # wxz # wxz print(print_text3.__name__) # add_func add_tag(print_text)(‘wxz’)和print_text2(‘wxz’)是等价的，装饰器实际就是嵌套函数（吗？其实还是有些不一样，见下面）。 另外可以看到执行func.__name__返回的是装饰器内的add_func方法名，原因是 add_func 覆写了 print_text3 函数的 name、doc、modual 三个属性。改回来的话可以使用Python 中的 functools.wraps 装饰器，如下面的代码。 带参数的装饰器示例 def add_anytag(tagname): def add_tag(func): @wraps(func) def add_func(*args, **kwargs): return f' {func(*args, **kwargs)} ' return add_func return add_tag def print_text33(name): return f'{name}' @add_anytag(tagname='div') def print_text3(name): return f'{name}' print(add_anytag('div')(print_text33)('baba')) print(print_text3('wxz')) # baba # wxz print(print_text3.__name__) # print_text3 add_anytag(‘div’)(print_text33)(‘baba’)和print_text3(‘wxz’)效果也是等价的。 如果想直接访问原始的无装饰器的函数怎么办？装饰器到底是什么 def real_decorator(func): print('【装饰器】：当装饰器被定义时我就会被加载。') def inner_decorator(*args, **kwargs): print('【装饰器】：func执行前调用') func() print('【装饰器】：func执行后调用') return inner_decorator print('func定义前我会打印出来') @real_decorator def test_decorator(): print('【func】：我是func') print('func定义后我会打印出来') test_decorator() print('func执行后我会打印出来') # func定义前我会打印出来 # 【装饰器】：当装饰器被定义时我就会被加载。 # func定义后我会打印出来 # 【装饰器】：func执行前调用 # 【func】：我是func # 【装饰器】：func执行后调用 # func执行后我会打印出来 由上面可见，装饰器real_decorator在被定义到test_decorator头上时就被执行了。它的本质相当于执行下面这行代码 # 定义一个变量do_real_decorator do_real_decorator = real_decorator(test_decorator) 所以real_decorator里面的print在test_decorator执行前就执行了。下面看下多个装饰器的情况。 多个装饰器 def set_func1(func): print('外壁巴布1') def wrapper1(*args,**kwargs): print('装饰内容开始1') func(*args, **kwargs) print('装饰内容结束1') print('外壁巴布11') return wrapper1 # 定义第二个装饰器 def set_func2(func): print('外壁巴布2') def wrapper2(*args,**kwargs): print('装饰内容开始2') func(*args, **kwargs) print('装饰内容结束2') print('外壁巴布22') return wrapper2 # 定义第二个装饰器 def set_func3(func): print('外壁巴布3') def wrapper3(*args,**kwargs): print('装饰内容开始3') func(*args, **kwargs) print('装饰内容结束3') print('外壁巴布33') return wrapper3 @set_func1 @set_func2 @set_func3 def show(): print('Show Run....') def show2(): print('show run2') print('》》》》》》》》》》》》》》》》》我是分割线，免得你看懵逼了') show() # 外壁巴布3 # 外壁巴布33 # 外壁巴布2 # 外壁巴布22 # 外壁巴布1 # 外壁巴布11 # 》》》》》》》》》》》》》》》》》我是分割线，免得你看懵逼了 # 装饰内容开始1 # 装饰内容开始2 # 装饰内容开始3 # Show Run.... # 装饰内容结束3 # 装饰内容结束2 # 装饰内容结束1 可见，多个装饰器被定义的顺序是从下到上，转换成嵌套函数则是，最下层是最内层。 set_func1(set_func2(set_func3(show2)))() 和 show() 是等价的。 def show2(): print('show run2') set_func1(set_func2(set_func3(show2)))() # 外壁巴布3 # 外壁巴布33 # 外壁巴布2 # 外壁巴布22 # 外壁巴布1 # 外壁巴布11 # 装饰内容开始1 # 装饰内容开始2 # 装饰内容开始3 # show run2 # 装饰内容结束3 # 装饰内容结束2 # 装饰内容结束1 ","date":"2019-06-30","objectID":"/blog/python%E5%B5%8C%E5%A5%97%E5%87%BD%E6%95%B0%E9%97%AD%E5%8C%85%E8%A3%85%E9%A5%B0%E5%99%A8/:0:0","series":[],"tags":[],"title":"Python嵌套函数、闭包、装饰器","uri":"/blog/python%E5%B5%8C%E5%A5%97%E5%87%BD%E6%95%B0%E9%97%AD%E5%8C%85%E8%A3%85%E9%A5%B0%E5%99%A8/#嵌套函数的调用示例"},{"categories":["python"],"content":"嵌套函数的调用示例 def func1(a1): def func2(a2): def func3(a3): print(f'{a1},{a2},{a3}') return func3 return func2 func1(1)(2)(3) # 1,2,3 闭包示例 def func1(): def func2(a2): def func3(a3): print(f'{a2},{a3}') print(\"func3\") print(func3.__closure__) return func3 print(\"func2\") print(func2.__closure__) return func2 print(func1.__closure__) func1()(2)(3) # None # func2 # None # func3 # (,) # 2,3 函数名.__closure__ 在函数是闭包函数时，返回一个cell元素；不是闭包时，返回None。上例中func1、func2都不是闭包，func3是闭包，区别在于func3中引入了func2中的变量，可见闭包的特点就是内部函数引用了外部函数中的变量。 另可知，闭包及嵌套函数执行顺序为，内部函数只会被定义，只有当内部函数被调用时才执行其内部代码。 装饰器示例 def add_tag(func): def add_func(*args,**kwargs): return f' {func(*args,**kwargs)}' return add_func def print_text(name): return f'{name}' @add_tag def print_text2(name): return f'{name}' print(add_tag(print_text)('wxz')) print(print_text2('wxz')) # wxz # wxz print(print_text3.__name__) # add_func add_tag(print_text)(‘wxz’)和print_text2(‘wxz’)是等价的，装饰器实际就是嵌套函数（吗？其实还是有些不一样，见下面）。 另外可以看到执行func.__name__返回的是装饰器内的add_func方法名，原因是 add_func 覆写了 print_text3 函数的 name、doc、modual 三个属性。改回来的话可以使用Python 中的 functools.wraps 装饰器，如下面的代码。 带参数的装饰器示例 def add_anytag(tagname): def add_tag(func): @wraps(func) def add_func(*args, **kwargs): return f' {func(*args, **kwargs)} ' return add_func return add_tag def print_text33(name): return f'{name}' @add_anytag(tagname='div') def print_text3(name): return f'{name}' print(add_anytag('div')(print_text33)('baba')) print(print_text3('wxz')) # baba # wxz print(print_text3.__name__) # print_text3 add_anytag(‘div’)(print_text33)(‘baba’)和print_text3(‘wxz’)效果也是等价的。 如果想直接访问原始的无装饰器的函数怎么办？装饰器到底是什么 def real_decorator(func): print('【装饰器】：当装饰器被定义时我就会被加载。') def inner_decorator(*args, **kwargs): print('【装饰器】：func执行前调用') func() print('【装饰器】：func执行后调用') return inner_decorator print('func定义前我会打印出来') @real_decorator def test_decorator(): print('【func】：我是func') print('func定义后我会打印出来') test_decorator() print('func执行后我会打印出来') # func定义前我会打印出来 # 【装饰器】：当装饰器被定义时我就会被加载。 # func定义后我会打印出来 # 【装饰器】：func执行前调用 # 【func】：我是func # 【装饰器】：func执行后调用 # func执行后我会打印出来 由上面可见，装饰器real_decorator在被定义到test_decorator头上时就被执行了。它的本质相当于执行下面这行代码 # 定义一个变量do_real_decorator do_real_decorator = real_decorator(test_decorator) 所以real_decorator里面的print在test_decorator执行前就执行了。下面看下多个装饰器的情况。 多个装饰器 def set_func1(func): print('外壁巴布1') def wrapper1(*args,**kwargs): print('装饰内容开始1') func(*args, **kwargs) print('装饰内容结束1') print('外壁巴布11') return wrapper1 # 定义第二个装饰器 def set_func2(func): print('外壁巴布2') def wrapper2(*args,**kwargs): print('装饰内容开始2') func(*args, **kwargs) print('装饰内容结束2') print('外壁巴布22') return wrapper2 # 定义第二个装饰器 def set_func3(func): print('外壁巴布3') def wrapper3(*args,**kwargs): print('装饰内容开始3') func(*args, **kwargs) print('装饰内容结束3') print('外壁巴布33') return wrapper3 @set_func1 @set_func2 @set_func3 def show(): print('Show Run....') def show2(): print('show run2') print('》》》》》》》》》》》》》》》》》我是分割线，免得你看懵逼了') show() # 外壁巴布3 # 外壁巴布33 # 外壁巴布2 # 外壁巴布22 # 外壁巴布1 # 外壁巴布11 # 》》》》》》》》》》》》》》》》》我是分割线，免得你看懵逼了 # 装饰内容开始1 # 装饰内容开始2 # 装饰内容开始3 # Show Run.... # 装饰内容结束3 # 装饰内容结束2 # 装饰内容结束1 可见，多个装饰器被定义的顺序是从下到上，转换成嵌套函数则是，最下层是最内层。 set_func1(set_func2(set_func3(show2)))() 和 show() 是等价的。 def show2(): print('show run2') set_func1(set_func2(set_func3(show2)))() # 外壁巴布3 # 外壁巴布33 # 外壁巴布2 # 外壁巴布22 # 外壁巴布1 # 外壁巴布11 # 装饰内容开始1 # 装饰内容开始2 # 装饰内容开始3 # show run2 # 装饰内容结束3 # 装饰内容结束2 # 装饰内容结束1 ","date":"2019-06-30","objectID":"/blog/python%E5%B5%8C%E5%A5%97%E5%87%BD%E6%95%B0%E9%97%AD%E5%8C%85%E8%A3%85%E9%A5%B0%E5%99%A8/:0:0","series":[],"tags":[],"title":"Python嵌套函数、闭包、装饰器","uri":"/blog/python%E5%B5%8C%E5%A5%97%E5%87%BD%E6%95%B0%E9%97%AD%E5%8C%85%E8%A3%85%E9%A5%B0%E5%99%A8/#闭包示例"},{"categories":["python"],"content":"嵌套函数的调用示例 def func1(a1): def func2(a2): def func3(a3): print(f'{a1},{a2},{a3}') return func3 return func2 func1(1)(2)(3) # 1,2,3 闭包示例 def func1(): def func2(a2): def func3(a3): print(f'{a2},{a3}') print(\"func3\") print(func3.__closure__) return func3 print(\"func2\") print(func2.__closure__) return func2 print(func1.__closure__) func1()(2)(3) # None # func2 # None # func3 # (,) # 2,3 函数名.__closure__ 在函数是闭包函数时，返回一个cell元素；不是闭包时，返回None。上例中func1、func2都不是闭包，func3是闭包，区别在于func3中引入了func2中的变量，可见闭包的特点就是内部函数引用了外部函数中的变量。 另可知，闭包及嵌套函数执行顺序为，内部函数只会被定义，只有当内部函数被调用时才执行其内部代码。 装饰器示例 def add_tag(func): def add_func(*args,**kwargs): return f' {func(*args,**kwargs)}' return add_func def print_text(name): return f'{name}' @add_tag def print_text2(name): return f'{name}' print(add_tag(print_text)('wxz')) print(print_text2('wxz')) # wxz # wxz print(print_text3.__name__) # add_func add_tag(print_text)(‘wxz’)和print_text2(‘wxz’)是等价的，装饰器实际就是嵌套函数（吗？其实还是有些不一样，见下面）。 另外可以看到执行func.__name__返回的是装饰器内的add_func方法名，原因是 add_func 覆写了 print_text3 函数的 name、doc、modual 三个属性。改回来的话可以使用Python 中的 functools.wraps 装饰器，如下面的代码。 带参数的装饰器示例 def add_anytag(tagname): def add_tag(func): @wraps(func) def add_func(*args, **kwargs): return f' {func(*args, **kwargs)} ' return add_func return add_tag def print_text33(name): return f'{name}' @add_anytag(tagname='div') def print_text3(name): return f'{name}' print(add_anytag('div')(print_text33)('baba')) print(print_text3('wxz')) # baba # wxz print(print_text3.__name__) # print_text3 add_anytag(‘div’)(print_text33)(‘baba’)和print_text3(‘wxz’)效果也是等价的。 如果想直接访问原始的无装饰器的函数怎么办？装饰器到底是什么 def real_decorator(func): print('【装饰器】：当装饰器被定义时我就会被加载。') def inner_decorator(*args, **kwargs): print('【装饰器】：func执行前调用') func() print('【装饰器】：func执行后调用') return inner_decorator print('func定义前我会打印出来') @real_decorator def test_decorator(): print('【func】：我是func') print('func定义后我会打印出来') test_decorator() print('func执行后我会打印出来') # func定义前我会打印出来 # 【装饰器】：当装饰器被定义时我就会被加载。 # func定义后我会打印出来 # 【装饰器】：func执行前调用 # 【func】：我是func # 【装饰器】：func执行后调用 # func执行后我会打印出来 由上面可见，装饰器real_decorator在被定义到test_decorator头上时就被执行了。它的本质相当于执行下面这行代码 # 定义一个变量do_real_decorator do_real_decorator = real_decorator(test_decorator) 所以real_decorator里面的print在test_decorator执行前就执行了。下面看下多个装饰器的情况。 多个装饰器 def set_func1(func): print('外壁巴布1') def wrapper1(*args,**kwargs): print('装饰内容开始1') func(*args, **kwargs) print('装饰内容结束1') print('外壁巴布11') return wrapper1 # 定义第二个装饰器 def set_func2(func): print('外壁巴布2') def wrapper2(*args,**kwargs): print('装饰内容开始2') func(*args, **kwargs) print('装饰内容结束2') print('外壁巴布22') return wrapper2 # 定义第二个装饰器 def set_func3(func): print('外壁巴布3') def wrapper3(*args,**kwargs): print('装饰内容开始3') func(*args, **kwargs) print('装饰内容结束3') print('外壁巴布33') return wrapper3 @set_func1 @set_func2 @set_func3 def show(): print('Show Run....') def show2(): print('show run2') print('》》》》》》》》》》》》》》》》》我是分割线，免得你看懵逼了') show() # 外壁巴布3 # 外壁巴布33 # 外壁巴布2 # 外壁巴布22 # 外壁巴布1 # 外壁巴布11 # 》》》》》》》》》》》》》》》》》我是分割线，免得你看懵逼了 # 装饰内容开始1 # 装饰内容开始2 # 装饰内容开始3 # Show Run.... # 装饰内容结束3 # 装饰内容结束2 # 装饰内容结束1 可见，多个装饰器被定义的顺序是从下到上，转换成嵌套函数则是，最下层是最内层。 set_func1(set_func2(set_func3(show2)))() 和 show() 是等价的。 def show2(): print('show run2') set_func1(set_func2(set_func3(show2)))() # 外壁巴布3 # 外壁巴布33 # 外壁巴布2 # 外壁巴布22 # 外壁巴布1 # 外壁巴布11 # 装饰内容开始1 # 装饰内容开始2 # 装饰内容开始3 # show run2 # 装饰内容结束3 # 装饰内容结束2 # 装饰内容结束1 ","date":"2019-06-30","objectID":"/blog/python%E5%B5%8C%E5%A5%97%E5%87%BD%E6%95%B0%E9%97%AD%E5%8C%85%E8%A3%85%E9%A5%B0%E5%99%A8/:0:0","series":[],"tags":[],"title":"Python嵌套函数、闭包、装饰器","uri":"/blog/python%E5%B5%8C%E5%A5%97%E5%87%BD%E6%95%B0%E9%97%AD%E5%8C%85%E8%A3%85%E9%A5%B0%E5%99%A8/#装饰器示例"},{"categories":["python"],"content":"嵌套函数的调用示例 def func1(a1): def func2(a2): def func3(a3): print(f'{a1},{a2},{a3}') return func3 return func2 func1(1)(2)(3) # 1,2,3 闭包示例 def func1(): def func2(a2): def func3(a3): print(f'{a2},{a3}') print(\"func3\") print(func3.__closure__) return func3 print(\"func2\") print(func2.__closure__) return func2 print(func1.__closure__) func1()(2)(3) # None # func2 # None # func3 # (,) # 2,3 函数名.__closure__ 在函数是闭包函数时，返回一个cell元素；不是闭包时，返回None。上例中func1、func2都不是闭包，func3是闭包，区别在于func3中引入了func2中的变量，可见闭包的特点就是内部函数引用了外部函数中的变量。 另可知，闭包及嵌套函数执行顺序为，内部函数只会被定义，只有当内部函数被调用时才执行其内部代码。 装饰器示例 def add_tag(func): def add_func(*args,**kwargs): return f' {func(*args,**kwargs)}' return add_func def print_text(name): return f'{name}' @add_tag def print_text2(name): return f'{name}' print(add_tag(print_text)('wxz')) print(print_text2('wxz')) # wxz # wxz print(print_text3.__name__) # add_func add_tag(print_text)(‘wxz’)和print_text2(‘wxz’)是等价的，装饰器实际就是嵌套函数（吗？其实还是有些不一样，见下面）。 另外可以看到执行func.__name__返回的是装饰器内的add_func方法名，原因是 add_func 覆写了 print_text3 函数的 name、doc、modual 三个属性。改回来的话可以使用Python 中的 functools.wraps 装饰器，如下面的代码。 带参数的装饰器示例 def add_anytag(tagname): def add_tag(func): @wraps(func) def add_func(*args, **kwargs): return f' {func(*args, **kwargs)} ' return add_func return add_tag def print_text33(name): return f'{name}' @add_anytag(tagname='div') def print_text3(name): return f'{name}' print(add_anytag('div')(print_text33)('baba')) print(print_text3('wxz')) # baba # wxz print(print_text3.__name__) # print_text3 add_anytag(‘div’)(print_text33)(‘baba’)和print_text3(‘wxz’)效果也是等价的。 如果想直接访问原始的无装饰器的函数怎么办？装饰器到底是什么 def real_decorator(func): print('【装饰器】：当装饰器被定义时我就会被加载。') def inner_decorator(*args, **kwargs): print('【装饰器】：func执行前调用') func() print('【装饰器】：func执行后调用') return inner_decorator print('func定义前我会打印出来') @real_decorator def test_decorator(): print('【func】：我是func') print('func定义后我会打印出来') test_decorator() print('func执行后我会打印出来') # func定义前我会打印出来 # 【装饰器】：当装饰器被定义时我就会被加载。 # func定义后我会打印出来 # 【装饰器】：func执行前调用 # 【func】：我是func # 【装饰器】：func执行后调用 # func执行后我会打印出来 由上面可见，装饰器real_decorator在被定义到test_decorator头上时就被执行了。它的本质相当于执行下面这行代码 # 定义一个变量do_real_decorator do_real_decorator = real_decorator(test_decorator) 所以real_decorator里面的print在test_decorator执行前就执行了。下面看下多个装饰器的情况。 多个装饰器 def set_func1(func): print('外壁巴布1') def wrapper1(*args,**kwargs): print('装饰内容开始1') func(*args, **kwargs) print('装饰内容结束1') print('外壁巴布11') return wrapper1 # 定义第二个装饰器 def set_func2(func): print('外壁巴布2') def wrapper2(*args,**kwargs): print('装饰内容开始2') func(*args, **kwargs) print('装饰内容结束2') print('外壁巴布22') return wrapper2 # 定义第二个装饰器 def set_func3(func): print('外壁巴布3') def wrapper3(*args,**kwargs): print('装饰内容开始3') func(*args, **kwargs) print('装饰内容结束3') print('外壁巴布33') return wrapper3 @set_func1 @set_func2 @set_func3 def show(): print('Show Run....') def show2(): print('show run2') print('》》》》》》》》》》》》》》》》》我是分割线，免得你看懵逼了') show() # 外壁巴布3 # 外壁巴布33 # 外壁巴布2 # 外壁巴布22 # 外壁巴布1 # 外壁巴布11 # 》》》》》》》》》》》》》》》》》我是分割线，免得你看懵逼了 # 装饰内容开始1 # 装饰内容开始2 # 装饰内容开始3 # Show Run.... # 装饰内容结束3 # 装饰内容结束2 # 装饰内容结束1 可见，多个装饰器被定义的顺序是从下到上，转换成嵌套函数则是，最下层是最内层。 set_func1(set_func2(set_func3(show2)))() 和 show() 是等价的。 def show2(): print('show run2') set_func1(set_func2(set_func3(show2)))() # 外壁巴布3 # 外壁巴布33 # 外壁巴布2 # 外壁巴布22 # 外壁巴布1 # 外壁巴布11 # 装饰内容开始1 # 装饰内容开始2 # 装饰内容开始3 # show run2 # 装饰内容结束3 # 装饰内容结束2 # 装饰内容结束1 ","date":"2019-06-30","objectID":"/blog/python%E5%B5%8C%E5%A5%97%E5%87%BD%E6%95%B0%E9%97%AD%E5%8C%85%E8%A3%85%E9%A5%B0%E5%99%A8/:0:0","series":[],"tags":[],"title":"Python嵌套函数、闭包、装饰器","uri":"/blog/python%E5%B5%8C%E5%A5%97%E5%87%BD%E6%95%B0%E9%97%AD%E5%8C%85%E8%A3%85%E9%A5%B0%E5%99%A8/#带参数的装饰器示例"},{"categories":["python"],"content":"嵌套函数的调用示例 def func1(a1): def func2(a2): def func3(a3): print(f'{a1},{a2},{a3}') return func3 return func2 func1(1)(2)(3) # 1,2,3 闭包示例 def func1(): def func2(a2): def func3(a3): print(f'{a2},{a3}') print(\"func3\") print(func3.__closure__) return func3 print(\"func2\") print(func2.__closure__) return func2 print(func1.__closure__) func1()(2)(3) # None # func2 # None # func3 # (,) # 2,3 函数名.__closure__ 在函数是闭包函数时，返回一个cell元素；不是闭包时，返回None。上例中func1、func2都不是闭包，func3是闭包，区别在于func3中引入了func2中的变量，可见闭包的特点就是内部函数引用了外部函数中的变量。 另可知，闭包及嵌套函数执行顺序为，内部函数只会被定义，只有当内部函数被调用时才执行其内部代码。 装饰器示例 def add_tag(func): def add_func(*args,**kwargs): return f' {func(*args,**kwargs)}' return add_func def print_text(name): return f'{name}' @add_tag def print_text2(name): return f'{name}' print(add_tag(print_text)('wxz')) print(print_text2('wxz')) # wxz # wxz print(print_text3.__name__) # add_func add_tag(print_text)(‘wxz’)和print_text2(‘wxz’)是等价的，装饰器实际就是嵌套函数（吗？其实还是有些不一样，见下面）。 另外可以看到执行func.__name__返回的是装饰器内的add_func方法名，原因是 add_func 覆写了 print_text3 函数的 name、doc、modual 三个属性。改回来的话可以使用Python 中的 functools.wraps 装饰器，如下面的代码。 带参数的装饰器示例 def add_anytag(tagname): def add_tag(func): @wraps(func) def add_func(*args, **kwargs): return f' {func(*args, **kwargs)} ' return add_func return add_tag def print_text33(name): return f'{name}' @add_anytag(tagname='div') def print_text3(name): return f'{name}' print(add_anytag('div')(print_text33)('baba')) print(print_text3('wxz')) # baba # wxz print(print_text3.__name__) # print_text3 add_anytag(‘div’)(print_text33)(‘baba’)和print_text3(‘wxz’)效果也是等价的。 如果想直接访问原始的无装饰器的函数怎么办？装饰器到底是什么 def real_decorator(func): print('【装饰器】：当装饰器被定义时我就会被加载。') def inner_decorator(*args, **kwargs): print('【装饰器】：func执行前调用') func() print('【装饰器】：func执行后调用') return inner_decorator print('func定义前我会打印出来') @real_decorator def test_decorator(): print('【func】：我是func') print('func定义后我会打印出来') test_decorator() print('func执行后我会打印出来') # func定义前我会打印出来 # 【装饰器】：当装饰器被定义时我就会被加载。 # func定义后我会打印出来 # 【装饰器】：func执行前调用 # 【func】：我是func # 【装饰器】：func执行后调用 # func执行后我会打印出来 由上面可见，装饰器real_decorator在被定义到test_decorator头上时就被执行了。它的本质相当于执行下面这行代码 # 定义一个变量do_real_decorator do_real_decorator = real_decorator(test_decorator) 所以real_decorator里面的print在test_decorator执行前就执行了。下面看下多个装饰器的情况。 多个装饰器 def set_func1(func): print('外壁巴布1') def wrapper1(*args,**kwargs): print('装饰内容开始1') func(*args, **kwargs) print('装饰内容结束1') print('外壁巴布11') return wrapper1 # 定义第二个装饰器 def set_func2(func): print('外壁巴布2') def wrapper2(*args,**kwargs): print('装饰内容开始2') func(*args, **kwargs) print('装饰内容结束2') print('外壁巴布22') return wrapper2 # 定义第二个装饰器 def set_func3(func): print('外壁巴布3') def wrapper3(*args,**kwargs): print('装饰内容开始3') func(*args, **kwargs) print('装饰内容结束3') print('外壁巴布33') return wrapper3 @set_func1 @set_func2 @set_func3 def show(): print('Show Run....') def show2(): print('show run2') print('》》》》》》》》》》》》》》》》》我是分割线，免得你看懵逼了') show() # 外壁巴布3 # 外壁巴布33 # 外壁巴布2 # 外壁巴布22 # 外壁巴布1 # 外壁巴布11 # 》》》》》》》》》》》》》》》》》我是分割线，免得你看懵逼了 # 装饰内容开始1 # 装饰内容开始2 # 装饰内容开始3 # Show Run.... # 装饰内容结束3 # 装饰内容结束2 # 装饰内容结束1 可见，多个装饰器被定义的顺序是从下到上，转换成嵌套函数则是，最下层是最内层。 set_func1(set_func2(set_func3(show2)))() 和 show() 是等价的。 def show2(): print('show run2') set_func1(set_func2(set_func3(show2)))() # 外壁巴布3 # 外壁巴布33 # 外壁巴布2 # 外壁巴布22 # 外壁巴布1 # 外壁巴布11 # 装饰内容开始1 # 装饰内容开始2 # 装饰内容开始3 # show run2 # 装饰内容结束3 # 装饰内容结束2 # 装饰内容结束1 ","date":"2019-06-30","objectID":"/blog/python%E5%B5%8C%E5%A5%97%E5%87%BD%E6%95%B0%E9%97%AD%E5%8C%85%E8%A3%85%E9%A5%B0%E5%99%A8/:0:0","series":[],"tags":[],"title":"Python嵌套函数、闭包、装饰器","uri":"/blog/python%E5%B5%8C%E5%A5%97%E5%87%BD%E6%95%B0%E9%97%AD%E5%8C%85%E8%A3%85%E9%A5%B0%E5%99%A8/#如果想直接访问原始的无装饰器的函数怎么办httpspython3-cookbookreadthedocsiozh_cnlatestc09p03_unwrapping_decoratorhtml"},{"categories":["python"],"content":"嵌套函数的调用示例 def func1(a1): def func2(a2): def func3(a3): print(f'{a1},{a2},{a3}') return func3 return func2 func1(1)(2)(3) # 1,2,3 闭包示例 def func1(): def func2(a2): def func3(a3): print(f'{a2},{a3}') print(\"func3\") print(func3.__closure__) return func3 print(\"func2\") print(func2.__closure__) return func2 print(func1.__closure__) func1()(2)(3) # None # func2 # None # func3 # (,) # 2,3 函数名.__closure__ 在函数是闭包函数时，返回一个cell元素；不是闭包时，返回None。上例中func1、func2都不是闭包，func3是闭包，区别在于func3中引入了func2中的变量，可见闭包的特点就是内部函数引用了外部函数中的变量。 另可知，闭包及嵌套函数执行顺序为，内部函数只会被定义，只有当内部函数被调用时才执行其内部代码。 装饰器示例 def add_tag(func): def add_func(*args,**kwargs): return f' {func(*args,**kwargs)}' return add_func def print_text(name): return f'{name}' @add_tag def print_text2(name): return f'{name}' print(add_tag(print_text)('wxz')) print(print_text2('wxz')) # wxz # wxz print(print_text3.__name__) # add_func add_tag(print_text)(‘wxz’)和print_text2(‘wxz’)是等价的，装饰器实际就是嵌套函数（吗？其实还是有些不一样，见下面）。 另外可以看到执行func.__name__返回的是装饰器内的add_func方法名，原因是 add_func 覆写了 print_text3 函数的 name、doc、modual 三个属性。改回来的话可以使用Python 中的 functools.wraps 装饰器，如下面的代码。 带参数的装饰器示例 def add_anytag(tagname): def add_tag(func): @wraps(func) def add_func(*args, **kwargs): return f' {func(*args, **kwargs)} ' return add_func return add_tag def print_text33(name): return f'{name}' @add_anytag(tagname='div') def print_text3(name): return f'{name}' print(add_anytag('div')(print_text33)('baba')) print(print_text3('wxz')) # baba # wxz print(print_text3.__name__) # print_text3 add_anytag(‘div’)(print_text33)(‘baba’)和print_text3(‘wxz’)效果也是等价的。 如果想直接访问原始的无装饰器的函数怎么办？装饰器到底是什么 def real_decorator(func): print('【装饰器】：当装饰器被定义时我就会被加载。') def inner_decorator(*args, **kwargs): print('【装饰器】：func执行前调用') func() print('【装饰器】：func执行后调用') return inner_decorator print('func定义前我会打印出来') @real_decorator def test_decorator(): print('【func】：我是func') print('func定义后我会打印出来') test_decorator() print('func执行后我会打印出来') # func定义前我会打印出来 # 【装饰器】：当装饰器被定义时我就会被加载。 # func定义后我会打印出来 # 【装饰器】：func执行前调用 # 【func】：我是func # 【装饰器】：func执行后调用 # func执行后我会打印出来 由上面可见，装饰器real_decorator在被定义到test_decorator头上时就被执行了。它的本质相当于执行下面这行代码 # 定义一个变量do_real_decorator do_real_decorator = real_decorator(test_decorator) 所以real_decorator里面的print在test_decorator执行前就执行了。下面看下多个装饰器的情况。 多个装饰器 def set_func1(func): print('外壁巴布1') def wrapper1(*args,**kwargs): print('装饰内容开始1') func(*args, **kwargs) print('装饰内容结束1') print('外壁巴布11') return wrapper1 # 定义第二个装饰器 def set_func2(func): print('外壁巴布2') def wrapper2(*args,**kwargs): print('装饰内容开始2') func(*args, **kwargs) print('装饰内容结束2') print('外壁巴布22') return wrapper2 # 定义第二个装饰器 def set_func3(func): print('外壁巴布3') def wrapper3(*args,**kwargs): print('装饰内容开始3') func(*args, **kwargs) print('装饰内容结束3') print('外壁巴布33') return wrapper3 @set_func1 @set_func2 @set_func3 def show(): print('Show Run....') def show2(): print('show run2') print('》》》》》》》》》》》》》》》》》我是分割线，免得你看懵逼了') show() # 外壁巴布3 # 外壁巴布33 # 外壁巴布2 # 外壁巴布22 # 外壁巴布1 # 外壁巴布11 # 》》》》》》》》》》》》》》》》》我是分割线，免得你看懵逼了 # 装饰内容开始1 # 装饰内容开始2 # 装饰内容开始3 # Show Run.... # 装饰内容结束3 # 装饰内容结束2 # 装饰内容结束1 可见，多个装饰器被定义的顺序是从下到上，转换成嵌套函数则是，最下层是最内层。 set_func1(set_func2(set_func3(show2)))() 和 show() 是等价的。 def show2(): print('show run2') set_func1(set_func2(set_func3(show2)))() # 外壁巴布3 # 外壁巴布33 # 外壁巴布2 # 外壁巴布22 # 外壁巴布1 # 外壁巴布11 # 装饰内容开始1 # 装饰内容开始2 # 装饰内容开始3 # show run2 # 装饰内容结束3 # 装饰内容结束2 # 装饰内容结束1 ","date":"2019-06-30","objectID":"/blog/python%E5%B5%8C%E5%A5%97%E5%87%BD%E6%95%B0%E9%97%AD%E5%8C%85%E8%A3%85%E9%A5%B0%E5%99%A8/:0:0","series":[],"tags":[],"title":"Python嵌套函数、闭包、装饰器","uri":"/blog/python%E5%B5%8C%E5%A5%97%E5%87%BD%E6%95%B0%E9%97%AD%E5%8C%85%E8%A3%85%E9%A5%B0%E5%99%A8/#装饰器到底是什么"},{"categories":["python"],"content":"嵌套函数的调用示例 def func1(a1): def func2(a2): def func3(a3): print(f'{a1},{a2},{a3}') return func3 return func2 func1(1)(2)(3) # 1,2,3 闭包示例 def func1(): def func2(a2): def func3(a3): print(f'{a2},{a3}') print(\"func3\") print(func3.__closure__) return func3 print(\"func2\") print(func2.__closure__) return func2 print(func1.__closure__) func1()(2)(3) # None # func2 # None # func3 # (,) # 2,3 函数名.__closure__ 在函数是闭包函数时，返回一个cell元素；不是闭包时，返回None。上例中func1、func2都不是闭包，func3是闭包，区别在于func3中引入了func2中的变量，可见闭包的特点就是内部函数引用了外部函数中的变量。 另可知，闭包及嵌套函数执行顺序为，内部函数只会被定义，只有当内部函数被调用时才执行其内部代码。 装饰器示例 def add_tag(func): def add_func(*args,**kwargs): return f' {func(*args,**kwargs)}' return add_func def print_text(name): return f'{name}' @add_tag def print_text2(name): return f'{name}' print(add_tag(print_text)('wxz')) print(print_text2('wxz')) # wxz # wxz print(print_text3.__name__) # add_func add_tag(print_text)(‘wxz’)和print_text2(‘wxz’)是等价的，装饰器实际就是嵌套函数（吗？其实还是有些不一样，见下面）。 另外可以看到执行func.__name__返回的是装饰器内的add_func方法名，原因是 add_func 覆写了 print_text3 函数的 name、doc、modual 三个属性。改回来的话可以使用Python 中的 functools.wraps 装饰器，如下面的代码。 带参数的装饰器示例 def add_anytag(tagname): def add_tag(func): @wraps(func) def add_func(*args, **kwargs): return f' {func(*args, **kwargs)} ' return add_func return add_tag def print_text33(name): return f'{name}' @add_anytag(tagname='div') def print_text3(name): return f'{name}' print(add_anytag('div')(print_text33)('baba')) print(print_text3('wxz')) # baba # wxz print(print_text3.__name__) # print_text3 add_anytag(‘div’)(print_text33)(‘baba’)和print_text3(‘wxz’)效果也是等价的。 如果想直接访问原始的无装饰器的函数怎么办？装饰器到底是什么 def real_decorator(func): print('【装饰器】：当装饰器被定义时我就会被加载。') def inner_decorator(*args, **kwargs): print('【装饰器】：func执行前调用') func() print('【装饰器】：func执行后调用') return inner_decorator print('func定义前我会打印出来') @real_decorator def test_decorator(): print('【func】：我是func') print('func定义后我会打印出来') test_decorator() print('func执行后我会打印出来') # func定义前我会打印出来 # 【装饰器】：当装饰器被定义时我就会被加载。 # func定义后我会打印出来 # 【装饰器】：func执行前调用 # 【func】：我是func # 【装饰器】：func执行后调用 # func执行后我会打印出来 由上面可见，装饰器real_decorator在被定义到test_decorator头上时就被执行了。它的本质相当于执行下面这行代码 # 定义一个变量do_real_decorator do_real_decorator = real_decorator(test_decorator) 所以real_decorator里面的print在test_decorator执行前就执行了。下面看下多个装饰器的情况。 多个装饰器 def set_func1(func): print('外壁巴布1') def wrapper1(*args,**kwargs): print('装饰内容开始1') func(*args, **kwargs) print('装饰内容结束1') print('外壁巴布11') return wrapper1 # 定义第二个装饰器 def set_func2(func): print('外壁巴布2') def wrapper2(*args,**kwargs): print('装饰内容开始2') func(*args, **kwargs) print('装饰内容结束2') print('外壁巴布22') return wrapper2 # 定义第二个装饰器 def set_func3(func): print('外壁巴布3') def wrapper3(*args,**kwargs): print('装饰内容开始3') func(*args, **kwargs) print('装饰内容结束3') print('外壁巴布33') return wrapper3 @set_func1 @set_func2 @set_func3 def show(): print('Show Run....') def show2(): print('show run2') print('》》》》》》》》》》》》》》》》》我是分割线，免得你看懵逼了') show() # 外壁巴布3 # 外壁巴布33 # 外壁巴布2 # 外壁巴布22 # 外壁巴布1 # 外壁巴布11 # 》》》》》》》》》》》》》》》》》我是分割线，免得你看懵逼了 # 装饰内容开始1 # 装饰内容开始2 # 装饰内容开始3 # Show Run.... # 装饰内容结束3 # 装饰内容结束2 # 装饰内容结束1 可见，多个装饰器被定义的顺序是从下到上，转换成嵌套函数则是，最下层是最内层。 set_func1(set_func2(set_func3(show2)))() 和 show() 是等价的。 def show2(): print('show run2') set_func1(set_func2(set_func3(show2)))() # 外壁巴布3 # 外壁巴布33 # 外壁巴布2 # 外壁巴布22 # 外壁巴布1 # 外壁巴布11 # 装饰内容开始1 # 装饰内容开始2 # 装饰内容开始3 # show run2 # 装饰内容结束3 # 装饰内容结束2 # 装饰内容结束1 ","date":"2019-06-30","objectID":"/blog/python%E5%B5%8C%E5%A5%97%E5%87%BD%E6%95%B0%E9%97%AD%E5%8C%85%E8%A3%85%E9%A5%B0%E5%99%A8/:0:0","series":[],"tags":[],"title":"Python嵌套函数、闭包、装饰器","uri":"/blog/python%E5%B5%8C%E5%A5%97%E5%87%BD%E6%95%B0%E9%97%AD%E5%8C%85%E8%A3%85%E9%A5%B0%E5%99%A8/#多个装饰器"},{"categories":["python"],"content":"代码： os.system( f'allure generate {file_path[\"report\"]}/data -o {file_path[\"report\"]}/html --clean') 控制台返回乱码，期望路径下未生成报告。 原因：pycharm的Global Encoding设置的utf-8，与操作系统不一致，改为GBK后ok了。 ","date":"2019-06-23","objectID":"/blog/pycharm%E7%94%9F%E6%88%90allureReport%E5%A4%B1%E8%B4%A5/:0:0","series":[],"tags":["allure report"],"title":"Pycharm生成allure report失败","uri":"/blog/pycharm%E7%94%9F%E6%88%90allureReport%E5%A4%B1%E8%B4%A5/#"},{"categories":["python"],"content":"code import logging import os import time project_dir = os.path.abspath(os.path.dirname(os.path.dirname(os.path.dirname(__file__)))) class CommonLog: \"\"\" 封装logging模块 \"\"\" def __init__(self, name=\"common_log\", level: logging = logging.INFO): \"\"\" 实例化logging :param name: 日志名称 :param level: 日志级别 \"\"\" # self.fmt = \"%(asctime)s %(name)s %(filename)s %(module)s %(funcName)s %(lineno)d %(message)s\" self.fmt = \"%(asctime)s [%(name)s] [%(filename)s] [%(levelname)s] [%(lineno)d] - %(message)s\" self.name = name self.level = level self.formatter = logging.Formatter(self.fmt) def create_logger(self): \"\"\" 创建一个logger，并设置日志级别 :return: \"\"\" logger = logging.getLogger(self.name) logger.setLevel(self.level) return logger def create_handle(self): \"\"\" 创建所需要的handel，并指定输出格式 :return: \"\"\" time_stamp = time.strftime('%Y%m%d%H%M%S', time.localtime(time.time())) log_folder = os.path.join(project_dir, \"run/log_report\") log_dir = os.path.join(log_folder, f\"{time_stamp}.log\") path = log_folder.strip() path = path.rstrip(\"\\\\\") path = path.rstrip(\"/\") # 判断路径是否存在 is_exists = os.path.exists(path) if not is_exists: try: os.makedirs(path) except Exception as e: print(e) file_write = logging.FileHandler(log_dir, encoding=\"utf-8\") file_write.setFormatter(self.formatter) file_write.setLevel(logging.DEBUG) file_print = logging.StreamHandler() file_print.setFormatter(self.formatter) file_print.setLevel(logging.DEBUG) return file_write, file_print def add_handle(self): \"\"\" 为handle添加日志处理器 :return: \"\"\" logger = self.create_logger() create_handle = self.create_handle() logger.addHandler(create_handle[0]) logger.addHandler(create_handle[1]) return logger logging模块的四大组件 组件 说明 loggers 提供应用程序代码直接使用的接口 handlers 用于将日志记录发送到指定的目的位置 filters 提供更细粒度的日志过滤功能，用于决定哪些日志记录将会被输出（其它的日志记录将会被忽略） formatters 用于控制日志信息的最终输出格式 logging.basicConfig()函数说明该方法用于为logging日志系统做一些基本配置，方法定义如下： logging.basicConfig(**kwargs) 该函数可接收的关键字参数如下： 参数名称 描述 filename 指定日志输出目标文件的文件名，指定该设置项后日志信心就不会被输出到控制台了 filemode 指定日志文件的打开模式，默认为’a'。需要注意的是，该选项要在filename指定时才有效 format 指定日志格式字符串，即指定日志输出时所包含的字段信息以及它们的顺序。logging模块定义的格式字段下面会列出。 datefmt 指定日期/时间格式。需要注意的是，该选项要在format中包含时间字段%(asctime)s时才有效 level 指定日志器的日志级别 stream 指定日志输出目标stream，如sys.stdout、sys.stderr以及网络stream。需要说明的是，stream和filename不能同时提供，否则会引发 ValueError异常 style Python 3.2中新添加的配置项。指定format格式字符串的风格，可取值为'%'、'{‘和’$'，默认为'%' handlers Python 3.3中新添加的配置项。该选项如果被指定，它应该是一个创建了多个Handler的可迭代对象，这些handler将会被添加到root logger。需要说明的是：filename、stream和handlers这三个配置项只能有一个存在，不能同时出现2个或3个，否则会引发ValueError异常。 logging模块定义的格式字符串字段我们来列举一下logging模块中定义好的可以用于format格式字符串中字段有哪些： 字段/属性名称 使用格式 描述 asctime %(asctime)s 日志事件发生的时间–人类可读时间，如：2003-07-08 16:49:45,896 created %(created)f 日志事件发生的时间–时间戳，就是当时调用time.time()函数返回的值 relativeCreated %(relativeCreated)d 日志事件发生的时间相对于logging模块加载时间的相对毫秒数（目前还不知道干嘛用的） msecs %(msecs)d 日志事件发生事件的毫秒部分 levelname %(levelname)s 该日志记录的文字形式的日志级别（‘DEBUG’, ‘INFO’, ‘WARNING’, ‘ERROR’, ‘CRITICAL’） levelno %(levelno)s 该日志记录的数字形式的日志级别（10, 20, 30, 40, 50） name %(name)s 所使用的日志器名称，默认是’root'，因为默认使用的是 rootLogger message %(message)s 日志记录的文本内容，通过 msg % args计算得到的 pathname %(pathname)s 调用日志记录函数的源码文件的全路径 filename %(filename)s pathname的文件名部分，包含文件后缀 module %(module)s filename的名称部分，不包含后缀 lineno %(lineno)d 调用日志记录函数的源代码所在的行号 funcName %(funcName)s 调用日志记录函数的函数名 process %(process)d 进程ID processName %(processName)s 进程名称，Python 3.1新增 thread %(thread)d 线程ID threadName %(thread)s 线程名称 logger.setLevel()和handler.setLevel()：logger.setLevel()必须设置，否则不生效。 logger.setLevel()的级别可设置DEBUG，handler.setLevel()设置INFO，则只对INFO生效，反之则不生效。 ","date":"2019-06-07","objectID":"/blog/PythonLogging/:0:0","series":[],"tags":[],"title":"Python Logging","uri":"/blog/PythonLogging/#"},{"categories":["python"],"content":"code import logging import os import time project_dir = os.path.abspath(os.path.dirname(os.path.dirname(os.path.dirname(__file__)))) class CommonLog: \"\"\" 封装logging模块 \"\"\" def __init__(self, name=\"common_log\", level: logging = logging.INFO): \"\"\" 实例化logging :param name: 日志名称 :param level: 日志级别 \"\"\" # self.fmt = \"%(asctime)s %(name)s %(filename)s %(module)s %(funcName)s %(lineno)d %(message)s\" self.fmt = \"%(asctime)s [%(name)s] [%(filename)s] [%(levelname)s] [%(lineno)d] - %(message)s\" self.name = name self.level = level self.formatter = logging.Formatter(self.fmt) def create_logger(self): \"\"\" 创建一个logger，并设置日志级别 :return: \"\"\" logger = logging.getLogger(self.name) logger.setLevel(self.level) return logger def create_handle(self): \"\"\" 创建所需要的handel，并指定输出格式 :return: \"\"\" time_stamp = time.strftime('%Y%m%d%H%M%S', time.localtime(time.time())) log_folder = os.path.join(project_dir, \"run/log_report\") log_dir = os.path.join(log_folder, f\"{time_stamp}.log\") path = log_folder.strip() path = path.rstrip(\"\\\\\") path = path.rstrip(\"/\") # 判断路径是否存在 is_exists = os.path.exists(path) if not is_exists: try: os.makedirs(path) except Exception as e: print(e) file_write = logging.FileHandler(log_dir, encoding=\"utf-8\") file_write.setFormatter(self.formatter) file_write.setLevel(logging.DEBUG) file_print = logging.StreamHandler() file_print.setFormatter(self.formatter) file_print.setLevel(logging.DEBUG) return file_write, file_print def add_handle(self): \"\"\" 为handle添加日志处理器 :return: \"\"\" logger = self.create_logger() create_handle = self.create_handle() logger.addHandler(create_handle[0]) logger.addHandler(create_handle[1]) return logger logging模块的四大组件 组件 说明 loggers 提供应用程序代码直接使用的接口 handlers 用于将日志记录发送到指定的目的位置 filters 提供更细粒度的日志过滤功能，用于决定哪些日志记录将会被输出（其它的日志记录将会被忽略） formatters 用于控制日志信息的最终输出格式 logging.basicConfig()函数说明该方法用于为logging日志系统做一些基本配置，方法定义如下： logging.basicConfig(**kwargs) 该函数可接收的关键字参数如下： 参数名称 描述 filename 指定日志输出目标文件的文件名，指定该设置项后日志信心就不会被输出到控制台了 filemode 指定日志文件的打开模式，默认为’a'。需要注意的是，该选项要在filename指定时才有效 format 指定日志格式字符串，即指定日志输出时所包含的字段信息以及它们的顺序。logging模块定义的格式字段下面会列出。 datefmt 指定日期/时间格式。需要注意的是，该选项要在format中包含时间字段%(asctime)s时才有效 level 指定日志器的日志级别 stream 指定日志输出目标stream，如sys.stdout、sys.stderr以及网络stream。需要说明的是，stream和filename不能同时提供，否则会引发 ValueError异常 style Python 3.2中新添加的配置项。指定format格式字符串的风格，可取值为'%'、'{‘和’$'，默认为'%' handlers Python 3.3中新添加的配置项。该选项如果被指定，它应该是一个创建了多个Handler的可迭代对象，这些handler将会被添加到root logger。需要说明的是：filename、stream和handlers这三个配置项只能有一个存在，不能同时出现2个或3个，否则会引发ValueError异常。 logging模块定义的格式字符串字段我们来列举一下logging模块中定义好的可以用于format格式字符串中字段有哪些： 字段/属性名称 使用格式 描述 asctime %(asctime)s 日志事件发生的时间–人类可读时间，如：2003-07-08 16:49:45,896 created %(created)f 日志事件发生的时间–时间戳，就是当时调用time.time()函数返回的值 relativeCreated %(relativeCreated)d 日志事件发生的时间相对于logging模块加载时间的相对毫秒数（目前还不知道干嘛用的） msecs %(msecs)d 日志事件发生事件的毫秒部分 levelname %(levelname)s 该日志记录的文字形式的日志级别（‘DEBUG’, ‘INFO’, ‘WARNING’, ‘ERROR’, ‘CRITICAL’） levelno %(levelno)s 该日志记录的数字形式的日志级别（10, 20, 30, 40, 50） name %(name)s 所使用的日志器名称，默认是’root'，因为默认使用的是 rootLogger message %(message)s 日志记录的文本内容，通过 msg % args计算得到的 pathname %(pathname)s 调用日志记录函数的源码文件的全路径 filename %(filename)s pathname的文件名部分，包含文件后缀 module %(module)s filename的名称部分，不包含后缀 lineno %(lineno)d 调用日志记录函数的源代码所在的行号 funcName %(funcName)s 调用日志记录函数的函数名 process %(process)d 进程ID processName %(processName)s 进程名称，Python 3.1新增 thread %(thread)d 线程ID threadName %(thread)s 线程名称 logger.setLevel()和handler.setLevel()：logger.setLevel()必须设置，否则不生效。 logger.setLevel()的级别可设置DEBUG，handler.setLevel()设置INFO，则只对INFO生效，反之则不生效。 ","date":"2019-06-07","objectID":"/blog/PythonLogging/:0:0","series":[],"tags":[],"title":"Python Logging","uri":"/blog/PythonLogging/#code"},{"categories":["python"],"content":"code import logging import os import time project_dir = os.path.abspath(os.path.dirname(os.path.dirname(os.path.dirname(__file__)))) class CommonLog: \"\"\" 封装logging模块 \"\"\" def __init__(self, name=\"common_log\", level: logging = logging.INFO): \"\"\" 实例化logging :param name: 日志名称 :param level: 日志级别 \"\"\" # self.fmt = \"%(asctime)s %(name)s %(filename)s %(module)s %(funcName)s %(lineno)d %(message)s\" self.fmt = \"%(asctime)s [%(name)s] [%(filename)s] [%(levelname)s] [%(lineno)d] - %(message)s\" self.name = name self.level = level self.formatter = logging.Formatter(self.fmt) def create_logger(self): \"\"\" 创建一个logger，并设置日志级别 :return: \"\"\" logger = logging.getLogger(self.name) logger.setLevel(self.level) return logger def create_handle(self): \"\"\" 创建所需要的handel，并指定输出格式 :return: \"\"\" time_stamp = time.strftime('%Y%m%d%H%M%S', time.localtime(time.time())) log_folder = os.path.join(project_dir, \"run/log_report\") log_dir = os.path.join(log_folder, f\"{time_stamp}.log\") path = log_folder.strip() path = path.rstrip(\"\\\\\") path = path.rstrip(\"/\") # 判断路径是否存在 is_exists = os.path.exists(path) if not is_exists: try: os.makedirs(path) except Exception as e: print(e) file_write = logging.FileHandler(log_dir, encoding=\"utf-8\") file_write.setFormatter(self.formatter) file_write.setLevel(logging.DEBUG) file_print = logging.StreamHandler() file_print.setFormatter(self.formatter) file_print.setLevel(logging.DEBUG) return file_write, file_print def add_handle(self): \"\"\" 为handle添加日志处理器 :return: \"\"\" logger = self.create_logger() create_handle = self.create_handle() logger.addHandler(create_handle[0]) logger.addHandler(create_handle[1]) return logger logging模块的四大组件 组件 说明 loggers 提供应用程序代码直接使用的接口 handlers 用于将日志记录发送到指定的目的位置 filters 提供更细粒度的日志过滤功能，用于决定哪些日志记录将会被输出（其它的日志记录将会被忽略） formatters 用于控制日志信息的最终输出格式 logging.basicConfig()函数说明该方法用于为logging日志系统做一些基本配置，方法定义如下： logging.basicConfig(**kwargs) 该函数可接收的关键字参数如下： 参数名称 描述 filename 指定日志输出目标文件的文件名，指定该设置项后日志信心就不会被输出到控制台了 filemode 指定日志文件的打开模式，默认为’a'。需要注意的是，该选项要在filename指定时才有效 format 指定日志格式字符串，即指定日志输出时所包含的字段信息以及它们的顺序。logging模块定义的格式字段下面会列出。 datefmt 指定日期/时间格式。需要注意的是，该选项要在format中包含时间字段%(asctime)s时才有效 level 指定日志器的日志级别 stream 指定日志输出目标stream，如sys.stdout、sys.stderr以及网络stream。需要说明的是，stream和filename不能同时提供，否则会引发 ValueError异常 style Python 3.2中新添加的配置项。指定format格式字符串的风格，可取值为'%'、'{‘和’$'，默认为'%' handlers Python 3.3中新添加的配置项。该选项如果被指定，它应该是一个创建了多个Handler的可迭代对象，这些handler将会被添加到root logger。需要说明的是：filename、stream和handlers这三个配置项只能有一个存在，不能同时出现2个或3个，否则会引发ValueError异常。 logging模块定义的格式字符串字段我们来列举一下logging模块中定义好的可以用于format格式字符串中字段有哪些： 字段/属性名称 使用格式 描述 asctime %(asctime)s 日志事件发生的时间–人类可读时间，如：2003-07-08 16:49:45,896 created %(created)f 日志事件发生的时间–时间戳，就是当时调用time.time()函数返回的值 relativeCreated %(relativeCreated)d 日志事件发生的时间相对于logging模块加载时间的相对毫秒数（目前还不知道干嘛用的） msecs %(msecs)d 日志事件发生事件的毫秒部分 levelname %(levelname)s 该日志记录的文字形式的日志级别（‘DEBUG’, ‘INFO’, ‘WARNING’, ‘ERROR’, ‘CRITICAL’） levelno %(levelno)s 该日志记录的数字形式的日志级别（10, 20, 30, 40, 50） name %(name)s 所使用的日志器名称，默认是’root'，因为默认使用的是 rootLogger message %(message)s 日志记录的文本内容，通过 msg % args计算得到的 pathname %(pathname)s 调用日志记录函数的源码文件的全路径 filename %(filename)s pathname的文件名部分，包含文件后缀 module %(module)s filename的名称部分，不包含后缀 lineno %(lineno)d 调用日志记录函数的源代码所在的行号 funcName %(funcName)s 调用日志记录函数的函数名 process %(process)d 进程ID processName %(processName)s 进程名称，Python 3.1新增 thread %(thread)d 线程ID threadName %(thread)s 线程名称 logger.setLevel()和handler.setLevel()：logger.setLevel()必须设置，否则不生效。 logger.setLevel()的级别可设置DEBUG，handler.setLevel()设置INFO，则只对INFO生效，反之则不生效。 ","date":"2019-06-07","objectID":"/blog/PythonLogging/:0:0","series":[],"tags":[],"title":"Python Logging","uri":"/blog/PythonLogging/#logging模块的四大组件"},{"categories":["python"],"content":"code import logging import os import time project_dir = os.path.abspath(os.path.dirname(os.path.dirname(os.path.dirname(__file__)))) class CommonLog: \"\"\" 封装logging模块 \"\"\" def __init__(self, name=\"common_log\", level: logging = logging.INFO): \"\"\" 实例化logging :param name: 日志名称 :param level: 日志级别 \"\"\" # self.fmt = \"%(asctime)s %(name)s %(filename)s %(module)s %(funcName)s %(lineno)d %(message)s\" self.fmt = \"%(asctime)s [%(name)s] [%(filename)s] [%(levelname)s] [%(lineno)d] - %(message)s\" self.name = name self.level = level self.formatter = logging.Formatter(self.fmt) def create_logger(self): \"\"\" 创建一个logger，并设置日志级别 :return: \"\"\" logger = logging.getLogger(self.name) logger.setLevel(self.level) return logger def create_handle(self): \"\"\" 创建所需要的handel，并指定输出格式 :return: \"\"\" time_stamp = time.strftime('%Y%m%d%H%M%S', time.localtime(time.time())) log_folder = os.path.join(project_dir, \"run/log_report\") log_dir = os.path.join(log_folder, f\"{time_stamp}.log\") path = log_folder.strip() path = path.rstrip(\"\\\\\") path = path.rstrip(\"/\") # 判断路径是否存在 is_exists = os.path.exists(path) if not is_exists: try: os.makedirs(path) except Exception as e: print(e) file_write = logging.FileHandler(log_dir, encoding=\"utf-8\") file_write.setFormatter(self.formatter) file_write.setLevel(logging.DEBUG) file_print = logging.StreamHandler() file_print.setFormatter(self.formatter) file_print.setLevel(logging.DEBUG) return file_write, file_print def add_handle(self): \"\"\" 为handle添加日志处理器 :return: \"\"\" logger = self.create_logger() create_handle = self.create_handle() logger.addHandler(create_handle[0]) logger.addHandler(create_handle[1]) return logger logging模块的四大组件 组件 说明 loggers 提供应用程序代码直接使用的接口 handlers 用于将日志记录发送到指定的目的位置 filters 提供更细粒度的日志过滤功能，用于决定哪些日志记录将会被输出（其它的日志记录将会被忽略） formatters 用于控制日志信息的最终输出格式 logging.basicConfig()函数说明该方法用于为logging日志系统做一些基本配置，方法定义如下： logging.basicConfig(**kwargs) 该函数可接收的关键字参数如下： 参数名称 描述 filename 指定日志输出目标文件的文件名，指定该设置项后日志信心就不会被输出到控制台了 filemode 指定日志文件的打开模式，默认为’a'。需要注意的是，该选项要在filename指定时才有效 format 指定日志格式字符串，即指定日志输出时所包含的字段信息以及它们的顺序。logging模块定义的格式字段下面会列出。 datefmt 指定日期/时间格式。需要注意的是，该选项要在format中包含时间字段%(asctime)s时才有效 level 指定日志器的日志级别 stream 指定日志输出目标stream，如sys.stdout、sys.stderr以及网络stream。需要说明的是，stream和filename不能同时提供，否则会引发 ValueError异常 style Python 3.2中新添加的配置项。指定format格式字符串的风格，可取值为'%'、'{‘和’$'，默认为'%' handlers Python 3.3中新添加的配置项。该选项如果被指定，它应该是一个创建了多个Handler的可迭代对象，这些handler将会被添加到root logger。需要说明的是：filename、stream和handlers这三个配置项只能有一个存在，不能同时出现2个或3个，否则会引发ValueError异常。 logging模块定义的格式字符串字段我们来列举一下logging模块中定义好的可以用于format格式字符串中字段有哪些： 字段/属性名称 使用格式 描述 asctime %(asctime)s 日志事件发生的时间–人类可读时间，如：2003-07-08 16:49:45,896 created %(created)f 日志事件发生的时间–时间戳，就是当时调用time.time()函数返回的值 relativeCreated %(relativeCreated)d 日志事件发生的时间相对于logging模块加载时间的相对毫秒数（目前还不知道干嘛用的） msecs %(msecs)d 日志事件发生事件的毫秒部分 levelname %(levelname)s 该日志记录的文字形式的日志级别（‘DEBUG’, ‘INFO’, ‘WARNING’, ‘ERROR’, ‘CRITICAL’） levelno %(levelno)s 该日志记录的数字形式的日志级别（10, 20, 30, 40, 50） name %(name)s 所使用的日志器名称，默认是’root'，因为默认使用的是 rootLogger message %(message)s 日志记录的文本内容，通过 msg % args计算得到的 pathname %(pathname)s 调用日志记录函数的源码文件的全路径 filename %(filename)s pathname的文件名部分，包含文件后缀 module %(module)s filename的名称部分，不包含后缀 lineno %(lineno)d 调用日志记录函数的源代码所在的行号 funcName %(funcName)s 调用日志记录函数的函数名 process %(process)d 进程ID processName %(processName)s 进程名称，Python 3.1新增 thread %(thread)d 线程ID threadName %(thread)s 线程名称 logger.setLevel()和handler.setLevel()：logger.setLevel()必须设置，否则不生效。 logger.setLevel()的级别可设置DEBUG，handler.setLevel()设置INFO，则只对INFO生效，反之则不生效。 ","date":"2019-06-07","objectID":"/blog/PythonLogging/:0:0","series":[],"tags":[],"title":"Python Logging","uri":"/blog/PythonLogging/#loggingbasicconfig函数说明"},{"categories":["python"],"content":"code import logging import os import time project_dir = os.path.abspath(os.path.dirname(os.path.dirname(os.path.dirname(__file__)))) class CommonLog: \"\"\" 封装logging模块 \"\"\" def __init__(self, name=\"common_log\", level: logging = logging.INFO): \"\"\" 实例化logging :param name: 日志名称 :param level: 日志级别 \"\"\" # self.fmt = \"%(asctime)s %(name)s %(filename)s %(module)s %(funcName)s %(lineno)d %(message)s\" self.fmt = \"%(asctime)s [%(name)s] [%(filename)s] [%(levelname)s] [%(lineno)d] - %(message)s\" self.name = name self.level = level self.formatter = logging.Formatter(self.fmt) def create_logger(self): \"\"\" 创建一个logger，并设置日志级别 :return: \"\"\" logger = logging.getLogger(self.name) logger.setLevel(self.level) return logger def create_handle(self): \"\"\" 创建所需要的handel，并指定输出格式 :return: \"\"\" time_stamp = time.strftime('%Y%m%d%H%M%S', time.localtime(time.time())) log_folder = os.path.join(project_dir, \"run/log_report\") log_dir = os.path.join(log_folder, f\"{time_stamp}.log\") path = log_folder.strip() path = path.rstrip(\"\\\\\") path = path.rstrip(\"/\") # 判断路径是否存在 is_exists = os.path.exists(path) if not is_exists: try: os.makedirs(path) except Exception as e: print(e) file_write = logging.FileHandler(log_dir, encoding=\"utf-8\") file_write.setFormatter(self.formatter) file_write.setLevel(logging.DEBUG) file_print = logging.StreamHandler() file_print.setFormatter(self.formatter) file_print.setLevel(logging.DEBUG) return file_write, file_print def add_handle(self): \"\"\" 为handle添加日志处理器 :return: \"\"\" logger = self.create_logger() create_handle = self.create_handle() logger.addHandler(create_handle[0]) logger.addHandler(create_handle[1]) return logger logging模块的四大组件 组件 说明 loggers 提供应用程序代码直接使用的接口 handlers 用于将日志记录发送到指定的目的位置 filters 提供更细粒度的日志过滤功能，用于决定哪些日志记录将会被输出（其它的日志记录将会被忽略） formatters 用于控制日志信息的最终输出格式 logging.basicConfig()函数说明该方法用于为logging日志系统做一些基本配置，方法定义如下： logging.basicConfig(**kwargs) 该函数可接收的关键字参数如下： 参数名称 描述 filename 指定日志输出目标文件的文件名，指定该设置项后日志信心就不会被输出到控制台了 filemode 指定日志文件的打开模式，默认为’a'。需要注意的是，该选项要在filename指定时才有效 format 指定日志格式字符串，即指定日志输出时所包含的字段信息以及它们的顺序。logging模块定义的格式字段下面会列出。 datefmt 指定日期/时间格式。需要注意的是，该选项要在format中包含时间字段%(asctime)s时才有效 level 指定日志器的日志级别 stream 指定日志输出目标stream，如sys.stdout、sys.stderr以及网络stream。需要说明的是，stream和filename不能同时提供，否则会引发 ValueError异常 style Python 3.2中新添加的配置项。指定format格式字符串的风格，可取值为'%'、'{‘和’$'，默认为'%' handlers Python 3.3中新添加的配置项。该选项如果被指定，它应该是一个创建了多个Handler的可迭代对象，这些handler将会被添加到root logger。需要说明的是：filename、stream和handlers这三个配置项只能有一个存在，不能同时出现2个或3个，否则会引发ValueError异常。 logging模块定义的格式字符串字段我们来列举一下logging模块中定义好的可以用于format格式字符串中字段有哪些： 字段/属性名称 使用格式 描述 asctime %(asctime)s 日志事件发生的时间–人类可读时间，如：2003-07-08 16:49:45,896 created %(created)f 日志事件发生的时间–时间戳，就是当时调用time.time()函数返回的值 relativeCreated %(relativeCreated)d 日志事件发生的时间相对于logging模块加载时间的相对毫秒数（目前还不知道干嘛用的） msecs %(msecs)d 日志事件发生事件的毫秒部分 levelname %(levelname)s 该日志记录的文字形式的日志级别（‘DEBUG’, ‘INFO’, ‘WARNING’, ‘ERROR’, ‘CRITICAL’） levelno %(levelno)s 该日志记录的数字形式的日志级别（10, 20, 30, 40, 50） name %(name)s 所使用的日志器名称，默认是’root'，因为默认使用的是 rootLogger message %(message)s 日志记录的文本内容，通过 msg % args计算得到的 pathname %(pathname)s 调用日志记录函数的源码文件的全路径 filename %(filename)s pathname的文件名部分，包含文件后缀 module %(module)s filename的名称部分，不包含后缀 lineno %(lineno)d 调用日志记录函数的源代码所在的行号 funcName %(funcName)s 调用日志记录函数的函数名 process %(process)d 进程ID processName %(processName)s 进程名称，Python 3.1新增 thread %(thread)d 线程ID threadName %(thread)s 线程名称 logger.setLevel()和handler.setLevel()：logger.setLevel()必须设置，否则不生效。 logger.setLevel()的级别可设置DEBUG，handler.setLevel()设置INFO，则只对INFO生效，反之则不生效。 ","date":"2019-06-07","objectID":"/blog/PythonLogging/:0:0","series":[],"tags":[],"title":"Python Logging","uri":"/blog/PythonLogging/#logging模块定义的格式字符串字段"},{"categories":["python"],"content":"code import logging import os import time project_dir = os.path.abspath(os.path.dirname(os.path.dirname(os.path.dirname(__file__)))) class CommonLog: \"\"\" 封装logging模块 \"\"\" def __init__(self, name=\"common_log\", level: logging = logging.INFO): \"\"\" 实例化logging :param name: 日志名称 :param level: 日志级别 \"\"\" # self.fmt = \"%(asctime)s %(name)s %(filename)s %(module)s %(funcName)s %(lineno)d %(message)s\" self.fmt = \"%(asctime)s [%(name)s] [%(filename)s] [%(levelname)s] [%(lineno)d] - %(message)s\" self.name = name self.level = level self.formatter = logging.Formatter(self.fmt) def create_logger(self): \"\"\" 创建一个logger，并设置日志级别 :return: \"\"\" logger = logging.getLogger(self.name) logger.setLevel(self.level) return logger def create_handle(self): \"\"\" 创建所需要的handel，并指定输出格式 :return: \"\"\" time_stamp = time.strftime('%Y%m%d%H%M%S', time.localtime(time.time())) log_folder = os.path.join(project_dir, \"run/log_report\") log_dir = os.path.join(log_folder, f\"{time_stamp}.log\") path = log_folder.strip() path = path.rstrip(\"\\\\\") path = path.rstrip(\"/\") # 判断路径是否存在 is_exists = os.path.exists(path) if not is_exists: try: os.makedirs(path) except Exception as e: print(e) file_write = logging.FileHandler(log_dir, encoding=\"utf-8\") file_write.setFormatter(self.formatter) file_write.setLevel(logging.DEBUG) file_print = logging.StreamHandler() file_print.setFormatter(self.formatter) file_print.setLevel(logging.DEBUG) return file_write, file_print def add_handle(self): \"\"\" 为handle添加日志处理器 :return: \"\"\" logger = self.create_logger() create_handle = self.create_handle() logger.addHandler(create_handle[0]) logger.addHandler(create_handle[1]) return logger logging模块的四大组件 组件 说明 loggers 提供应用程序代码直接使用的接口 handlers 用于将日志记录发送到指定的目的位置 filters 提供更细粒度的日志过滤功能，用于决定哪些日志记录将会被输出（其它的日志记录将会被忽略） formatters 用于控制日志信息的最终输出格式 logging.basicConfig()函数说明该方法用于为logging日志系统做一些基本配置，方法定义如下： logging.basicConfig(**kwargs) 该函数可接收的关键字参数如下： 参数名称 描述 filename 指定日志输出目标文件的文件名，指定该设置项后日志信心就不会被输出到控制台了 filemode 指定日志文件的打开模式，默认为’a'。需要注意的是，该选项要在filename指定时才有效 format 指定日志格式字符串，即指定日志输出时所包含的字段信息以及它们的顺序。logging模块定义的格式字段下面会列出。 datefmt 指定日期/时间格式。需要注意的是，该选项要在format中包含时间字段%(asctime)s时才有效 level 指定日志器的日志级别 stream 指定日志输出目标stream，如sys.stdout、sys.stderr以及网络stream。需要说明的是，stream和filename不能同时提供，否则会引发 ValueError异常 style Python 3.2中新添加的配置项。指定format格式字符串的风格，可取值为'%'、'{‘和’$'，默认为'%' handlers Python 3.3中新添加的配置项。该选项如果被指定，它应该是一个创建了多个Handler的可迭代对象，这些handler将会被添加到root logger。需要说明的是：filename、stream和handlers这三个配置项只能有一个存在，不能同时出现2个或3个，否则会引发ValueError异常。 logging模块定义的格式字符串字段我们来列举一下logging模块中定义好的可以用于format格式字符串中字段有哪些： 字段/属性名称 使用格式 描述 asctime %(asctime)s 日志事件发生的时间–人类可读时间，如：2003-07-08 16:49:45,896 created %(created)f 日志事件发生的时间–时间戳，就是当时调用time.time()函数返回的值 relativeCreated %(relativeCreated)d 日志事件发生的时间相对于logging模块加载时间的相对毫秒数（目前还不知道干嘛用的） msecs %(msecs)d 日志事件发生事件的毫秒部分 levelname %(levelname)s 该日志记录的文字形式的日志级别（‘DEBUG’, ‘INFO’, ‘WARNING’, ‘ERROR’, ‘CRITICAL’） levelno %(levelno)s 该日志记录的数字形式的日志级别（10, 20, 30, 40, 50） name %(name)s 所使用的日志器名称，默认是’root'，因为默认使用的是 rootLogger message %(message)s 日志记录的文本内容，通过 msg % args计算得到的 pathname %(pathname)s 调用日志记录函数的源码文件的全路径 filename %(filename)s pathname的文件名部分，包含文件后缀 module %(module)s filename的名称部分，不包含后缀 lineno %(lineno)d 调用日志记录函数的源代码所在的行号 funcName %(funcName)s 调用日志记录函数的函数名 process %(process)d 进程ID processName %(processName)s 进程名称，Python 3.1新增 thread %(thread)d 线程ID threadName %(thread)s 线程名称 logger.setLevel()和handler.setLevel()：logger.setLevel()必须设置，否则不生效。 logger.setLevel()的级别可设置DEBUG，handler.setLevel()设置INFO，则只对INFO生效，反之则不生效。 ","date":"2019-06-07","objectID":"/blog/PythonLogging/:0:0","series":[],"tags":[],"title":"Python Logging","uri":"/blog/PythonLogging/#loggersetlevel和handlersetlevel"},{"categories":[],"content":"前言：本来想装个ELK，结果小服务器内存开销过大跑不动，本来也没什么日志可看，只好凑活着弄个es玩玩。 ","date":"2019-03-30","objectID":"/blog/Docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8elasticsearch/:0:0","series":[],"tags":["docker","es"],"title":"Docker安装部署使用elasticsearch","uri":"/blog/Docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8elasticsearch/#"},{"categories":[],"content":"一、Docker部署es及es-head # docker pull elasticsearch # docker run -d --name myES -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" elasticsearc 启动后发现服务器卡死了，使用docker stats查看容器CPU使用情况，发现ES容器占用了1.2G的内存，只能把它关掉。 1核2G的小服务器想部署ES必须要限制它的内存占用，所以启动时要加上限制内存的参数。 # ES较耗费内存 # ES的数据一般需要挂载到安全目录中，需要提前创建好“elasticsearch.yml”文件，如果直接运行命令会被当作文件夹创建 # docker run --name myES -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" -e ES_JAVA_OPTS=\"-Xms64m -Xmx256m\" -v /home/wxz/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v /home/wxz/elasticsearch/data:/usr/share/elasticsearch/data -v /home/wxz/elasticsearch/plugins:/usr/share/elasticsearch/plugins -d elasticsearch # 9200作为Http协议，主要用于外部通讯 # 9300作为Tcp协议，jar之间就是通过tcp协议通讯 # ES集群之间是通过9300进行通讯 # elasticsearch.yml是挂载的配置文件，data是挂载的数据，plugins是es的插件 创建成功，访问9200端口检查ES是否正常启动 检查容器的内存使用情况。docker stats ","date":"2019-03-30","objectID":"/blog/Docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8elasticsearch/:1:0","series":[],"tags":["docker","es"],"title":"Docker安装部署使用elasticsearch","uri":"/blog/Docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8elasticsearch/#一docker部署es及es-head"},{"categories":[],"content":"安装ElasticSearch Head # docker pull mobz/elasticsearch-head:5 # docker run -d --name ES-Head -p 9100:9100 mobz/elasticsearch-head:5 安装成功后访问http://IP:9100/，连接ES，发现连接失败，是因为有跨域问题，因为前后端分离开发的所以需要设置一下es配置。 # vim elasticsearch.yml # 添加以下内容解决跨域问题，其实就是SpringBoot的yml文件 添加跨域支持 http.cors.enabled: true http.cors.allow-origin: \"*\" # 退出容器并重启 # docker restart es 重新访问http://IP:9100/，连接ES，发现连接成功。 ","date":"2019-03-30","objectID":"/blog/Docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8elasticsearch/:1:1","series":[],"tags":["docker","es"],"title":"Docker安装部署使用elasticsearch","uri":"/blog/Docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8elasticsearch/#安装elasticsearch-head"},{"categories":[],"content":"二、es的基本概念","date":"2019-03-30","objectID":"/blog/Docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8elasticsearch/:2:0","series":[],"tags":["docker","es"],"title":"Docker安装部署使用elasticsearch","uri":"/blog/Docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8elasticsearch/#二es的基本概念"},{"categories":[],"content":"2.1 Node 与 ClusterElastic 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。 单个 Elastic 实例称为一个节点（node）。一组节点构成一个集群（cluster）。 ","date":"2019-03-30","objectID":"/blog/Docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8elasticsearch/:2:1","series":[],"tags":["docker","es"],"title":"Docker安装部署使用elasticsearch","uri":"/blog/Docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8elasticsearch/#21-node-与-cluster"},{"categories":[],"content":"2.2 IndexElastic 会索引所有字段，经过处理后写入一个反向索引（Inverted Index）。查找数据的时候，直接查找该索引。 所以，Elastic 数据管理的顶层单位就叫做 Index（索引）。它是单个数据库的同义词。每个 Index （即数据库）的名字必须是小写。 下面的命令可以查看当前节点的所有 Index。 $ curl -X GET 'http://localhost:9200/_cat/indices?v' ","date":"2019-03-30","objectID":"/blog/Docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8elasticsearch/:2:2","series":[],"tags":["docker","es"],"title":"Docker安装部署使用elasticsearch","uri":"/blog/Docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8elasticsearch/#22-index"},{"categories":[],"content":"2.3 DocumentIndex 里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。 Document 使用 JSON 格式表示，下面是一个例子。 { \"user\": \"张三\", \"title\": \"工程师\", \"desc\": \"数据库管理\" } 同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。 ","date":"2019-03-30","objectID":"/blog/Docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8elasticsearch/:2:3","series":[],"tags":["docker","es"],"title":"Docker安装部署使用elasticsearch","uri":"/blog/Docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8elasticsearch/#23-document"},{"categories":[],"content":"2.4 TypeDocument 可以分组，比如weather这个 Index 里面，可以按城市分组（北京和上海），也可以按气候分组（晴天和雨天）。这种分组就叫做 Type，它是虚拟的逻辑分组，用来过滤 Document。 不同的 Type 应该有相似的结构（schema），举例来说，id字段不能在这个组是字符串，在另一个组是数值。这是与关系型数据库的表的一个区别。性质完全不同的数据（比如products和logs）应该存成两个 Index，而不是一个 Index 里面的两个 Type（虽然可以做到）。 下面的命令可以列出每个 Index 所包含的 Type。 $ curl 'localhost:9200/_mapping?pretty=true' 根据规划，Elastic 6.x 版只允许每个 Index 包含一个 Type，7.x 版将会彻底移除 Type。 ","date":"2019-03-30","objectID":"/blog/Docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8elasticsearch/:2:4","series":[],"tags":["docker","es"],"title":"Docker安装部署使用elasticsearch","uri":"/blog/Docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8elasticsearch/#24-type"},{"categories":[],"content":"三、es数据操作命令 引用自： http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html https://www.elastic.co/guide/en/elasticsearch/reference/6.8/query-dsl.html ","date":"2019-03-30","objectID":"/blog/Docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8elasticsearch/:3:0","series":[],"tags":["docker","es"],"title":"Docker安装部署使用elasticsearch","uri":"/blog/Docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8elasticsearch/#三es数据操作命令"},{"categories":[],"content":"3.1 新建和删除 Index新建 Index，可以直接向 Elastic 服务器发出 PUT 请求。下面的例子是新建一个名叫weather的 Index。 $ curl -X PUT 'localhost:9200/weather' 服务器返回一个 JSON 对象，里面的acknowledged字段表示操作成功。 { \"acknowledged\":true, \"shards_acknowledged\":true } 然后，我们发出 DELETE 请求，删除这个 Index。 $ curl -X DELETE 'localhost:9200/weather' ","date":"2019-03-30","objectID":"/blog/Docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8elasticsearch/:3:1","series":[],"tags":["docker","es"],"title":"Docker安装部署使用elasticsearch","uri":"/blog/Docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8elasticsearch/#31-新建和删除-index"},{"categories":[],"content":"3.1 新增记录向指定的 /Index/Type 发送 PUT 请求，就可以在 Index 里面新增一条记录。比如，向/accounts/person发送请求，就可以新增一条人员记录。 $ curl -X PUT 'localhost:9200/accounts/person/1' -d ' { \"user\": \"张三\", \"title\": \"工程师\", \"desc\": \"数据库管理\" }' 服务器返回的 JSON 对象，会给出 Index、Type、Id、Version 等信息。 { \"_index\":\"accounts\", \"_type\":\"person\", \"_id\":\"1\", \"_version\":1, \"result\":\"created\", \"_shards\":{\"total\":2,\"successful\":1,\"failed\":0}, \"created\":true } 如果你仔细看，会发现请求路径是/accounts/person/1，最后的1是该条记录的 Id。它不一定是数字，任意字符串（比如abc）都可以。 新增记录的时候，也可以不指定 Id，这时要改成 POST 请求。 $ curl -X POST 'localhost:9200/accounts/person' -d ' { \"user\": \"李四\", \"title\": \"工程师\", \"desc\": \"系统管理\" }' 上面代码中，向/accounts/person发出一个 POST 请求，添加一个记录。这时，服务器返回的 JSON 对象里面，_id字段就是一个随机字符串。 { \"_index\":\"accounts\", \"_type\":\"person\", \"_id\":\"AV3qGfrC6jMbsbXb6k1p\", \"_version\":1, \"result\":\"created\", \"_shards\":{\"total\":2,\"successful\":1,\"failed\":0}, \"created\":true } 注意，如果没有先创建 Index（这个例子是accounts），直接执行上面的命令，Elastic 也不会报错，而是直接生成指定的 Index。所以，打字的时候要小心，不要写错 Index 的名称。 ","date":"2019-03-30","objectID":"/blog/Docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8elasticsearch/:3:2","series":[],"tags":["docker","es"],"title":"Docker安装部署使用elasticsearch","uri":"/blog/Docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8elasticsearch/#31-新增记录"},{"categories":[],"content":"3.2 查看记录向/Index/Type/Id发出 GET 请求，就可以查看这条记录。 $ curl 'localhost:9200/accounts/person/1?pretty=true' 上面代码请求查看/accounts/person/1这条记录，URL 的参数pretty=true表示以易读的格式返回。 返回的数据中，found字段表示查询成功，_source字段返回原始记录。 { \"_index\" : \"accounts\", \"_type\" : \"person\", \"_id\" : \"1\", \"_version\" : 1, \"found\" : true, \"_source\" : { \"user\" : \"张三\", \"title\" : \"工程师\", \"desc\" : \"数据库管理\" } } 如果 Id 不正确，就查不到数据，found字段就是false。 $ curl 'localhost:9200/weather/beijing/abc?pretty=true' { \"_index\" : \"accounts\", \"_type\" : \"person\", \"_id\" : \"abc\", \"found\" : false } ","date":"2019-03-30","objectID":"/blog/Docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8elasticsearch/:3:3","series":[],"tags":["docker","es"],"title":"Docker安装部署使用elasticsearch","uri":"/blog/Docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8elasticsearch/#32-查看记录"},{"categories":[],"content":"3.3 删除记录删除记录就是发出 DELETE 请求。 $ curl -X DELETE 'localhost:9200/accounts/person/1' 这里先不要删除这条记录，后面还要用到。 ","date":"2019-03-30","objectID":"/blog/Docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8elasticsearch/:3:4","series":[],"tags":["docker","es"],"title":"Docker安装部署使用elasticsearch","uri":"/blog/Docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8elasticsearch/#33-删除记录"},{"categories":[],"content":"3.4 更新记录更新记录就是使用 PUT 请求，重新发送一次数据。 $ curl -X PUT 'localhost:9200/accounts/person/1' -d ' { \"user\" : \"张三\", \"title\" : \"工程师\", \"desc\" : \"数据库管理，软件开发\" }' { \"_index\":\"accounts\", \"_type\":\"person\", \"_id\":\"1\", \"_version\":2, \"result\":\"updated\", \"_shards\":{\"total\":2,\"successful\":1,\"failed\":0}, \"created\":false } 上面代码中，我们将原始数据从\"数据库管理\"改成\"数据库管理，软件开发\"。 返回结果里面，有几个字段发生了变化。 \"_version\" : 2, \"result\" : \"updated\", \"created\" : false 可以看到，记录的 Id 没变，但是版本（version）从1变成2，操作类型（result）从created变成updated，created字段变成false，因为这次不是新建记录。 ","date":"2019-03-30","objectID":"/blog/Docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8elasticsearch/:3:5","series":[],"tags":["docker","es"],"title":"Docker安装部署使用elasticsearch","uri":"/blog/Docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8elasticsearch/#34-更新记录"},{"categories":[],"content":"3.5 返回所有记录使用 GET 方法，直接请求/Index/Type/_search，就会返回所有记录。 $ curl 'localhost:9200/accounts/person/_search' { \"took\":2, \"timed_out\":false, \"_shards\":{\"total\":5,\"successful\":5,\"failed\":0}, \"hits\":{ \"total\":2, \"max_score\":1.0, \"hits\":[ { \"_index\":\"accounts\", \"_type\":\"person\", \"_id\":\"AV3qGfrC6jMbsbXb6k1p\", \"_score\":1.0, \"_source\": { \"user\": \"李四\", \"title\": \"工程师\", \"desc\": \"系统管理\" } }, { \"_index\":\"accounts\", \"_type\":\"person\", \"_id\":\"1\", \"_score\":1.0, \"_source\": { \"user\" : \"张三\", \"title\" : \"工程师\", \"desc\" : \"数据库管理，软件开发\" } } ] } } 上面代码中，返回结果的 took字段表示该操作的耗时（单位为毫秒），timed_out字段表示是否超时，hits字段表示命中的记录，里面子字段的含义如下。 total：返回记录数，本例是2条。 max_score：最高的匹配程度，本例是1.0。 hits：返回的记录组成的数组。 返回的记录中，每条记录都有一个_score字段，表示匹配的程序，默认是按照这个字段降序排列。 ","date":"2019-03-30","objectID":"/blog/Docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8elasticsearch/:3:6","series":[],"tags":["docker","es"],"title":"Docker安装部署使用elasticsearch","uri":"/blog/Docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8elasticsearch/#35-返回所有记录"},{"categories":[],"content":"3.6 全文搜索Elastic 的查询非常特别，使用自己的查询语法，要求 GET 请求带有数据体。 $ curl 'localhost:9200/accounts/person/_search' -d ' { \"query\" : { \"match\" : { \"desc\" : \"软件\" }} }' 上面代码使用 Match 查询，指定的匹配条件是desc字段里面包含\"软件\"这个词。返回结果如下。 { \"took\":3, \"timed_out\":false, \"_shards\":{\"total\":5,\"successful\":5,\"failed\":0}, \"hits\":{ \"total\":1, \"max_score\":0.28582606, \"hits\":[ { \"_index\":\"accounts\", \"_type\":\"person\", \"_id\":\"1\", \"_score\":0.28582606, \"_source\": { \"user\" : \"张三\", \"title\" : \"工程师\", \"desc\" : \"数据库管理，软件开发\" } } ] } } Elastic 默认一次返回10条结果，可以通过size字段改变这个设置。 $ curl 'localhost:9200/accounts/person/_search' -d ' { \"query\" : { \"match\" : { \"desc\" : \"管理\" }}, \"size\": 1 }' 上面代码指定，每次只返回一条结果。 还可以通过from字段，指定位移。 $ curl 'localhost:9200/accounts/person/_search' -d ' { \"query\" : { \"match\" : { \"desc\" : \"管理\" }}, \"from\": 1, \"size\": 1 }' 上面代码指定，从位置1开始（默认是从位置0开始），只返回一条结果。 ","date":"2019-03-30","objectID":"/blog/Docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8elasticsearch/:3:7","series":[],"tags":["docker","es"],"title":"Docker安装部署使用elasticsearch","uri":"/blog/Docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8elasticsearch/#36-全文搜索"},{"categories":[],"content":"3.7 逻辑运算如果有多个搜索关键字， Elastic 认为它们是or关系。 $ curl 'localhost:9200/accounts/person/_search' -d ' { \"query\" : { \"match\" : { \"desc\" : \"软件 系统\" }} }' 上面代码搜索的是软件 or 系统。 如果要执行多个关键词的and搜索，必须使用布尔查询。 $ curl 'localhost:9200/accounts/person/_search' -d ' { \"query\": { \"bool\": { \"must\": [ { \"match\": { \"desc\": \"软件\" } }, { \"match\": { \"desc\": \"系统\" } } ] } } }' ","date":"2019-03-30","objectID":"/blog/Docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8elasticsearch/:3:8","series":[],"tags":["docker","es"],"title":"Docker安装部署使用elasticsearch","uri":"/blog/Docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8elasticsearch/#37-逻辑运算"},{"categories":[],"content":"四、es-head使用方法本质和上面的查询命令一样 ","date":"2019-03-30","objectID":"/blog/Docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8elasticsearch/:4:0","series":[],"tags":["docker","es"],"title":"Docker安装部署使用elasticsearch","uri":"/blog/Docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8elasticsearch/#四es-head使用方法"},{"categories":[],"content":"一、下载nginx镜像并运行容器 docker pull nginx docker run --name nginxtest -d -p 80:80 nginx 容器启动成功后，在阿里云防火墙控制台开启80端口，访问公网ip，可以跳转到“Welcome to nginx”。 ","date":"2019-03-23","objectID":"/blog/Docker%E5%AE%89%E8%A3%85nginx%E5%B9%B6%E9%85%8D%E7%BD%AEwordpress%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/:1:0","series":[],"tags":["docker","nginx"],"title":"Docker安装nginx并配置wordpress反向代理","uri":"/blog/Docker%E5%AE%89%E8%A3%85nginx%E5%B9%B6%E9%85%8D%E7%BD%AEwordpress%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/#一下载nginx镜像并运行容器"},{"categories":[],"content":"二、复制nginx配置文件至宿主机 # 复制 nginxtest 容器中 /etc/nginx/nginx.conf 文件夹到宿主机的 /home/wxz/nginx/conf 路径下 docker cp nginx:/etc/nginx/nginx.conf /home/wxz/nginx/conf # 复制 nginxtest 容器中 /etc/nginx/conf.d/ 文件夹到宿主机的 /home/wxz/nginx/conf/conf.d/ 路径下(文件夹结尾用/区分) docker cp nginx:/etc/nginx/conf.d/ /home/wxz/nginx/conf/conf.d/ 这一步不能省略，否则启动nginx容器设置挂载时会失败，因为nginx.conf文件会被当成是文件夹。 ","date":"2019-03-23","objectID":"/blog/Docker%E5%AE%89%E8%A3%85nginx%E5%B9%B6%E9%85%8D%E7%BD%AEwordpress%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/:2:0","series":[],"tags":["docker","nginx"],"title":"Docker安装nginx并配置wordpress反向代理","uri":"/blog/Docker%E5%AE%89%E8%A3%85nginx%E5%B9%B6%E9%85%8D%E7%BD%AEwordpress%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/#二复制nginx配置文件至宿主机"},{"categories":[],"content":"三、启动正式的nginx容器并设置挂载 # 先删除测试用nginx容器 docker stop nginxtest dockers rm nginxtest # 启动正式nginx容器并设置挂载 docker run --name mynginx -d -p 80:80 -v /home/wxz/nginx/html:/usr/share/nginx/html -v /home/wxz/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /home/wxz/nginx/conf/conf.d:/etc/nginx/conf.d -v /home/wxz/nginx/logs:/var/log/nginx nginx ","date":"2019-03-23","objectID":"/blog/Docker%E5%AE%89%E8%A3%85nginx%E5%B9%B6%E9%85%8D%E7%BD%AEwordpress%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/:3:0","series":[],"tags":["docker","nginx"],"title":"Docker安装nginx并配置wordpress反向代理","uri":"/blog/Docker%E5%AE%89%E8%A3%85nginx%E5%B9%B6%E9%85%8D%E7%BD%AEwordpress%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/#三启动正式的nginx容器并设置挂载"},{"categories":[],"content":"四、修改nginx配置文件，添加反向代理查看宿主机的nginx.conf文件配置： user nginx; worker_processes 1; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf; } nginx.conf配置文件中有这么一条配置include /etc/nginx/conf.d/*.conf，所以支持此目录下配置server，此目录也已挂载到宿主机/home/wxz/nginx/conf/conf.d，在宿主机挂载目录下新增一个forestwang.xyz.conf即可。 server { listen 80; server_name 47.110.126.175; charset utf-8; location / { proxy_pass http://内网IP:端口; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } } **注：**此处配置的是nginx监听公网的80端口，然后将内网的wordpress端口转发出去，因为是2个容器之间通信，不能用localhost，除此之外还需要在wordpress设置中将站点地址设置成公网ip:80端口","date":"2019-03-23","objectID":"/blog/Docker%E5%AE%89%E8%A3%85nginx%E5%B9%B6%E9%85%8D%E7%BD%AEwordpress%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/:4:0","series":[],"tags":["docker","nginx"],"title":"Docker安装nginx并配置wordpress反向代理","uri":"/blog/Docker%E5%AE%89%E8%A3%85nginx%E5%B9%B6%E9%85%8D%E7%BD%AEwordpress%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/#四修改nginx配置文件添加反向代理"},{"categories":[],"content":"四、修改nginx配置文件，添加反向代理查看宿主机的nginx.conf文件配置： user nginx; worker_processes 1; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf; } nginx.conf配置文件中有这么一条配置include /etc/nginx/conf.d/*.conf，所以支持此目录下配置server，此目录也已挂载到宿主机/home/wxz/nginx/conf/conf.d，在宿主机挂载目录下新增一个forestwang.xyz.conf即可。 server { listen 80; server_name 47.110.126.175; charset utf-8; location / { proxy_pass http://内网IP:端口; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } } **注：**此处配置的是nginx监听公网的80端口，然后将内网的wordpress端口转发出去，因为是2个容器之间通信，不能用localhost，除此之外还需要在wordpress设置中将站点地址设置成公网ip:80端口","date":"2019-03-23","objectID":"/blog/Docker%E5%AE%89%E8%A3%85nginx%E5%B9%B6%E9%85%8D%E7%BD%AEwordpress%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/:4:0","series":[],"tags":["docker","nginx"],"title":"Docker安装nginx并配置wordpress反向代理","uri":"/blog/Docker%E5%AE%89%E8%A3%85nginx%E5%B9%B6%E9%85%8D%E7%BD%AEwordpress%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/#注此处配置的是nginx监听公网的80端口然后将内网的wordpress端口转发出去因为是2个容器之间通信不能用localhost除此之外还需要在wordpress设置中将站点地址设置成公网ip80端口"},{"categories":[],"content":"五、Wordpress设置wordpress设置-\u003e常规选项里，URL地址必须设置为公网IP。如果设置成公网IP:wordpress端口，则会跳转到此端口，访问失败。 参考：https://www.zuimoban.com/php/wordpress/11678.html ","date":"2019-03-23","objectID":"/blog/Docker%E5%AE%89%E8%A3%85nginx%E5%B9%B6%E9%85%8D%E7%BD%AEwordpress%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/:5:0","series":[],"tags":["docker","nginx"],"title":"Docker安装nginx并配置wordpress反向代理","uri":"/blog/Docker%E5%AE%89%E8%A3%85nginx%E5%B9%B6%E9%85%8D%E7%BD%AEwordpress%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/#五wordpress设置"},{"categories":[],"content":"一、下载wordpress镜像并启动容器 # docker pull wordpress # docker run --name mywordpress -e WORDPRESS_DB_HOST=IP:3306 -e WORDPRESS_DB_USER=**** -e WORDPRESS_DB_PASSWORD=****** -e WORDPRESS_DB_NAME=wordpress -p 8080:80 -v /home/wxz/wordpress:/var/www/html -d wordpress 由于我的数据库也是docker启动的，配置mysql的IP时不能使用localhost，需要使用内网IP，否则俩容器间不能正常连接。 容器启动成功后在阿里云开启80端口，可访问成功。首次访问要注册管理员账号，并简单配置。 wordpress仪表盘 wordpress文件目录 数据库目录 ","date":"2019-03-10","objectID":"/blog/%E5%BC%84%E4%B8%AAwordpress%E7%8E%A9%E7%8E%A9/:1:0","series":["弄个blog玩玩"],"tags":["wordpress","blog"],"title":"弄个wordpress玩玩","uri":"/blog/%E5%BC%84%E4%B8%AAwordpress%E7%8E%A9%E7%8E%A9/#一下载wordpress镜像并启动容器"},{"categories":[],"content":"二、挑选wordpress主题、插件，开始整活主题： Dashscroll 在用的插件： Akismet 反垃圾评论 All-in-One WP Migration：所有博客数据的迁移工具。 只需点击一下即可导入或导出您的博客内容。 Disable Gutenberg Autoptimize Download Free Images Enhanced Media Library QQWorld自动保存图片自动保存远程图片到本地，自动设置特色图片，并且支持机器人采集软件从外部提交。 Wordfence安全：Wordfence安全 - 防病毒，防火墙和恶意软件扫描 WP Githuber MD：一个为 WordPress 网站提供全功能 Markdown 语法的插件。 WP-Optimize - Clean, Compress, Cache：WP-Optimize使您的网站快速高效。 它清理数据库，压缩图像并缓存页面。 加速站点吸引更多的流量和用户。 ","date":"2019-03-10","objectID":"/blog/%E5%BC%84%E4%B8%AAwordpress%E7%8E%A9%E7%8E%A9/:2:0","series":["弄个blog玩玩"],"tags":["wordpress","blog"],"title":"弄个wordpress玩玩","uri":"/blog/%E5%BC%84%E4%B8%AAwordpress%E7%8E%A9%E7%8E%A9/#二挑选wordpress主题插件开始整活"},{"categories":null,"content":" You are not connected to the Internet, only cached pages will be available. ","date":"0001-01-01","objectID":"/offline/:0:0","series":null,"tags":null,"title":"Offline","uri":"/offline/#"}]